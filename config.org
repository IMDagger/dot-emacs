#+TITLE: config.org
#+DESCRIPTION: Configuration options loaded at Emacs startup.
#+AUTHOR: Chris Barrett
#+OPTIONS: toc:3 num:nil ^:nil

This is the main customisation file for this Emacs config. =org-babel= is used
to generate the elisp file that will actually be loaded by Emacs.

* Define var to enable/disable vim keybindings
#+begin_src emacs-lisp
(defvar cb:use-vim-keybindings? t
  "Set to nil to disable Evil-mode and associated key bindings.")
#+end_src
* Remove all GUI elements except the mode line
#+begin_src emacs-lisp
(when (fboundp 'scroll-bar-mode)   (scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode)     (tool-bar-mode -1))
(when (fboundp 'blink-cursor-mode) (blink-cursor-mode -1))
(when (fboundp 'menu-bar-mode)     (menu-bar-mode (if (display-graphic-p) +1 -1)))
#+end_src

* Increase GC threshold
This is recommended to prevent extensions like =flx= from triggering excessive
GCs during normal opertion.
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 1024 1024 20))
#+end_src
* Add additional directories to the Emacs load-path
#+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(add-to-list 'load-path (concat (getenv "HOME") "/Dropbox/"))
(add-to-list 'load-path (concat user-emacs-directory "lisp"))
(add-to-list 'load-path (concat user-emacs-directory "lib"))
#+end_src
* Install core packages
These packages are utilities required by the configuration infrastructure.
#+begin_src emacs-lisp
(defun cb:install-package (pkg &optional require?)
  "Install PKG unless it has already been installed.
Also require the package when REQUIRE? is set."
  (unless (package-installed-p pkg) (package-install pkg))
  (when require? (require pkg)))

(cb:install-package 'dash t)
(cb:install-package 'dash-functional t)
(cb:install-package 's t)
(cb:install-package 'f t)
(cb:install-package 'async t)
(cb:install-package 'noflet t)
(cb:install-package 'diminish t)
(cb:install-package 'bind-key t)
#+end_src
* dash.el extensions
** combinator aliases
#+begin_src emacs-lisp
(defalias 'AP 'funcall)
(defalias 'K '-const)
(defalias 'I 'identity)
#+end_src
** dash-functional extension macros
#+begin_src emacs-lisp
(eval-and-compile
  (defun cblib:quote-if-fn (fn)
    (if (symbolp fn) `',fn fn)))

(defmacro N (fn)
  "Like `-not', but does not require FN to be quoted."
  `(-not ,(cblib:quote-if-fn fn)))

(defmacro ~ (fn &rest args)
  "Like `-partial', but does not require FN to be quoted."
  `(-partial ,(cblib:quote-if-fn fn) ,@args))

(defmacro ~R (fn &rest args)
  "Like `-rpartial', but does not require FN to be quoted."
  `(-partial ,(cblib:quote-if-fn fn) ,@args))

(defmacro π (&rest fns)
  "Like `-juxt', but does not require FNS to be quoted."
  `(-juxt ,@(-map 'cblib:quote-if-fn fns)))

(defmacro C (&rest fns)
  "Like `-compose', but does not require FNS to be quoted."
  `(-compose ,@(-map 'cblib:quote-if-fn fns)))

(defmacro <> (fn)
  "Like `-flip', but does not require FN to be quoted."
  `(-flip ,(cblib:quote-if-fn fn)))

(defmacro & (&rest fns)
  "Like `-andfn', but does not require FNS to be quoted."
  `(-andfn ,@(-map 'cblib:quote-if-fn fns)))

(defmacro | (&rest fns)
  "Like `-orfn', but does not require FNS to be quoted."
  `(-orfn ,@(-map 'cblib:quote-if-fn fns)))

(defmacro @ (fn)
  "Like `-applify', but does not require FN to be quoted."
  `(-applify ,(cblib:quote-if-fn fn)))

(defun -true-fn (&rest _)
  "Always return t."
  t)

(defun -nil-fn (&rest _)
  "Always return nil."
  nil)
#+end_src
** list extensions
#+begin_src emacs-lisp
(defun -listify (x)
  "Wrap X in a list if it is not a list."
  (if (listp x)
      x
    (list x)))

(defun -uniq-by (selector-fn list)
  "Remove duplicates in the given sequence using a function.

- SELECTOR-FN takes the current element and returns the item to compare.

- LIST is the sequence to transform."
  ;; Cache the items compared using selector-fn for later comparisons. This
  ;; alleviates the need for an additional traversal.
  (let (transformed)
    (--reduce-r-from
     (let ((cur (funcall selector-fn it)))
       (if (-contains? transformed cur)
           acc
         (push cur transformed)
         (cons it acc)))
     nil
     list)))
#+end_src
* s.el extensions
#+begin_src emacs-lisp
(defun s-alnum-only (s)
  "Remove non-alphanumeric characters from S."
  (with-temp-buffer
    (insert s)
    (goto-char (point-min))
    (while (search-forward-regexp (rx (not alnum)) nil t)
      (replace-match ""))
    (buffer-string)))

(defun s-unlines (&rest strs)
  "Join STRS with newlines."
  (s-join "\n" strs))

(defmacro s-lex-cat (&rest format-strs)
  "Concatenate FORMAT-STRS then pass them to `s-lex-format'."
  `(s-lex-format ,(apply 'concat format-strs)))

(defmacro s-with-temp-buffer (&rest body)
  "Evaluate BODY in a temporary buffer and return the buffer string."
  (declare (indent 0) (debug t))
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defalias 's-no-props 'substring-no-properties)

(defun s-split-sexps (str)
  "Split STR by sexp boundaries."
  (with-temp-buffer
    (insert str)
    (goto-char (point-min))
    ;; Collect sexps in buffer.
    (let (acc (pt (point-min)))
      (until (eobp)
        (forward-sexp)
        (setq acc (cons (s-trim (buffer-substring pt (point)))
                        acc))
        (setq pt (point)))

      (-remove 's-blank? (nreverse acc)))))
#+end_src
* Convenience macros
** define =until=, the logical opposite of =while=
#+begin_src emacs-lisp
(defmacro until (test &rest body)
  "If TEST yields nil, eval BODY... and repeat.
The order of execution is thus TEST, BODY, TEST, BODY and so on
until TEST returns non-nil."
  (declare (indent 1))
  `(while (not ,test)
     ,@body))
#+end_src
** Lambda-function with destructuring args
#+begin_src emacs-lisp
(defmacro lambda+ (arglist &rest body)
  "A lambda function supporting argument destructuring.

ARGLIST is a full Common Lisp arglist.  Its bindings are availabe
in BODY.

\(fn ARGS [DOCSTRING] [INTERACTIVE] BODY)"
  (declare (doc-string 2) (indent defun)
           (debug (&define lambda-list
                           [&optional stringp]
                           [&optional ("interactive" interactive)]
                           def-body)))
  `(lambda (&rest args)
     (cl-destructuring-bind ,arglist args
       ,@body)))
#+end_src
** Macros for defining hooks
#+begin_src emacs-lisp
(defun cb-lib:format-message (category desc body)
  (format "[%s]: %s\n%s\n" category desc body))

(cl-defmacro hook-fn (hook &rest body
                           &key local append (arglist '(&rest _args))
                           &allow-other-keys)
  "Execute forms when a given hook is called.

- HOOK is the name of the hook.

- BODY is a list of forms to evaluate when the hook is run.

- APPEND and LOCAL are passed to the underlying call to `add-hook'.

- ARGLIST overrides the default arglist for the hook's function.

\(fn hook &rest body &key local append arglist)"
  (declare (indent 1) (doc-string 2))

  (cl-assert (symbolp (eval hook)))

  (let ((bod
         ;; Remove keyword args from body.
         `(progn ,@(->> body
                     (-partition-all-in-steps 2 2)
                     (--drop-while (keywordp (car it)))
                     (apply '-concat))))
        (file (or byte-compile-current-file load-file-name)))
    `(progn
       (add-hook ,hook
                 (lambda ,arglist
                   ;; Do not allow errors to propagate from the hook.
                   (condition-case-unless-debug err
                       ,bod
                     (error
                      (message
                       (cb-lib:format-message
                        ,(if file
                             (format "%s in %s" (eval hook) file)
                           hook)
                        "Error raised in hook"
                        (error-message-string err))))))
                 ,append ,local)
       ,hook)))

(defmacro hook-fns (hooks &rest args)
  "A wrapper for `hook-fn', where HOOKS is a list of hooks.

\(fn hooks &rest body &key local append arglist)"
  (declare (indent 1) (doc-string 2))
  `(progn
     ,@(--map `(hook-fn ',it ,@args)
              (eval hooks))))
#+end_src
** Define a wrapper for the eval-after-load+progn idiom
#+begin_src emacs-lisp
(defmacro after (features &rest body)
  "Like `eval-after-load' - once all FEATURES are loaded, execute the BODY.
FEATURES may be a symbol or list of symbols."
  (declare (indent 1))
  ;; Wrap body in a descending list of `eval-after-load' forms.
  ;; The last form is eval'd to remove its quote.
  (eval (->> (-listify (eval features))
          (--map `(eval-after-load ',it))
          (--reduce-from `'(,@it ,acc)
                         `'(progn ,@body)))))

#+end_src
** define a shorthand for anonymous interactive commands
#+begin_src emacs-lisp
(defmacro command (&rest body)
  "Declare an `interactive' command with BODY forms."
  `(lambda (&optional _arg &rest _args)
     (interactive)
     ,@body))
#+end_src
** test if a symbol is bound and not nil
#+begin_src emacs-lisp
(defmacro true? (sym)
  "Test whether SYM is bound and non-nil."
  `(and (boundp ',sym) (eval ',sym)))
#+end_src
** Key binding commands
#+begin_src emacs-lisp
(cl-defmacro bind-keys (&rest
                        bindings
                        &key map hook overriding?
                        &allow-other-keys)
  "Variadic form of `bind-key'.
- MAP is an optional keymap.  The bindings will only be enabled
  when this keymap is active.

- OVERRIDING? prevents other maps from overriding the binding.  It
  uses `bind-key*' instead of the default `bind-key'.

- HOOK is a hook or list of hooks. The bindings will be made to
  the specified keymap MAP, or using `local-set-key' is no keymap
  is specified.

- BINDINGS are alternating strings and functions to use for
  keybindings."
  (declare (indent 0))
  (cl-assert (not (and map overriding?)))
  (let ((bs (->> bindings (-partition-all 2) (--remove (keywordp (car it))))))
    `(progn
       ,@(cl-loop for (k f) in bs collect
                  (cond
                   (overriding?
                    `(bind-key* ,k ,f))
                   (hook
                    `(hook-fns ',(-listify hook)
                       ;; If there is a map specified, bind to that
                       ;; map. Otherwise fall back on `local-set-key' for
                       ;; bindings.
                       (if (true? ,map)
                           (bind-key ,k ,f ,map)
                         (local-set-key ,k ,f))))
                   (t
                    `(bind-key ,k ,f ,map)))))))

(defmacro define-keys (keymap &rest bindings)
  "Variadic form of `define-key'.

- KEYMAP is a keymap to add the bindings to.

- BINDINGS are the bindings to add to the keymap."
  (declare (indent 1))
  (let ((bs (->> bindings (-partition-all 2) (--remove (keywordp (car it))))))
    `(progn
       ,@(cl-loop for (k f) in bs
                  collect `(define-key
                             ,keymap
                             ,(if (stringp k) `(kbd ,k) k)
                             ,f)))))

(defun buffer-local-set-key (key command)
  "Map KEY to COMMAND in this buffer alone."
  (interactive "KSet key on this buffer: \naCommand: ")
  (let ((mode-name (intern (format "%s-magic" (buffer-name)))))
    (eval
     `(define-minor-mode ,mode-name
        "Automagically built minor mode to define buffer-local keys."))
    (let* ((mapname (format "%s-map" mode-name))
           (map (intern mapname)))
      (unless (boundp (intern mapname))
        (set map (make-sparse-keymap)))
      (eval
       `(define-key ,map ,key ',command)))
    (funcall mode-name t)))
#+end_src
* Convenience functions
** current region
#+begin_src emacs-lisp
(defun current-region (&optional no-properties)
  "Return the current active region, or nil if there is no region active.
If NO-PROPERTIES is non-nil, return the region without text properties."
  (when (region-active-p)
    (funcall (if no-properties 'buffer-substring-no-properties 'buffer-substring)
             (region-beginning)
             (region-end))))
#+end_src
** current line's contents
#+begin_src emacs-lisp
(cl-defun current-line (&optional (move-n-lines 0))
  "Return the line at point, or another line relative to this line.
MOVE-N-LINES is an integer that will return a line forward if
positive or backward if negative."
  (save-excursion
    (forward-line move-n-lines)
    (buffer-substring (line-beginning-position) (line-end-position))))
#+end_src
** collapse vertical whitespace
#+begin_src emacs-lisp
(cl-defun collapse-vertical-whitespace (&optional (to-n-lines 1))
  "Collapse blank lines around point.
TO-N-LINES is the number of blank lines to insert afterwards."
  (interactive "*nCollapse to N blanks: ")
  (save-excursion
    ;; Delete blank lines.
    (search-backward-regexp (rx (not (any space "\n"))) nil t)
    (forward-line 1)
    (while (s-matches? (rx bol (* space) eol) (current-line))
      (forward-line)
      (join-line))
    ;; Open a user-specified number of blanks.
    (open-line to-n-lines)))
#+end_src
** move point to the end of the buffer for inserting text
#+begin_src emacs-lisp
(defun cb:append-buffer ()
  "Enter insertion mode at the end of the current buffer."
  (interactive)
  (goto-char (point-max))
  (when (fboundp 'evil-insert-state)
    (evil-insert-state)))
#+end_src
* Path variables
Define important paths that should be global throughout the configuration.
** Define special paths
These paths should be named.
#+begin_src emacs-lisp
(defconst user-home-directory    (concat (getenv "HOME") "/"))
(defconst user-dropbox-directory (concat user-home-directory "Dropbox/"))
(defconst user-mail-directory    (f-join user-home-directory "Maildir"))
#+end_src
These common paths should be named and created if necessary.
#+begin_src emacs-lisp
(defmacro define-path (sym path)
  "Define a subfolder of the `user-emacs-directory'.
SYM is declared as a special variable set to PATH.
This directory tree will be added to the load path if ADD-PATH is non-nil."
  `(defconst ,sym
     (let ((dir (f-join user-emacs-directory ,path)))
       (unless (file-exists-p dir) (make-directory dir))
       dir)))

(define-path cb:assets-dir    "assets/")
(define-path cb:autosaves-dir "tmp/autosaves/")
(define-path cb:backups-dir   "backups/")
(define-path cb:bin-dir       "bin/")
(define-path cb:el-get-dir    "el-get")
(define-path cb:elpa-dir      "elpa/")
(define-path cb:etc-dir       "etc/")
(define-path cb:src-dir       "src")
(define-path cb:tmp-dir       "tmp/")
(define-path cb:yasnippet-dir "snippets/")
(define-path cb:info-dir      "info")
(define-path cb:lib-dir       "lib/")
(define-path cb:lisp-dir      "lisp/")
#+end_src
** Add subdirs for lisp src directories to load path
#+begin_src emacs-lisp
(-each (->> (list cb:lib-dir cb:lisp-dir)
         (--mapcat (f-directories it nil t)))
       (~ add-to-list 'load-path))
#+end_src
** Use the version of emacs in ./src for C sources.
#+begin_src emacs-lisp
(setq source-directory
      (f-join cb:src-dir (format "emacs-%s.%s"
                                 emacs-major-version
                                 emacs-minor-version)))
#+end_src
** Add downloaded sources to the info path.
#+begin_src emacs-lisp
(after 'info
  (add-to-list 'Info-default-directory-list (f-join source-directory "info/"))
  (add-to-list 'Info-additional-directory-list cb:info-dir))
#+end_src
** Define org directory and default notes file.
#+begin_src emacs-lisp
(setq org-directory (f-join user-home-directory "org")
      org-default-notes-file (f-join org-directory "notes.org"))
#+end_src
** Define path to ledger file.
#+begin_src emacs-lisp
(defvar ledger-file (f-join org-directory "accounts.ledger"))
#+end_src
* Modal view macros
Define macros for creating /modal views/. These are commands that, when invoked,
show a particular buffer and delete all other windows. They restore the previous
window state when closed.
** Define a macro that allows window restoration
#+begin_src emacs-lisp
(defun deep-replace (target rep tree)
  "Replace TARGET with REP in TREE."
  (cond ((equal target tree) rep)
        ((atom tree)         tree)
        (t
         (--map (deep-replace target rep it) tree))))

(defmacro with-window-restore (&rest body)
  "Declare an action that will eventually restore window state.
The original state can be restored by calling (restore) in BODY."
  (declare (indent 0))
  (let ((register (cl-gensym)))
    `(progn
       (window-configuration-to-register ',register)
       ,@(deep-replace '(restore)
                       `(ignore-errors
                          (jump-to-register ',register))
                       body))))
#+end_src
** Define a way to decorate a function to make it behave modally
#+begin_src emacs-lisp
(cl-defmacro declare-modal-view (command &optional (quit-key "q"))
  "Advise a given command to restore window state when finished."
  `(defadvice ,command (around
                        ,(intern (format "%s-wrapper" command))
                        activate)
     "Auto-generated window restoration wrapper."
     (with-window-restore
       ad-do-it
       (delete-other-windows)
       (buffer-local-set-key (kbd ,quit-key) (command (kill-buffer) (restore))))))
#+end_src
** Define a high-level way to declare modal commands
#+begin_src emacs-lisp
(cl-defmacro declare-modal-executor
    (name &optional &key command bind restore-bindings)
  "Execute a command with modal window behaviour.

- NAME is used to name the executor.

- COMMAND is a function or sexp to evaluate.

- BIND is a key binding or list thereof used to globally invoke the command.

- RESTORE-BINDINGS are key commands that will restore the buffer
  state. If none are given, BIND will be used as the restore
  key."
  (declare (indent defun))
  (let ((fname (intern (format "executor:%s" name)))
        (bindings (if (listp bind) bind `'(,bind))))
    `(progn
       (defun ,fname ()
         ,(format "Auto-generated modal executor for %s" name)
         (interactive)
         (with-window-restore
           ;; Evaluate the command.
           ,(cond ((interactive-form command) `(call-interactively ',command))
                  ((functionp command)        `(funcall #',command))
                  (t                           command))
           (delete-other-windows)
           ;; Configure restore bindings.
           (--each (or ,restore-bindings ,bindings)
             (buffer-local-set-key (kbd it) (command (bury-buffer) (restore))))))

       ;; Create global hotkeys
       (--each ,bindings
         (eval `(bind-key* ,it ',',fname))))))
#+end_src
* Option pickers
** Define face for keys in option pickers
#+begin_src emacs-lisp
(defface option-key
  `((t (:foreground "red")))
  "Face for key highlight in search method prompt"
  :group 'options)

#+end_src
** Define utilities for formatting options
#+begin_src emacs-lisp
(defun cb-lib:columnate-lines (lines column-width)
  "Columnate LINES by splitting the lines into two lists then
zipping them together again, such that:

  '(A B C D)

becomes:

  A C
  B D

COLUMN-WIDTH sets the width of each column."
  (let* ((mid (ceiling (/ (length lines) 2.0)))
         (xs (-slice lines 0 mid))
         (ys (-slice lines mid)))
    (->>
        ;; Add an extra line to YS if there is an odd number of options so
        ;; the zip does not discard an option.
        (if (/= (length xs) (length ys))
            (-concat ys '(""))
          ys)
      (-zip-with
       (lambda (l r) (concat (s-pad-right column-width " " l) r)) xs)
      (s-join "\n"))))

(defun cb-lib:maybe-columnate-lines (thresh-hold column-width lines)
  "Return a formatted string that may columnate the input.
The columnation will occur if LINES exceeds THRESH-HOLD in length.
COLUMN-WIDTH specifies the width of columns if columnation is used."
  (if (< (length lines) thresh-hold)
      (s-join "\n" lines)
    (cb-lib:columnate-lines lines column-width)))
#+end_src
** Define utilities for reading options from the user
#+begin_src emacs-lisp
(defun cb-lib:read-opt (option-key-fn options)
  "Read an option from the user.
Returns the element in OPTIONS matching the key event. The \"q\"
key will abort the loop if there is no option bound to \"q\"."
  (let ((c (read-char-choice "" (-concat
                                 (-map (-compose 'string-to-char option-key-fn) options)
                                 (list ?\q)))))
    (or
     ;; Return option with the read key.
     (-first (-compose (~ equal c) 'string-to-char option-key-fn)
             options)
     ;; Cancel if the user had entered \q\ and no option was matched.
     (user-error ""))))

(defun window-bounds ()
  "The width of the selected window, minus the fringe."
  (- (window-width)
     (fringe-columns 'left)
     (fringe-columns 'right)))

(defun read-option (title option-key-fn option-name-fn options)
  "Prompt the user to select from a list of choices.
Return the element in a list of options corresponding to the user's selection.

- TITLE is the name of the buffer that will be displayed.

- OPTION-KEY-FN is a function that returns the key (as a string)
  to use for a given option.

- OPTION-NAME-FN is a function that returns a string describing a given option.

- OPTIONS is a list of items to present to the user."
  (save-excursion
    (save-window-excursion
      ;; Split the window and create a buffer containing the options.

      (let ((win (split-window-below)))
        (select-window win)
        (with-current-buffer (get-buffer-create title)
          (set-window-buffer win (current-buffer))

          ;; 1. Format the options for insertion.

          (let* ((longest-key
                  (-max (-map (-compose 'length option-key-fn) options)))
                 ;; Transform the options list into a list of lines of
                 ;; "[key] desc"
                 (lines
                  (->> options
                    (-sort (-on 'string< (-compose 's-downcase option-key-fn)))
                    (--map
                     (let ((key
                            (propertize (funcall option-key-fn it) 'face 'option-key)))
                       (format " %s %s"
                               (s-pad-right
                                (+ 2 longest-key) ; Offset by length of square brackets.
                                " " (concat "[" key "]"))
                               (funcall option-name-fn it)))))))

            (erase-buffer)
            (insert
             ;; Show small numbers of options in a single column. If the number
             ;; of lines exceeds 3, split into 2 columns.
             (cb-lib:maybe-columnate-lines 3
                                           (/ (window-bounds) 2)
                                           lines))

            ;; 2. Prepare window.

            (goto-char (point-min))
            (fit-window-to-buffer)

            ;; 3. Read selection from user.
            (unwind-protect
                (cb-lib:read-opt option-key-fn options)
              (kill-buffer title))))))))

#+end_src
** Define high-level macro for declaring an option picker
#+begin_src emacs-lisp
(cl-defmacro define-command-picker (name &key title options)
  "Define a command that will display an option picker for the user.

- NAME is the name of the command.

- TITLE is the name of the options buffer to display.

- OPTIONS is a list of options.

Each option is a list of the form (KEY LABEL COMMAND [&key MODES WHEN UNLESS]), where:

- KEY is a string representing the key sequence for the option

- LABEL is a string describing the option

- COMMAND is the command that will be called if this option is selected

- The optional predicates MODES, WHEN and UNLESS control whether
  an option should be displayed. MODES is a symbol or list of
  symbols naming the modes in which the option is available. WHEN
  and UNLESS are nullary functions.

If the predicates are omitted the option will always be shown."
  (cl-assert (not (null options)))
  (cl-assert (stringp title))
  (let ((varname (intern (format "%s-options" name))))
    `(progn

       (defvar ,varname nil ,(format "The list of options shown by `%s'" name))
       (setq ,varname ,options)

       (defun ,name ()
         "Auto-generated option picker."
         (interactive)
         (cl-destructuring-bind (_ _ fn &rest rst)
             (read-option ,title 'car 'cadr
                          ;; Call the predicates for each option to determine
                          ;; whether to display it.
                          (-filter (lambda+
                                     ((&key modes
                                            (when '-true-fn)
                                            (unless '-nil-fn)
                                            &allow-other-keys))
                                     (and
                                      (if modes
                                          (apply 'derived-mode-p (-listify modes))
                                        t)
                                      (funcall when)
                                      (not (funcall unless))))
                                   ,varname))
           ;; Call the option selected by the user.
           (if (commandp fn)
               (call-interactively fn)
             (funcall fn)))))))
#+end_src
* Shell convenience functions
#+begin_src emacs-lisp
(defvar %-sudo-liftable-commands '(%-sh
                                   %-async
                                   %-string
                                   shell-command
                                   async-shell-command
                                   shell-command-to-string)
  "A list of commands that may be escalated using the `%-sudo' macro.

`%-sudo' operates by modifying the string passed to the shell.
For this to work, all commands in this list must accept a string
as their first parameter.")

(defalias '%-quote 'shell-quote-argument)

(defun %-sh (command &rest arguments)
  "Run COMMAND with ARGUMENTS, returning the exit code."
  (shell-command (concat command " " (s-join " " arguments))))

(defun %-string (command &rest arguments)
  "Run COMMAND with ARGUMENTS, returning its output as a string."
  (s-trim-right
   (shell-command-to-string (concat command " " (s-join " " arguments)))))

(defun %-async (command &rest arguments)
  "Run COMMAND with ARGUMENTS asynchronously."
  (save-window-excursion
    (async-shell-command (concat command " " (s-join " " arguments)))))

(defun %-can-sudo-without-passwd? ()
  "Test whether we are currently able to sudo without entering a password."
  (zerop (shell-command "sudo -n true")))

(defmacro %-sudo (command)
  "Execute a shell command with escalated privileges.

COMMAND must be a direct call to one of the forms listed in
`sudo-liftable-commands'.

The sudo command will likely be configured with a timeout on your
system.  The user will be interactively prompted for their
password if necessary.  Subsequent calls to sudo within the
timeout period will not require the password again."
  (cl-assert command)
  (cl-assert (listp command))
  (cl-assert (-contains? %-sudo-liftable-commands (car command)))

  ;; Reach into the command and replace the direct shell command argument,
  ;; wrapping it with a call to sudo.
  ;;
  ;; There are two execution paths, depending on whether the user is currently
  ;; authenticated with sudo.
  (cl-destructuring-bind (fn cmd &rest args) command
    (let ((g-passwd (cl-gensym))
          (g-result (cl-gensym)))
      `(-if-let (,g-passwd (unless (%-can-sudo-without-passwd?)
                             (read-passwd "Password: ")))

           ;; Path 1. The password is required: Consume the password and
           ;; tidy the shell output. Finally, delete the password string from
           ;; memory.
           (unwind-protect
               (let ((,g-result
                      (,fn
                       (format "echo %s | sudo -S %s"
                               (shell-quote-argument ,g-passwd) ,cmd)
                       ,@args)))
                 ;; Annoyingly, the password prompt gets prepended to string
                 ;; output and must be stripped.
                 (if (stringp ,g-result)
                     (s-chop-prefix "Password:" ,g-result)
                   ,g-result))
             ;; Clear the password from memory.
             (clear-string ,g-passwd))

         ;; Path 2. We are within the sudo timeout period: The password is not
         ;; required and we can call the command with sudo prefixed.
         (,fn (format "sudo %s" ,cmd) ,@args)))))
#+end_src
* Buffer and window list commands
** Filter buffer list
#+begin_src emacs-lisp
(cl-defmacro --filter-buffers (pred-form &optional (bufs '(buffer-list)))
  "Anaphoric form of `-filter-buffers'"
  `(--filter (with-current-buffer it ,pred-form) ,bufs))
#+end_src
** Map over buffer list
#+begin_src emacs-lisp
(cl-defmacro --map-buffers (form &optional (bufs '(buffer-list)))
  "Anaphoric form of `-map-buffers'"
  `(--map (with-current-buffer it ,form) ,bufs))
#+end_src
** Find first buffer matching predicate
#+begin_src emacs-lisp
(cl-defmacro --first-buffer (pred-form &optional (bufs '(buffer-list)))
  "Anaphoric form of `-first-buffer'"
  `(--first (with-current-buffer it ,pred-form) ,bufs))
#+end_src
** Find first window matching predicate
#+begin_src emacs-lisp
(defalias '-first-window 'get-window-with-predicate)

(defmacro --first-window (pred-form)
  "Anaphoric form of `-first-window'.
Find the first window where PRED-FORM is not nil."
  `(-first-window (lambda (it) ,pred-form)))
#+end_src
** Display a list of buffers, Exposé-style
#+begin_src emacs-lisp
(cl-defun expose-buffers
    (buffers &optional (sort-fn (-on 'string< 'buffer-file-name)))
  "Show an Exposé-style arrangement of BUFFERS."
  (when buffers
    (delete-other-windows)
    (let* ((live (-filter 'buffer-live-p (-sort sort-fn buffers)))
           (padded (if (cl-evenp (length live)) live (nreverse (cons nil (nreverse live)))))
           (bs (apply '-zip (-partition (/ (length padded) 2) padded))))

      (when live
        (switch-to-buffer (caar bs) t))

      ;; Split sensibly for 2-up view, otherwise show a grid.
      (cond
       ((= 1 (length bs))
        (-when-let (bot (cdar bs))
          (select-window (split-window-sensibly))
          (switch-to-buffer bot)))

       (t
        (-each (cdr bs)
               (lambda+ ((top . bot))
                 (select-window (split-window-horizontally))
                 (switch-to-buffer top)
                 (balance-windows)))
        (-each bs
               (lambda+ ((top . bot))
                 (select-window (get-buffer-window top))
                 (when bot
                   (select-window (split-window-vertically))
                   (switch-to-buffer bot)))))))))
#+end_src
* Define commands to filter the list of interned symbols
#+begin_src emacs-lisp
(defun filter-atoms (predicate)
  "Return the elements of the default obarray that match PREDICATE."
  (let (acc)
    (mapatoms (lambda (atom)
                (when (funcall predicate atom)
                  (push atom acc))))
    acc))

(defmacro --filter-atoms (predicate)
  "Anaphoric form of `filter-atoms'.
Return the elements of the default obarray that match PREDICATE."
  `(filter-atoms (lambda (it) ,predicate)))
#+end_src
* Always use y-or-n-p
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
* Define an alias for make-local-hook to prevent errors
#+begin_src emacs-lisp
(defalias 'make-local-hook 'ignore)
#+end_src
* Set default directory
When starting up, set the default dir to the home directory on OS X. This
prevents the app bundle from being used as the default dir.
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
  (unless (ignore-errors (emacs-init-time))
    (setq default-directory user-home-directory)))
#+end_src
* Don't ring the bell on errors
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src
* Don't show startup message
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src
* Don't add anything to the default scratch buffer
#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src
* Highlight active regions, like most editors
#+begin_src emacs-lisp
(setq-default transient-mark-mode t)
#+end_src
* Add commands for asynchronously installing packages
** Define an icon for package-related growl notifications
#+begin_src emacs-lisp
(defvar cbpkg:package-icon (f-join cb:assets-dir "package.png"))
#+end_src
** Define a command for updating packages in the background
#+begin_src emacs-lisp
(defun cbpkg:install-packages (pkgs)
  ;; Show summary of packages to be installed.
  (-when-let (len (and pkgs (length pkgs)))
    (growl "Installing Packages"
           (format "%s package%s will be installed or updated:\n%s"
                   len
                   (if (= 1 len) "" "s")
                   (s-join ", " (-map 'pp-to-string pkgs)))
           cbpkg:package-icon)
    ;; Perform installation.
    (-each pkgs 'package-install)))

(defun cbpkg:updateable-packages ()
  "Return the packages with available updates."
  ;; The easiest way to get this info is from the package menu.
  (-keep 'car
         (save-window-excursion
           (save-excursion
             (package-list-packages t)
             (package-menu--find-upgrades)))))

(defun update-packages ()
  "Update all installed packages in the background."
  (interactive)
  (growl "Starting Updates"
         "Updating packages in the background."
         cbpkg:package-icon)
  (async-start

   `(lambda ()
      (load-file ,user-init-file)
      (let ((pkgs (cbpkg:updateable-packages)))
        (cbpkg:install-packages pkgs)
        (length pkgs)))

   (lambda (len)
     (package-initialize)
     (if (zerop len)
         (growl "Updates Finished"
                "No packages needed to be updated."
                cbpkg:package-icon)

       (growl "Updates Finished"
              (concat
               (format "%s package%s %s updated " len
                       (if (= 1 len) "" "s")
                       (if (= 1 len) "was" "were"))
               "and will be loaded next time Emacs is started.")
              cbpkg:package-icon)))))
#+end_src
* OS X
** CONDITIONAL
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
#+end_src
** Set paths
Emacs.app does not inherit the PATH set by shell config files. Set the path
manually as a workaround.
#+begin_src emacs-lisp
(let ((path (->> (list "~/Library/Haskell/bin"
                         "~/.cask/bin"
                         "~/bin"
                         "~/scripts"
                         "/opt/local/bin/"
                         (%-string "echo $PATH"))
                (s-join ":")
                (s-split ":")
                (-map 'f-expand))))
    (setq exec-path (-union path exec-path))
    (setenv "PATH" (s-join ":" exec-path)))
#+end_src
** Override shell
Most packages assume the shell is POSIX-compliant. If the shell is fish, change
to bash to prevent shell commands from borking.
#+begin_src emacs-lisp
(when (s-ends-with? "fish" (getenv "SHELL"))
  (setq shell-file-name "/bin/bash" explicit-shell-file-name shell-file-name)
  (setenv "SHELL"  shell-file-name))
#+end_src
** Use =osx-bbdb= to keep BBDB up-to-date with the OS X Address Book.
#+begin_src emacs-lisp
(unless noninteractive
  (after 'bbdb
    (require 'osx-bbdb)))
#+end_src
** Create terminfo so ansi-term displays shells correctly
#+begin_src emacs-lisp
(let ((terminfo (expand-file-name "~/.terminfo")))
  (unless (file-exists-p terminfo)
    (start-process
     "tic" " tic" "tic"
     "-o" terminfo
     "/Applications/Emacs.app/Contents/Resources/etc/e/eterm-color.ti")))
#+end_src
** Use GNU coreutils version of ls if available.
#+begin_src emacs-lisp
(setq insert-directory-program (or (executable-find "gls") "ls"))
#+end_src
** Use gnutls when sending emails
#+begin_src emacs-lisp
(setq starttls-gnutls-program (executable-find "gnutls-cli")
      starttls-use-gnutls t)
#+end_src
** Define utilities for playing system sounds
#+begin_src emacs-lisp
(defun osx-find-system-sound (name)
  "Find a system alert matching NAME."
  (when (equal system-type 'darwin)
    (-first (~ s-matches? name) (f-files "/System/Library/Sounds"))))

(defun osx-play-system-sound (name)
  "Play alert matching NAME."
  (when (equal system-type 'darwin)
    (-when-let (snd (osx-find-system-sound name))
      (start-process "appt alert" " appt alert" "afplay" snd))))
#+end_src
** Use system clipboard
#+begin_src emacs-lisp
(defun cb:osx-paste ()
  (shell-command-to-string "pbpaste"))

(defun cb:osx-copy (text &optional _push)
  (let ((process-connection-type nil))
    (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
      (process-send-string proc text)
      (process-send-eof proc))))

(unless window-system
  (setq interprogram-cut-function   'cb:osx-copy
        interprogram-paste-function 'cb:osx-paste))
#+end_src
** Enable printing to postscript
#+begin_src emacs-lisp
(defun ps-print-with-faces-dwim ()
  "Perform a context-sensitive printing command."
  (interactive)
  (call-interactively
   (if (region-active-p)
       'ps-print-region-with-faces
     'ps-print-buffer-with-faces)))
#+end_src
*** Set a key binding for the above command.
#+begin_src emacs-lisp
(bind-key* "s-p" 'ps-print-with-faces-dwim)
#+end_src
** Open
*** Open the current directory in the Finder
#+begin_src emacs-lisp
(defun mac-reveal-in-finder ()
  "Open the current directory in the Finder."
  (interactive)
  (%-sh "open ."))
#+end_src
*** Open the thing at point
Define a command that runs =open= in a context-sensitive way.
#+begin_src emacs-lisp
(autoload 'thing-at-point-url-at-point "thingatpt")

(defun cb:visual-url-at-point ()
  "Find a URL at point."
  (or
   ;; Find urls at point.
   (thing-at-point-url-at-point)
   (get-text-property (point) 'shr-url)
   ;; Extract org-mode links.
   (when (and (fboundp 'org-in-regexp)
              (boundp 'org-bracket-link-regexp)
              (org-in-regexp org-bracket-link-regexp 1))
     (org-link-unescape (org-match-string-no-properties 1)))))

(defun mac-open-dwim (open-arg)
  "Pass OPEN-ARG to OS X's open command.
When used interactively, makes a guess at what to pass."
  (interactive
   (list
    (ido-read-file-name
     "Open: " nil (or
                   (cb:visual-url-at-point)
                   (and (boundp 'w3m-current-url) w3m-current-url)
                   (and (derived-mode-p 'dired-mode)
                        (read-file-name(dired-get-file-for-visit)))
                   (buffer-file-name)))))

  (%-sh (format "open '%s'" open-arg)))
#+end_src
*** Evil
Set evil-mode bindings for the previous commands.
#+begin_src emacs-lisp
(after 'evil
  (evil-global-set-key 'normal (kbd "g o") 'mac-open-dwim)
  (evil-global-set-key 'normal (kbd "g O") 'mac-reveal-in-finder))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Notifications
#+begin_src emacs-lisp
(cl-defun growl (title
                 message
                 &optional (icon "/Applications/Emacs.app/Contents/Resources/Emacs.icns"))
  "Display a growl notification.
Fall back to `message' if growlnotify is not installed.
The notification will have the given TITLE and MESSAGE."
  (let ((growl-program "growlnotify"))
    (if (executable-find growl-program)
        ;; Call growl
        (let ((proc (start-process "growl" nil
                                   growl-program
                                   title
                                   "-n" "Emacs"
                                   "-a" "Emacs"
                                   "--image" icon)))
          (process-send-string proc message)
          (process-send-string proc "\n")
          (process-send-eof proc))
      ;; Fall back to message.
      (message "%s. %s" title message))))
#+end_src
* Display-related variables
#+begin_src emacs-lisp
(setq redisplay-dont-pause t
      echo-keystrokes 0.02
      truncate-partial-width-windows nil)
#+end_src
* Use org-mode as the default mode
#+begin_src emacs-lisp
(setq          initial-major-mode 'org-mode)
(setq-default  major-mode         'org-mode)
#+end_src
* File handling
** Don't prompt the user to continue when visiting a file that does not exist
#+begin_src emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)
#+end_src
** Don't use the trash when deleting files--just delete immediately
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash nil)
#+end_src
** Automatically decompress files to read and recompress on write
#+begin_src emacs-lisp
(auto-compression-mode +1)
#+end_src
** Make scripts executable on save
#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src
* Whitespace handling
** Perform whitespace cleanup on save
#+begin_src emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Fix `whitespace-cleanup' bug in Emacs 24
When using `indent-tabs-mode', whitespace cleanup will untabify the buffer,
breaking makefiles.
#+begin_src emacs-lisp
(defadvice whitespace-cleanup (around whitespace-cleanup-indent-tab activate)
  (let ((whitespace-indent-tabs-mode indent-tabs-mode)
        (whitespace-tab-width tab-width))
    ad-do-it))
#+end_src
** Add a space after opening a new comment line
#+begin_src emacs-lisp
(defadvice comment-indent-new-line (after add-space activate)
  (when (and comment-start
             (thing-at-point-looking-at (regexp-quote comment-start)))
    (unless (or (thing-at-point-looking-at (rx (+ space))))
      (just-one-space))))
#+end_src
** Remove trailing whitespace after yanking text
#+begin_src emacs-lisp
(defadvice insert-for-yank (after clean-whitespace)
  (whitespace-cleanup)
  (delete-trailing-whitespace))
#+end_src
* Buffer formatting
** By default, ensure each saved file ends with a newline
#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src
** Don't require two spaces at the end of a sentence
This is a wacky American convention that can't die fast enough.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
** Hide DOS eol characters
#+begin_src emacs-lisp
(hook-fn 'find-file-hook
  "Hide DOS EOL chars."
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M [])
  (aset buffer-display-table ?\^L []))
#+end_src
* Tabs
** Always use spaces instead of tabs.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src
** Set tab width for buffers that use tabs for indentation
#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src
* Fill
** Use auto-fill-mode for org-mode, which is the default text editing mode.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
** Increase the fill column
This defines the maximum column before the line will be wrapped by fill commands
or auto-fill-mode.
#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src
* Bookmarks
I don't actually use this feature, but make sure the bookmarks file is created
in a subdir of the Emacs directory to keep things clean.
#+begin_src emacs-lisp
(setq bookmark-default-file (f-join cb:tmp-dir "bookmarks"))
#+end_src
* Save position in files between sessions
#+begin_src emacs-lisp
(setq save-place-file (f-join cb:tmp-dir "saved-places"))
(setq-default save-place t)

(unless noninteractive
  (require 'saveplace)
  (add-hook 'kill-emacs-hook   'save-place-kill-emacs-hook)
  (add-hook 'kill-buffer-hook  'save-place-to-alist)
  (add-hook 'find-file-hook    'save-place-find-file-hook t)
  (add-hook 'server-visit-hook 'save-place-find-file-hook)
  (add-hook 'server-done-hook  'save-place-kill-emacs-hook))
#+end_src
* Save backup files to a special directory
#+begin_src emacs-lisp
(require 'backup-dir)
(setq auto-save-file-name-transforms `((".*" ,(concat cb:autosaves-dir "\\1") t))
      backup-by-copying        t
      bkup-backup-directory-info `((".*" ,cb:backups-dir ok-create))
      auto-save-list-file-name (concat cb:autosaves-dir "autosave-list")
      delete-old-versions      t
      kept-new-versions        6
      kept-old-versions        2
      version-control          t)
#+end_src
* Initialise recent files list
Recentf adds a recent files list. It is also used by helm and other packages to
show recent files.
#+begin_src emacs-lisp
(require 'recentf)
#+end_src
** Keep the recentf file in tmp
#+begin_src emacs-lisp
(setq recentf-save-file (f-join cb:tmp-dir "recentf"))
#+end_src
** Set limits on the number of files to save with recentf
#+begin_src emacs-lisp
(setq recentf-max-saved-items 50
      recentf-max-menu-items  10)
#+end_src
** Automatically remove deleted files
#+begin_src emacs-lisp
(setq recentf-keep '(file-remote-p file-readable-p))
#+end_src
** Define the files to exclude from recentf
#+begin_src emacs-lisp
(setq recentf-exclude '(
                        ;; Filetypes
                        "\\.elc$"
                        "TAGS"
                        "\\.gz$"
                        "#$"
                        ;; Special directories
                        "/elpa/"
                        "/tmp/"
                        "/temp/"
                        ".emacs.d/url/"
                        "/\\.git/"
                        "/Emacs.app/"
                        ;; Tramp
                        "^/?sudo"
                        ;; Special files
                        "\\.bbdb"
                        "\\.newsrc"
                        "/gnus$"
                        "/gnus.eld$"
                        "\\.ido\\.last"
                        "\\.org-clock-save\\.el$"
                        ))
#+end_src
** Suppress messages when cleaning recent files list
#+begin_src emacs-lisp
(defadvice recentf-cleanup (around hide-messages activate)
  (noflet ((message (&rest args))) ad-do-it))
#+end_src
** Enable recentf
#+begin_src emacs-lisp
(recentf-mode +1)
#+end_src
* Save command history between sessions
** Configure variables.
#+begin_src emacs-lisp
(setq savehist-additional-variables '(search ring regexp-search-ring)
      savehist-autosave-interval    60
      savehist-file                 (f-join cb:tmp-dir "savehist"))
#+end_src
** Safely enable savehist
This can sometimes fail with a void-variable error. In such a
case, just delete the cache and start afresh.
#+begin_src emacs-lisp
(condition-case _
    (savehist-mode +1)
  (void-variable
   (delete-file savehist-file)
   (savehist-mode +1)))
#+end_src
* Tramp
Ensure tramp resources are released properly on exit. This prevents certain
crashes in Emacs 24.
#+begin_src emacs-lisp
(hook-fn 'kill-emacs-hook
  (ignore-errors
    (when (fboundp 'tramp-cleanup-all-buffers)
      (tramp-cleanup-all-buffers))))
#+end_src
* Define command for generating passwords
#+begin_src emacs-lisp
(defun generate-password (length)
  "Generate a password with a given LENGTH."
  (interactive (list (read-number "Password length: " 32)))
  (let ((pass
         (--> (%-string "openssl" "rand" "-base64" (number-to-string length))
           ;; The encoding process will pad with '=' characters to reach a
           ;; length divisible by 4 bytes. Drop this padding.
           (substring it 0 length))))
    (cond
     ((called-interactively-p 'any)
      (kill-new pass)
      (message "Password copied to kill ring."))
     (t
      pass))))
#+end_src
* Use UTF-8 for all text encodings
#+begin_src emacs-lisp
(setq locale-coding-system   'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system        'utf-8)
#+end_src
* Keyboard macros
** Define a way to prompt for input in keyboard macros
#+begin_src emacs-lisp
(defun minibuffer-macro-query (arg)
  "Prompt for input using minibuffer during kbd macro execution.
With prefix ARG, allows you to select what prompt string to use.
If the input is non-empty, it is inserted at point."
  (interactive "P")
  (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
         (input (minibuffer-with-setup-hook (lambda () (kbd-macro-query t))
                  (read-from-minibuffer prompt))))
    (unless (string= "" input) (insert input))))
#+end_src
** Bind the above command during macro definitions
#+begin_src emacs-lisp
(define-key kmacro-keymap (kbd "C-/") 'minibuffer-macro-query)
#+end_src
* Clipboard
#+begin_src emacs-lisp
(setq x-select-enable-clipboard t)
#+end_src
* Input methods
** Use TeX as the default alternative input method
This allows you to enter mathematical symbols easily.
#+begin_src emacs-lisp
(setq default-input-method "TeX")
#+end_src
** Define a key command for setting method
#+begin_src emacs-lisp
(bind-key "C-x C-\\" 'set-input-method)
#+end_src
* Global key bindings
** When on a comment, RET creates a new line that continues the comment
#+begin_src emacs-lisp
(bind-key "RET" 'comment-indent-new-line)
#+end_src
** Define a more ergonomic M-x
#+begin_src emacs-lisp
(bind-key* "S-SPC" 'execute-extended-command)
#+end_src
** Kill buffer and delete window on C-backspace
#+begin_src emacs-lisp
(bind-key* "C-<backspace>"
           (command (cond ((< 1 (length (window-list)))
                           (kill-current-buffer)
                           (delete-window))
                          (t
                           (kill-current-buffer)))))
#+end_src
** Enable debugging
#+begin_src emacs-lisp
(bind-key "C-c e e" 'toggle-debug-on-error)
#+end_src
** Use custom indentation command
#+begin_src emacs-lisp
(define-key prog-mode-map (kbd "M-q") 'indent-dwim)
#+end_src
* Buffer killing
** Define a custom kill command
Buries certain buffers rather than killing them.
#+begin_src emacs-lisp
(defvar cb:kill-buffer-ignored-list
  '("*scratch*" "*Messages*" "*Group*"
    "*shell*" "*eshell*" "*ansi-term*"
    "diary.org" "notes.org"))

(defun kill-current-buffer ()
  "Kill the current buffer.
If this buffer is a member of `cb:kill-buffer-ignored-list, bury it rather than killing it."
  (interactive)
  (if (member (buffer-name (current-buffer)) cb:kill-buffer-ignored-list)
      (bury-buffer)
    (kill-buffer (current-buffer))))

(bind-key* "C-x <backspace>" 'kill-current-buffer)
#+end_src
** Define a command that cleans the buffer list
Does not delete terminals, org buffers, or buffers with a running process.
*** Impl
#+begin_src emacs-lisp
(defun clean-buffers ()
  "Close all buffers not in the ignore list."
  (interactive)
  (delete-other-windows)
  (-each (--filter-buffers
          (not (or (-contains? cb:kill-buffer-ignored-list (buffer-name it))
                   (get-buffer-process it))))
         'kill-buffer))
#+end_src
*** Set key binding
#+begin_src emacs-lisp
(bind-key* "C-c k b"  'clean-buffers)
#+end_src
* Show autoloads in file
#+begin_src emacs-lisp
(defun cb:find-autoloads (buffer)
  (->> (with-current-buffer buffer
         (buffer-substring-no-properties (point-min) (point-max)))
    (s-match-strings-all (rx ";;;###autoload" "\n"
                             (* space) "("(+ (not space)) (+ space) (? "'")
                             (group (+ (not space)))))
    (-map 'cadr)))

(cl-defun show-autoloads (&optional (buffer (current-buffer)))
  "Find the autoloaded definitions in BUFFER"
  (interactive)
  (-if-let (results (-map (~ s-append "\n") (cb:find-autoloads buffer)))
    (with-output-to-temp-buffer "*autoloads*"
      (-each results 'princ))

    (error "No autoloads found in current buffer")))
#+end_src
* Window management
** Expose buffers
#+begin_src emacs-lisp
(defun expose-buffers-by-mode (&optional mode arg)
  "Show all buffers with major mode MODE.
With a prefix ARG, show all buffers"
  (interactive (list
                (->> (--filter-buffers
                      (and (derived-mode-p 'prog-mode 'text-mode)
                           (or current-prefix-arg (buffer-file-name))))
                  (--map-buffers (symbol-name major-mode))
                  (-sort 'string<)
                  (-uniq)
                  (ido-completing-read "Mode: ")
                  (intern))

                current-prefix-arg))
  (expose-buffers (--filter-buffers (and (derived-mode-p mode)
                                         (or arg (buffer-file-name))))))
#+end_src
** Rotate buffers in windows
#+begin_src emacs-lisp
(defun cb:rotate-buffers ()
  "Rotate active buffers, retaining the window layout.
Changes the selected buffer."
  (interactive)
  ;; Bail if there are not enough windows to rotate.
  (unless (> (count-windows) 1)
    (user-error "Cannot rotate single window"))
  ;; Perform rotation.
  (let ((i 1)
        (n-windows (count-windows)))
    (while  (< i n-windows)
      (let* (
             (w1 (elt (window-list) i))
             (w2 (elt (window-list) (+ (% i n-windows) 1)))
             (b1 (window-buffer w1))
             (b2 (window-buffer w2))
             (s1 (window-start w1))
             (s2 (window-start w2))
             )
        (set-window-buffer w1  b2)
        (set-window-buffer w2 b1)
        (set-window-start w1 s2)
        (set-window-start w2 s1)
        (setq i (1+ i))))))

(bind-key* "s-f" 'cb:rotate-buffers)
#+end_src
* Transpose lines
** Define commands to transpose lines
#+begin_src emacs-lisp
(defun move-line-up ()
  "Move the current line up."
  (interactive)
  (if (derived-mode-p 'org-mode)
      (org-move-item-up)

    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode)))

(defun move-line-down ()
  "Move the current line up."
  (interactive)
  (if (derived-mode-p 'org-mode)
      (org-move-item-down)

    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode)))
#+end_src
** Define global key bindings
#+begin_src emacs-lisp
(bind-key* "C-<up>" 'move-line-up)
(bind-key* "C-<down>" 'move-line-down)
#+end_src
* Version Control (VC)
** Do not prompt to follow symlinks
Do not prompt for confirmation when opening a symlink to a file under version
control.
#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src
** Use Git only
Only enable Git by default, since all the projects I work on use Git these days.
#+begin_src emacs-lisp
(setq vc-handled-backends '(Git))
#+end_src
** Autoload functions that are used throughout this config
#+begin_src emacs-lisp
(autoload 'vc-git-root "vc-git")
#+end_src
* Enable commands
Enable commands that are disabled by default.
#+begin_src emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'erase-buffer 'disabled nil)
#+end_src
* Exiting Emacs
** Define custom commands for exiting Emacs
Makes exiting Emacs and killing emacsclient instances consistent.
#+begin_src emacs-lisp
(defun cb:exit-emacs ()
  (interactive)
  (when (yes-or-no-p "Kill Emacs? ")
    (save-buffers-kill-emacs)))

(defun cb:exit-emacs-dwim ()
  (interactive)
  (when (yes-or-no-p "Kill Emacs? ")
    (if (daemonp)
        (server-save-buffers-kill-terminal nil)
      (save-buffers-kill-emacs))))
#+end_src
** Suppress "Active processes exist" query when exiting Emacs
#+begin_src emacs-lisp
(defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
  (noflet ((process-list () nil))
    ad-do-it))
#+end_src
** Rebind exit keys to prevent accidental exits when using org-mode
#+begin_src emacs-lisp
(bind-key* "C-x C-c" (command (message "Type <C-c k k> to exit Emacs")))
(bind-key* "C-c k k" 'cb:exit-emacs-dwim)
(bind-key* "C-c k e" 'cb:exit-emacs)
#+end_src
* Narrowing
** Enable narrowing commands
#+begin_src emacs-lisp
(put 'narrow-to-defun  'disabled nil)
(put 'narrow-to-page   'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+end_src
** Define a narrowing command picker
#+begin_src emacs-lisp
(define-command-picker narrowing-picker
  :title "*Narrowing*"
  :options
  '(("d" "Defun" narrow-to-defun :modes prog-mode)
    ("r" "Region" narrow-to-region :when region-active-p)
    ("w" "Widen" widen :when buffer-narrowed-p)
    ("b" "Block (org)" org-narrow-to-block :modes org-mode)
    ("e" "Element (org)" org-narrow-to-element :modes org-mode)
    ("s" "Subtree (org)" org-narrow-to-subtree :modes org-mode)))
#+end_src
** Create a binding for the narrowing picker
#+begin_src emacs-lisp
(bind-key* "C-x n" 'narrowing-picker)
#+end_src
* Insertion commands
** Insert time stamp with helm
#+begin_src emacs-lisp
(defun insert-timestamp ()
  "Read a timestamp from the user and insert it at point."
  (interactive)
  (let ((time (current-time)))
    (helm :prompt "Timestamp: "
          :buffer "*Helm Timestamp*"
          :sources
          `(((name . "Dates")
             (candidates . ,(list
                             (format-time-string "%d-%m-%y" time)
                             (format-time-string "%d-%m-%Y" time)
                             (format-time-string "%d-%m-%Y %H:%M" time)
                             (format-time-string "%d-%m-%Y %I:%M %p" time)))
             (action . insert)
             (volatile))

            ((name . "Times")
             (candidates . ,(list
                             (format-time-string "%X" time)
                             (format-time-string "%I:%M %p" time)
                             (format-time-string "%I:%M:%S %p" time)))
             (action . insert)
             (volatile))

            ((name . "Special")
             (candidates . ,(list
                             (format-time-string "%d %B, %Y" time)
                             (format-time-string "%Y-%m-%dT%H%M%S%z")))
             (action . insert)
             (volatile))))))
#+end_src
** Insert shebang
#+begin_src emacs-lisp
(defun cb:filename->interpreter (filename)
  (cdr
   (assoc (file-name-extension filename)
          '(("el" . "emacs")
            ("hs" . "runhaskell")
            ("py" . "python")
            ("rb" . "ruby")
            ("sh" . "bash")))))

(defun insert-shebang (cmd)
  "Insert a shebang line at the top of the current buffer.
Prompt for a command CMD if one cannot be guessed."
  (interactive
   (list (or (cb:filename->interpreter buffer-file-name)
             (read-string "Command name: " nil t))))
  (require 'emr)
  (emr-reporting-buffer-changes "Inserted shebang"
    (save-excursion
      (goto-char (point-min))
      (open-line 2)
      (insert (concat "#!/usr/bin/env " cmd)))))
#+end_src
** Insert variable
#+begin_src emacs-lisp
(defun insert-variable (variable)
  "Insert the value of VARIABLE at point."
  (interactive
   (list
    (intern
     (ido-completing-read
      "Variable: "
      (-map 'symbol-name
            (filter-atoms (-orfn 'custom-variable-p 'special-variable-p)))))))
  (insert (pp-to-string (eval variable))))
#+end_src
** Insert GUID
#+begin_src emacs-lisp
(defun make-uuid ()
  "Generate a UUID using the uuid utility."
  (%-string "uuidgen"))

(defun insert-uuid ()
  "Insert a GUID at point."
  (interactive "*")
  (insert (make-uuid)))

(defalias 'insert-guid 'insert-uuid)
#+end_src
** Insert lorem ipsum text
#+begin_src emacs-lisp
(defun insert-lorem-ipsum (n-paragraphs paragraph-length)
  "Insert N-PARAGRAPHS of lorem ipsum text into the current buffer.
PARAGRAPH-LENGTH is one of short, medium, long or verylong."
  (interactive
   (list (read-number "Number of paragraphs: " 3)
         (ido-completing-read "Paragraph length: "
                              '("short" "medium" "long" "verylong"))))
  (let ((url (format "http://loripsum.net/api/%s/%s/plaintext"
                     n-paragraphs paragraph-length)))
    (insert (with-current-buffer (url-retrieve-synchronously url)
              ;; Skip HTTP header.
              (goto-char (point-min))
              (search-forward "\n\n")
              (s-trim (buffer-substring (point) (point-max)))))))
#+end_src
** Command picker
*** Define a command picker for insertion commands
#+begin_src emacs-lisp
(define-command-picker insertion-picker
  :title "*Insert*"
  :options
  '(("F" "File" insert-file)
    ("L" "Lorem Ipsum" insert-lorem-ipsum)
    ("T" "Timestamp" insert-timestamp)
    ("U" "UUID" insert-uuid)
    ("V" "File Local Var" add-file-local-variable)
    ("P" "File Local Var (prop line)" add-file-local-variable-prop-line)))
#+end_src
*** Bind insertion picker to a global key
#+begin_src emacs-lisp
(bind-key* "C-c i" 'insertion-picker)
#+end_src
* Indentation commands
** Define command to remove indentation
*** Impl
#+begin_src emacs-lisp
(defun outdent ()
  "Remove indentation on the current line."
  (interactive "*")
  (save-excursion
    (goto-char (line-beginning-position))
    (delete-horizontal-space)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(bind-key* "<backtab>" 'outdent)
#+end_src
** Define command to indent whole buffer
#+begin_src emacs-lisp
(defun indent-buffer ()
  "Indent the whole buffer."
  (interactive)
  (ignore-errors
    (save-excursion
      (indent-region (point-min) (point-max)))))
#+end_src
** Define a dwim command that indents, fills paragraphs, etc
#+begin_src emacs-lisp
(defun indent-dwim (&optional arg)
  "Perform a context-sensitive indentation action.
With prefix argument ARG, justify text."
  (interactive "P")
  (cond
   ((region-active-p)
    (indent-region (region-beginning) (region-end))
    (message "Indented region."))

   ((-contains? '(font-lock-comment-face
                  font-lock-string-face
                  font-lock-doc-face)
                (face-at-point))
    (if (apply 'derived-mode-p cb:lisp-modes)
        (lisp-fill-paragraph arg)
      (fill-paragraph arg))
    (message "Filled paragraph."))

   ((thing-at-point 'defun)
    (indent-region
     (save-excursion (beginning-of-defun) (point))
     (save-excursion (end-of-defun) (point)))
    (message "Indented defun."))

   (t
    (indent-buffer)
    (message "Indented buffer."))))
#+end_src
* Editing commands
** Insert comma, then space
#+begin_src emacs-lisp
(defun cb:comma-then-space ()
  (interactive)
  (atomic-change-group
    (insert-char ?\,)
    (just-one-space)))
#+end_src
* Buffer file commands
** Delete current buffer and file
#+begin_src emacs-lisp
(defun delete-buffer-and-file ()
  "Delete a file and its associated buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defalias 'delete-file-and-buffer 'delete-buffer-and-file)
#+end_src
** Rename current buffer and file
#+begin_src emacs-lisp
(defun rename-buffer-and-file ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)))))))

(defalias 'rename-file-and-buffer 'rename-buffer-and-file)
#+end_src
* Sorting commands
** Define a command picker for sorting
#+begin_src emacs-lisp
(define-command-picker sorting-picker
  :title "*Sorting*"
  :options
  '(("a" "Alpha" sort-lines)
    ("A" "Alpha (reverse)" (lambda () (sort-lines t (region-beginning) (region-end))))
    ("r" "Reverse" reverse-region)))
#+end_src
** Org-mode compatibility
Define a command that will use the appropriate sorting picker for the current
mode. In org-mode, use the built-in picker. Otherwise use the picker defined
above.
#+begin_src emacs-lisp
(defun cb:sort-dispatch ()
  "Open the appropriate sorting picker for the current mode."
  (interactive)
  (cond
   ((derived-mode-p 'org-mode)
    (call-interactively 'org-sort))
   ((region-active-p)
    (call-interactively 'sorting-picker))
   (t
    (user-error "Sort commands require a region to be active"))))
#+end_src
** Set global key binding
#+begin_src emacs-lisp
(bind-key* "C-c ^" 'cb:sort-dispatch)
#+end_src
* Viewing commands
** Define a picker for showing certain buffers
#+begin_src emacs-lisp
(define-command-picker viewing-picker
  :title "*Viewing*"
  :options
  '(("i" "IRC" show-irc)
    ("m" "Exposé (mode)" expose-buffers-by-mode)))
#+end_src
** Key binding
#+begin_src emacs-lisp
(bind-key* "C-c v" 'viewing-picker)
#+end_src
* Search commands
Define a search picker.
** Implementation
*** Define a data structure to represent a search method
#+begin_src emacs-lisp
(cl-defun cbs-search-method (&key
                             name key command
                             (when (lambda () t))
                             (unless (lambda () nil)))
  (list name key command
        `(lambda ()
           (and (funcall ',when)
                (not (funcall ',unless))))))

(cl-defun cbs-search-method-name ((n _ _ _)) n)
(cl-defun cbs-search-method-key  ((_ k _ _)) k)
(cl-defun cbs-search-method-func ((_ _ f _)) f)
(cl-defun cbs-search-method-pred ((_ _ _ p)) p)
#+end_src
*** Define a variable to maintain a global list of search methods
#+begin_src emacs-lisp
(defvar cbs:search-methods nil
  "The list of search methods used by `cbs-search'.")
#+end_src
*** Define a command to add a search method
#+begin_src emacs-lisp
(defun cbs-read (source-name &optional default)
  "Read a query for SOURCE-NAME with an optional DEFAULT."
  (let ((prompt (if default
                    (format "%s (default: %s): " source-name default)
                  (format "%s: " source-name))))
    (read-string prompt nil t default)))

(cl-defun cbs-define-search-method (&rest spec)
  "Define a new search method.
NAME is the user-facing description.
KEY is used to select it from the menu.
SEARCH-FUNC is a unary function that will be passed the query string.
PRED is a predicate to determine whether search method is currently available.

\(fn &key name key command when unless)"
  (add-to-list 'cbs:search-methods (apply 'cbs-search-method spec)))

(defun cbs-search ()
  "Submit a query to a selected search provider."
  (interactive)
  (message "Select search method")
  (let ((default-search-term
          (-when-let (s (or (current-region) (thing-at-point 'symbol)))
            (substring-no-properties s)))
        (m
         (read-option
          "*Select Search*"
          'cbs-search-method-key 'cbs-search-method-name
          (->> cbs:search-methods
            ;; Use methods without a predicate or where the
            ;; predicate returns non-nil.
            (--filter
             (-if-let (p (cbs-search-method-pred it))
                 (funcall p)
               t))
            ;; Drop duplicated options.
            (-uniq-by (π cbs-search-method-name cbs-search-method-key))
            ;; Sort by key.
            (-sort (-on 'string< (C s-upcase cbs-search-method-key)))))))
    (funcall (cbs-search-method-func m) default-search-term)))
#+end_src

*** Create a global key binding for the search picker
#+begin_src emacs-lisp
(bind-key* "M-s" 'cbs-search)
#+end_src
** Define search methods
#+begin_src emacs-lisp
(cbs-define-search-method
 :name "Dictionary"
 :key "d"
 :command
 (lambda (q)
   (dictionary-search (cbs-read "Dictionary" q))))

(cbs-define-search-method
 :name "Org Files"
 :key "o"
 :command (lambda (_)
            (call-interactively 'org-search-view)))

(cbs-define-search-method
 :name "Web Search"
 :key "s"
 :command
 (lambda (q)
   (browse-url
    (concat "https://duckduckgo.com/?q="
            (url-hexify-string (cbs-read "Duck Duck Go" q))))))

(cbs-define-search-method
 :name "Image Search"
 :key "i"
 :command
 (lambda (q)
   (browse-url
    (concat "https://www.google.co.nz/search?tbm=isch&q="
            (url-hexify-string (cbs-read "Google Images" q))))))

(cbs-define-search-method
 :name "YouTube"
 :key "y"
 :command
 (lambda (q)
   (browse-url
    (concat "http://www.youtube.com/results?search_query="
            (url-hexify-string (cbs-read "YouTube" q))))))

(cbs-define-search-method
 :name "Wikipedia"
 :key "w"
 :command
 (lambda (q)
   (browse-url
    (concat "http://en.wikipedia.org/w/index.php?search="
            (url-hexify-string (cbs-read "Wikipedia" q))))))

(cbs-define-search-method
 :name "BBDB"
 :key "b"
 :command
 (lambda (_)
   (call-interactively 'bbdb)))

(cbs-define-search-method
 :name "Man Page"
 :key "m"
 :command
 (lambda (q)
   (require 'helm-man)
   (helm :sources 'helm-source-man-pages
         :buffer "*Helm man woman*"
         :input q)))

(cbs-define-search-method
 :name "Notmuch (mail)"
 :key "n"
 :when (lambda () (executable-find "notmuch"))
 :command
 (lambda (q)
   (notmuch-search (cbs-read "Mail" q))))

(cbs-define-search-method
 :name "GitHub"
 :key "g"
 :command
 (lambda (q)
   (browse-url
    (concat "https://github.com/search?q="
            (url-hexify-string (cbs-read "GitHub Search" q))))))

(cbs-define-search-method
 :name "Info"
 :key "e"
 :command
 (lambda (_)
   (call-interactively 'helm-info-at-point)))
#+end_src
* Help picker
** Define a picker for help commands
#+begin_src emacs-lisp
(define-command-picker help-picker
  :title "*Help Commands*"
  :options
  '(("m" "Messages" view-echo-area-messages)
    ("f" "Find Function" find-function)
    ("l" "Find Library" find-library)
    ("v" "Find Variable" find-variable)
    ("a" "Apropos" apropos)
    ("A" "Apropos (value)" apropos-value)))
#+end_src
** Bind help picker to a key
#+begin_src emacs-lisp
(bind-key "C-h e" 'help-picker)
#+end_src
* Sudo editing
** Define a command to edit files with sudo
#+begin_src emacs-lisp
(cl-defun sudo-edit (&optional (file (buffer-file-name)))
  "Edit FILE with sudo if permissions require it."
  (interactive)
  (when file
    (cond
     ((f-dir? file)
      (error "%s is a directory" file))

     ((file-writable-p file)
      (error "%s: sudo editing not needed" file))

     ;; Prompt user whether to escalate. Ensure the tramp connection is cleaned
     ;; up afterwards.
     ((and (yes-or-no-p "Edit file with sudo?  ")
           (find-alternate-file (concat "/sudo:root@localhost:" file)))
      (add-hook 'kill-buffer-hook 'tramp-cleanup-this-connection nil t)))))
#+end_src
** Offer to edit files with sudo when necessary
#+begin_src emacs-lisp
(defun maybe-sudo-edit ()
  (let ((dir (file-name-directory (buffer-file-name))))
    (when (or (and (not (file-writable-p (buffer-file-name)))
                   (file-exists-p (buffer-file-name)))

              (and dir
                   (file-exists-p dir)
                   (not (file-writable-p dir))))
      (sudo-edit))))

(add-hook 'find-file-hook 'maybe-sudo-edit)
#+end_src
** Add a global key to edit the current file with sudo
#+begin_src emacs-lisp
(bind-key* "C-x e" 'sudo-edit)
#+end_src
* Mode groups
/Mode groups/ are ad-hoc families of modes. They provide hooks for modes that
have commonalities but are not directly related through mode inheritance.

Given the following macro definitions:

#+begin_src emacs-lisp
(defmacro define-combined-hook (name hooks)
  "Create a hook bound as NAME that is run after each hook in HOOKS."
  (declare (indent 1))
  `(progn
     (defvar ,name nil "Auto-generated combined hook.")
     (hook-fns ',(eval hooks)
       (run-hooks ',name))))

(defmacro define-mode-group (name modes)
  "Create an ad-hoc relationship between language modes.
Creates a special var with NAME to contain the grouping.
Declares a hook NAME-hook that runs after any of MODES are initialized."
  (declare (indent 1))
  (let ((hook (intern (format "%s-hook" name))))
    `(progn
       ;; Define modes variable.
       (defconst ,name ,modes "Auto-generated variable for language grouping.")
       ;; Create a combined hook for MODES.
       (define-combined-hook ,hook
         (--map (intern (concat (symbol-name it) "-hook"))
                ,modes)))))
#+end_src

We define the following mode groups:

#+begin_src emacs-lisp
(define-mode-group cb:scheme-modes
  '(scheme-mode
    inferior-scheme-mode
    geiser-repl-mode))

(define-mode-group cb:clojure-modes
  '(clojure-mode
    clojurescript-mode
    cider-repl-mode))

(define-mode-group cb:elisp-modes
  '(emacs-lisp-mode
    inferior-emacs-lisp-mode))

(define-mode-group cb:slime-modes
  '(slime-mode
    slime-repl-mode))

(define-mode-group cb:lisp-modes
  `(,@cb:scheme-modes
    ,@cb:clojure-modes
    ,@cb:elisp-modes
    ,@cb:slime-modes
    common-lisp-mode
    inferior-lisp-mode
    lisp-mode
    repl-mode))

(define-mode-group cb:haskell-modes
  '(haskell-mode
    inferior-haskell-mode
    haskell-interactive-mode
    haskell-c-mode
    haskell-cabal-mode))

(define-mode-group cb:idris-modes
  '(idris-mode
    idris-repl-mode))

(define-mode-group cb:python-modes
  '(python-mode
    inferior-python-mode))

(define-mode-group cb:ruby-modes
  '(inf-ruby-mode
    ruby-mode))

(define-mode-group cb:rails-modes
  `(,@cb:ruby-modes
    erb-mode))

(define-mode-group cb:xml-modes
  '(sgml-mode
    nxml-mode))

(define-mode-group cb:org-minor-modes
  '(orgtbl-mode
    org-indent-mode
    orgstruct-mode
    orgstruct++-mode))

(define-mode-group cb:conf-modes
  '(conf-unix-mode
    conf-windows-mode
    conf-javaprop-mode))

(define-mode-group cb:prompt-modes
  '(comint-mode
    inf-ruby-mode
    inferior-python-mode
    ielm-mode
    erc-mode
    slime-repl-mode
    inferior-scheme-mode
    inferior-haskell-mode
    sclang-post-buffer-mode))

(define-mode-group cb:whitespace-sensitive-languages
  '(python-mode
    haskell-mode
    fsharp-mode
    idris-mode))
#+end_src

* Server
#+begin_src emacs-lisp
(require 'server)
#+end_src
** Start the server after Emacs has been initialised
#+begin_src emacs-lisp
(hook-fn 'after-init-hook
  (unless (or noninteractive (server-running-p))
    (server-start)))
#+end_src
** Disable colour themes for console frames
Using emacsclient with colour themes can be flaky in terminals, especially on OS
X. This code tweaks the colours when creating frames in a terminal.
#+begin_src emacs-lisp
(after 'server
  (defun cb-server:configure-frame (&rest frame)
    "Disable themeing for console emacsclient."
    (unless (display-graphic-p)
      (let ((fm (or (car frame) (selected-frame)))
            (tranparent "ARGBBB000000")
            (blue "#168DCC")
            )
        (set-face-foreground 'default nil fm)
        (set-face-background 'default tranparent fm)
        (set-face-background 'menu blue fm)
        (set-face-foreground 'menu "white" fm)
        (set-face-background 'hl-line tranparent fm)
        (set-face-background 'fringe tranparent fm)
        (set-face-background 'cursor "#2F4F4F" fm)
        ;; Modeline
        (set-face-foreground 'mode-line-filename "white" fm)
        (set-face-foreground 'mode-line-position "white" fm)
        (set-face-foreground 'mode-line-mode "black" fm)
        (set-face-bold 'mode-line-mode t fm)
        (set-face-background 'mode-line blue fm)
        (set-face-background 'mode-line blue fm)

        (when (featurep 'smartparens)
          (set-face-background 'sp-pair-overlay-face "green" fm))
        (when (featurep 'org)
          (set-face-background 'org-block-begin-line tranparent fm)
          (set-face-background 'org-block-end-line tranparent fm)
          (set-face-background 'org-block-background tranparent fm)))))

  (defadvice server-create-window-system-frame (after configure-frame activate)
    "Set custom frame colours when creating the first frame on a display"
    (cb-server:configure-frame))

  (add-hook 'after-make-frame-functions 'cb-server:configure-frame t))
#+end_src
* Font lock
** Use maximum font-lock prettiness
#+begin_src emacs-lisp
(setq font-lock-maximum-decoration t)
#+end_src
** Do not perform font-locking on killed buffers
#+begin_src emacs-lisp
(defadvice jit-lock-force-redisplay (around ignore-killed-buffers activate)
  (let ((buf (ad-get-arg 0)))
    (when (buffer-live-p buf)
      ad-do-it)))
#+end_src
* Typefaces
Provide support for rich typefaces.
** Ignore font changes in terminal
#+begin_src emacs-lisp
(defadvice set-face-font (around ignore-in-term activate)
  "Ignore attempts to change the font in terminals."
  (when (display-graphic-p) ad-do-it))
#+end_src
** Define face families
Define face families. This should work on most OSes, though I haven't tested on
anything other than OS X.

Define function for finding serif, sans-serif and monospace fonts appropriate to
this system.

#+begin_src emacs-lisp
(defun first-font (&rest fonts)
  "Return the first available font in FONTS."
  (--first (find-font (font-spec :name it)) fonts))

(defun serif-font ()
  "Retun the serif type-face name to use for this Emacs session."
  (first-font "Palatino" "Cambria" "Times New Roman"))

(defun sans-serif-font ()
  "Retun the sans-serif type-face name to use for this Emacs session."
  (first-font "Lucida Grande" "Ubuntu Regular" "Segoe UI"
              "Helvetica Neue" "Calibri" "Helvetica" "Verdana" "Arial"))

(defun monospace-font ()
  "Retun the monospace type-face name to use for this Emacs session."
  (or (first-font "Menlo" "Consolas" "Inconsolata" "DejaVu Sans Mono"
                  "Ubuntu Mono Regular" "Courier")
      "Menlo"))
#+end_src
** Set default font
*** Manually set the default font
#+begin_src emacs-lisp
(set-frame-font (format "%s 11" (monospace-font)) t)
#+end_src
*** Ensure that any further frames use this font too
#+begin_src emacs-lisp
(hook-fn 'after-make-frame-functions
  (set-frame-font (format "%s 11" (monospace-font)) t
                  (list (car (frame-list)))))
#+end_src
* Colours and themes
** Compatibility
Define an alias for =set-face-bold=, which was introduced in 24.3
#+begin_src emacs-lisp
(when (and (<= emacs-major-version 24)
           (< emacs-minor-version 3))
  (defalias 'set-face-bold 'set-face-bold-p))
#+end_src
** Solarized colours
Define global variables for Solarized accent colours so they can be used in
other places in the configuration.
#+begin_src emacs-lisp
(defvar solarized-hl-yellow    "#b58900")
(defvar solarized-hl-orange    "#cb4b16")
(defvar solarized-hl-red       "#dc322f")
(defvar solarized-hl-magenta   "#d33682")
(defvar solarized-hl-violet    "#6c71c4")
(defvar solarized-hl-blue      "#268bd2")
(defvar solarized-hl-cyan      "#2aa198")
(defvar solarized-hl-green     "#859900")
#+end_src
** CONDITIONAL
Do not load if we're running Emacs in a terminal.
#+begin_src emacs-lisp
(when (or (daemonp) (display-graphic-p))
#+end_src
** Saving themes between sessions
Define a utility for saving the current theme. This allows the theme that was
last used to be selected when Emacs is started.
#+begin_src emacs-lisp
(defconst cbcl:saved-theme-file (f-join cb:tmp-dir "last-theme")
  "Filepath to a file containing the last selected colour theme.")

(defun cbcl:save-theme-settings (theme)
  "Save THEME to a file at `cbcl:saved-theme-file'."
  (when after-init-time
    (f-write (format "(%s)" theme) 'utf-8 cbcl:saved-theme-file)))
#+end_src
** Solarized
The Solarized theme is a popular colour theme. It comes in two variants--light
and dark.
*** Install package
#+begin_src emacs-lisp
(unless noninteractive
  (cb:install-package 'solarized-theme))
#+end_src
*** Define common settings
Define a function for applying settings common to both the light and dark
themes.
#+begin_src emacs-lisp
(defun cb-colour:common-setup ()
  "Perform customisation common to all themes."
  (set-face-underline 'hl-line nil)
  (set-face-font 'default (format "%s 11" (monospace-font)))

  (after 'eval-sexp-fu
    (set-face-background 'eval-sexp-fu-flash-error solarized-hl-orange))

  (after 'helm
    (set-face-underline   'helm-selection nil))

  (after 'smartparens
    (set-face-foreground  'sp-show-pair-match-face "#002b36")
    (set-face-background  'sp-show-pair-match-face "white")
    (set-face-bold        'sp-show-pair-match-face t))

  (after 'iedit
    (set-face-attribute 'iedit-occurrence nil :underline solarized-hl-orange))

  (after 'org
    (set-face-underline  'org-block-begin-line t)
    (set-face-attribute  'org-block-end-line nil :overline t)
    (set-face-background 'org-hide 'unspecified)
    (set-face-foreground 'org-document-info-keyword 'unspecified)
    (set-face-italic 'org-meta-line nil)
    (set-face-attribute 'org-document-info-keyword nil :inherit 'org-meta-line)
    (--each (--filter-atoms (and (s-starts-with? "org-level-" (symbol-name it))
                                 (facep it)))
      (unless (equal 'org-level-1 it)
        (set-face-bold it nil))
      (set-face-font it (monospace-font)))))
#+end_src
*** Configure Solarized Light
#+begin_src emacs-lisp
(defun solarized-light ()
  (interactive)
  (cbcl:save-theme-settings 'solarized-light)
  (load-theme 'solarized-light 'no-confirm)
  (cb-colour:common-setup)

  (after 'org
    (set-face-background 'org-block-begin-line "#f8f1dc")
    (set-face-background 'org-block-end-line "#f8f1dc")
    (set-face-background 'org-block-background "#f8f1dc"))

  (after 'ledger-fonts
    (set-face-background 'ledger-font-xact-highlight-face "#eee8d5")
    (set-face-background 'ledger-occur-xact-face "#eee8d5"))

  (after 'helm
    (set-face-background  'helm-selection "white")
    (set-face-foreground  'helm-selection "black"))

  (after 'eval-sexp-fu
    (set-face-background 'eval-sexp-fu-flash "#eee8d5")
    (set-face-foreground 'eval-sexp-fu-flash solarized-hl-cyan))

  (after 'parenface-plus
    (set-face-foreground  'paren-face "grey80")))
#+end_src
*** Configure Solarized Dark
#+begin_src emacs-lisp
(defun solarized-dark ()
  (interactive)
  (cbcl:save-theme-settings 'solarized-dark)
  (load-theme 'solarized-dark 'no-confirm)
  (cb-colour:common-setup)

  (after 'helm
    (set-face-background  'helm-selection "black")
    (set-face-foreground  'helm-selection "white"))

  (after 'ledger-fonts
    (set-face-background 'ledger-font-xact-highlight-face "#073642")
    (set-face-background 'ledger-occur-xact-face "#073642"))

  (after 'eval-sexp-fu
    (set-face-background 'eval-sexp-fu-flash "#073642")
    (set-face-foreground 'eval-sexp-fu-flash solarized-hl-cyan))

  (after 'parenface-plus
    (set-face-foreground  'paren-face "#505070"))

  (after 'org
    (set-face-background 'org-block-end-line "#11303b")
    (set-face-background 'org-block-begin-line "#11303b")
    (set-face-background 'org-block-background "#11303b")))
#+end_src
*** Make convenience aliases for the above functions
#+begin_src emacs-lisp
(defalias 'light 'solarized-light)
(defalias 'dark 'solarized-dark)
#+end_src
** Load theme on startup
Write current theme to disk whenever the colour theme is changed so it can be
reloaded on startup.
#+begin_src emacs-lisp
(defun cb-colour:load-last-theme ()
  (condition-case _
      (load cbcl:saved-theme-file nil t t)
    (error (solarized-light))))

(unless (true? after-init-time) (cb-colour:load-last-theme))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Highlight FIXMEs and TODOs in comments
#+begin_src emacs-lisp
(hook-fn 'prog-mode-hook
  (font-lock-add-keywords
   nil '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
          1 font-lock-warning-face t))))
#+end_src
* Comint
#+begin_src emacs-lisp
(setq comint-prompt-read-only t)
#+end_src
** Configure common key bindings for comint and prompt modes.
#+begin_src emacs-lisp
(defun cb:clear-scrollback ()
  "Erase all but the last line of the current buffer."
  (interactive)
  (let ((inhibit-read-only t)
        (last-line (save-excursion
                     (goto-char (point-max))
                     (forward-line -1)
                     (line-end-position))))
    (delete-region (point-min) last-line)
    (goto-char (point-max))))

(hook-fn 'cb:prompt-modes-hook
  (local-set-key (kbd "C-a") 'move-beginning-of-line)
  (local-set-key (kbd "C-e") 'move-end-of-line)
  (local-set-key (kbd "C-l") 'cb:clear-scrollback)
  (local-set-key (kbd "M->") 'cb:append-buffer)
  (cb:append-buffer))
#+end_src
* Hippie-expand
=Hippie-expand= provides keyword completion.
** Expand liberally
#+begin_src emacs-lisp
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
#+end_src
** Bind globally.
#+begin_src emacs-lisp
(bind-key* "M-/" 'hippie-expand)
#+end_src
* Indirect buffers
Define a command for creating indirect buffers from a region.
** Impl
#+begin_src emacs-lisp
(defvar-local indirect-mode-name nil
  "Mode to set for indirect buffers.")

(defun indirect-region (start end)
  "Edit the current region from START to END in another buffer.
If the buffer-local variable `indirect-mode-name' is not set, prompt
for mode name to choose for the indirect buffer interactively.
Otherwise, use the value of said variable as argument to a funcall."
  (interactive "r")
  (let ((buffer-name (generate-new-buffer-name "*indirect*"))
        (mode
         (if (not indirect-mode-name)
             (setq indirect-mode-name
                   (intern
                    (completing-read
                     "Mode: "
                     (mapcar (lambda (e)
                               (list (symbol-name e)))
                             (apropos-internal "-mode$" 'commandp))
                     nil t)))
           indirect-mode-name)))
    (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
    (funcall mode)
    (narrow-to-region start end)
    (goto-char (point-min))
    (shrink-window-if-larger-than-buffer)))
#+end_src
** Key binding
#+begin_src emacs-lisp
(bind-key "C-c C" 'indirect-region)
#+end_src
* Calc
** Define a command that invokes calc and performs a context-sensitive action
#+begin_src emacs-lisp
(defun calc-dwim ()
  "Run calc or grab the current region."
  (interactive)
  (if (region-active-p)
      (condition-case err
          (let ((opt (read-option
                      "Calc Grab" 'car 'cadr
                      '(("v" "Grab as Vector" calc-grab-region)
                        ("m" "Grab as Matrix" calc-grab-rectangle)
                        ("c" "Sum Cols" calc-grab-sum-down)
                        ("r" "Sum Rows" calc-grab-sum-across)))))
            (call-interactively (nth 2 opt)))

        (error
         (message "Malformed region. %s" (error-message-string err))))

    (call-interactively 'calc)))
#+end_src
** Create global key bindings for calc
#+begin_src emacs-lisp
(bind-key* "<f2>" 'calc-dwim)
(bind-key* "C-/"  'quick-calc)
#+end_src
* hl-line
Highlight the current line.
#+begin_src emacs-lisp
(when (display-graphic-p)
  (global-hl-line-mode t))
#+end_src
* fringe
Set fringe width.
#+begin_src emacs-lisp
(require 'fringe)
(fringe-mode '(2 . 0))
#+end_src
* ansi-color
Enable ANSI colour codes in terminals and compilation buffers.
#+begin_src emacs-lisp
(add-hook 'comint-mode-hook 'ansi-color-for-comint-mode-on)
(add-hook 'compilation-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src
** Process ANSI colours in shell output
#+begin_src emacs-lisp
(defadvice display-message-or-buffer (before ansi-color activate)
  "Process ANSI color codes in shell output."
  (let ((buf (ad-get-arg 0)))
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max))))))
#+end_src
* Ido
** Ido
#+begin_src emacs-lisp
(require 'ido)
(ido-mode +1)
#+end_src
** Define a macro to decorate a command to use ido
#+begin_src emacs-lisp
(defmacro declare-ido-wrapper (command)
  "Make COMMAND use ido for file and directory completions."
  `(defadvice ,command (around read-with-ido activate)
     (noflet
         ((read-directory-name
           (&rest args) (apply 'ido-read-directory-name args))
          (read-file-name
           (&rest args) (apply 'ido-read-file-name args))
          (read-buffer
           (&rest args) (apply 'ido-read-buffer)))
       ad-do-it)))
#+end_src
** Configure variables
#+begin_src emacs-lisp
(setq ido-enable-prefix nil
      ido-save-directory-list-file (f-join cb:tmp-dir "ido.last")
      ido-enable-flex-matching t
      ido-create-new-buffer 'always
      ido-use-filename-at-point 'guess
      ido-max-prospects 10
      ido-default-file-method 'selected-window)
#+end_src
** Ignore certain patterns
#+begin_src emacs-lisp
(add-to-list 'ido-ignore-buffers "\\*helm.*")
(add-to-list 'ido-ignore-buffers "\\*Minibuf.*")
(add-to-list 'ido-ignore-files "\\.swp")
(add-to-list 'ido-ignore-files "\\.DS_Store")
#+end_src
** Set key bindings
#+begin_src emacs-lisp
(bind-keys
  "C-x C-f" 'ido-find-file
  "C-x d"   'ido-dired
  "C-x i"   'ido-insert-file
  "C-x C-w" 'ido-write-file
  "C-x k"   'ido-kill-buffer
  "C-x b"   'ido-switch-buffer)
#+end_src
** Typing '~' goes immediately to home folder.
#+begin_src emacs-lisp
(hook-fn 'ido-setup-hook
  (define-key ido-common-completion-map (kbd "~") (command (insert "~/"))))
#+end_src
** Ido vertical mode
Shows ido menus using a vertical layout.
#+begin_src emacs-lisp
(cb:install-package 'ido-vertical-mode t)
(noflet ((message (&rest _) nil)) (ido-vertical-mode +1))
#+end_src
** Ido hacks
Extends ido to more places.
#+begin_src emacs-lisp
(cb:install-package 'ido-hacks t)
(ido-hacks-mode +1)
#+end_src
** Flx-ido
Adds improved matching algorithm for ido.
#+begin_src emacs-lisp
(cb:install-package 'flx-ido t)
(flx-ido-mode +1)
#+end_src
*** Override ido faces with flx ones
#+begin_src emacs-lisp
(setq ido-use-faces nil)
#+end_src
* Projectile
Projectile provides project-level commands such as finding files in the current
project, performing searches and replacements, etc.
#+begin_src emacs-lisp
(cb:install-package 'projectile t)
(projectile-global-mode +1)
#+end_src
** Configure vars
#+begin_src emacs-lisp
(setq projectile-known-projects-file
      (f-join cb:tmp-dir "projectile-bookmarks.eld")

      projectile-cache-file
      (f-join cb:tmp-dir "projectile.cache"))
#+end_src
** Hide projectile modeline indicator
#+begin_src emacs-lisp
(after 'projectile (diminish 'projectile-mode))
#+end_src
** Advise tag searches to make sure we're searching the right tags file
#+begin_src emacs-lisp
(defadvice find-tag (before set-tags-directory activate)
      "Ensure the TAGS path is set before searching for tags."
      (setq tags-file-name (concat (projectile-project-root) "TAGS")))
#+end_src
* Helm
Helm provides a general UI for searching through lists of items interactively.
#+begin_src emacs-lisp
(cb:install-package 'helm t)
#+end_src
** Save the history file to the tmp dir
#+begin_src emacs-lisp
(setq helm-adaptive-history-file (f-join cb:tmp-dir "helm-adaptive-history"))
#+end_src
** Evil
#+begin_src emacs-lisp
  (after 'evil
    (bind-keys
      :overriding? t
      "C-SPC" 'helm-mini
      "C-x C-b" 'helm-buffers-list
      "M-b" 'helm-buffers-list)

    (evil-global-set-key 'normal (kbd "C-e") 'helm-etags-select)
    (evil-global-set-key 'normal (kbd "C-t") 'helm-imenu))
#+end_src
** Hide boring files in helm files lists
#+begin_src emacs-lisp
  (setq helm-ff-skip-boring-files t)
  (setq helm-boring-file-regexp-list '("\\.DS_Store" "\\.elc$"))
#+end_src
** Typing '~' in helm find files goes back to home directory
#+begin_src emacs-lisp
(after 'helm-files
  (define-key helm-find-files-map
    (kbd "~")
    (command
     (if (looking-back "/")
         (helm-insert-in-minibuffer "~/" t)
       (call-interactively 'self-insert-command)))))
#+end_src
** Set a global key binding for helm-find-files
#+begin_src emacs-lisp
(bind-key* "C-x SPC" 'helm-find-files)
#+end_src
** Helm projectile
Provides helm sources for projectile.
#+begin_src emacs-lisp
(cb:install-package 'helm-projectile)
(bind-key "M-j" 'helm-projectile)
#+end_src
* Auto-complete
Provides intellisense-style completion popops.
#+begin_src emacs-lisp
(cb:install-package 'auto-complete t)
(global-auto-complete-mode +1)
#+end_src
** Start with default configuration
#+begin_src emacs-lisp
(require 'auto-complete-config)
(ac-config-default)
#+end_src
** Customise vars
#+begin_src emacs-lisp
(setq ac-auto-show-menu t
      ac-dwim t
      ac-use-menu-map t
      ac-quick-help-delay 0.4
      ac-quick-help-height 60
      ac-disable-inline t
      ac-show-menu-immediately-on-auto-complete t
      ac-auto-start 3
      ac-candidate-menu-min 0
      ac-comphist-file (f-join cb:tmp-dir "ac-comphist.dat"))
#+end_src
** Fix issues with flyspell
#+begin_src emacs-lisp
(ac-flyspell-workaround)
#+end_src
** Define user dictionary directory
#+begin_src emacs-lisp
(add-to-list 'ac-dictionary-directories (concat user-emacs-directory "ac-dict"))
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'auto-complete-mode)
#+end_src
** Ignore errors when showing help popups
#+begin_src emacs-lisp
(defadvice ac-quick-help (around ignore-errors activate)
  "Ignore errors when showing help popups."
  (ignore-errors ad-do-it))
#+end_src
** Define keys for auto-complete popups
#+begin_src emacs-lisp
(define-keys ac-completing-map
  "<escape>" 'ac-stop
  "C-n" 'ac-next
  "C-p" 'ac-previous
  "\t"  'ac-complete)
#+end_src
* Yasnippet
Provides textmate-style snippets.
#+begin_src emacs-lisp
(cb:install-package 'yasnippet)
(add-hook 'prog-mode-hook 'yas-minor-mode)
(add-hook 'text-mode-hook 'yas-minor-mode)
#+end_src
** Override yasnippet faces
#+begin_src emacs-lisp
(defface yas-field-highlight-face
  `((t :underline ,solarized-hl-cyan
       :italic t))
  "The face used to highlight the currently active field of a snippet"
  :group 'yasnippet)
#+end_src
** Use only my snippet dir, since the built-in snippets are crappy
#+begin_src emacs-lisp
(setq yas/snippet-dirs (list cb:yasnippet-dir))
#+end_src
** Load yasnippet, suppressing most of the startup messages
#+begin_src emacs-lisp
(noflet ((message (&rest _) nil)) (yas-global-mode t))
#+end_src
** Customise vars
#+begin_src emacs-lisp
(setq yas-prompt-functions '(yas-ido-prompt)
      yas-wrap-around-region t)
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'yas-minor-mode)
#+end_src
** Auxiliary commands
#+begin_src emacs-lisp
(defun cbyas:reload-all ()
  (interactive)
  (yas-recompile-all)
  (yas-reload-all))
#+end_src
** Define a command picker for yasnippet actions
*** Impl
#+begin_src emacs-lisp
(define-command-picker yasnippet-picker
  :title "*Yasnippet Commands*"
  :options
  '(("e" "Expand" yas-expand)
    ("f" "Visit File" yas-visit-snippet-file)
    ("i" "Insert" yas-insert-snippet)
    ("n" "New" yas-new-snippet)
    ("r" "Reload All" cbyas:reload-all)
    ("t" "Show Tables" yas-describe-tables)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(bind-key* "C-c y" 'yasnippet-picker)
#+end_src
** Snippet utilities
#+begin_src emacs-lisp
(defun cbyas:bol? ()
  "Non-nil if point is on an empty line or at the first word."
  (s-matches? (rx bol (* space) (* word) eol)
              (buffer-substring (line-beginning-position)
                                (point))))
#+end_src
** Utilities for yasnippet advice
#+begin_src emacs-lisp
(defun cbyas:current-field ()
  "Return the current active field."
  (and (boundp 'yas--active-field-overlay)
       yas--active-field-overlay
       (overlay-buffer yas--active-field-overlay)
       (overlay-get yas--active-field-overlay 'yas--field)))

(defun cbyas:beginning-of-field ()
  (-when-let (field (cbyas:current-field))
    (marker-position (yas--field-start field))))

(defun cbyas:end-of-field ()
  (-when-let (field (cbyas:current-field))
    (marker-position (yas--field-end field))))

(defun cbyas:current-field-text ()
  "Return the text in the active snippet field."
  (-when-let (field (cbyas:current-field))
    (yas--field-text-for-display field)))
#+end_src
** Blank field trimming
Advise yasnippet to trim blank fields when moving between fields in a snippet.
#+begin_src emacs-lisp
(defun cbyas:clear-blank-field ()
  "Clear the current field if it is blank."
  (-when-let* ((beg (cbyas:beginning-of-field))
               (end (cbyas:end-of-field))
               (str (cbyas:current-field-text)))
    (when (s-matches? (rx bos (+ space) eos) str)
      (delete-region beg end)
      t)))

(defadvice yas-next-field (before clear-blank-field activate)
  (cbyas:clear-blank-field))

(defadvice yas-prev-field (before clear-blank-field activate)
  (cbyas:clear-blank-field))
#+end_src
** Cursor positioning
advise yasnippet to position the cursor at the end of fields when switching
fields in a snippet.
#+begin_src emacs-lisp
(defun cbyas:maybe-goto-field-end ()
  "Move to the end of the current field if it has been modified."
  (-when-let (field (cbyas:current-field))
    (when (and (yas--field-modified-p field)
               (yas--field-contains-point-p field))
      (goto-char (cbyas:end-of-field)))))

(defadvice yas-next-field (after goto-field-end activate)
  (cbyas:maybe-goto-field-end))

(defadvice yas-prev-field (after goto-field-end activate)
  (cbyas:maybe-goto-field-end))
#+end_src
** Backspace clears unmodified fields or deletes backwards
#+begin_src emacs-lisp
(defun cbyas:backspace ()
  "Clear the current field if the current snippet is unmodified.
Otherwise delete backwards."
  (interactive "*")
  (let ((field (cbyas:current-field)))
    (cond ((and field
                (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          ((true? smartparens-mode)
           (call-interactively 'sp-backward-delete-char))
          (t
           (call-interactively 'backward-delete-char)))))

(bind-key "<backspace>" 'cbyas:backspace yas-keymap)
#+end_src
** Typing space clears and skips unmodified fields.
#+begin_src emacs-lisp
(defun cbyas:space ()
  "Clear and skip this field if it is unmodified. Otherwise insert a space."
  (interactive "*")
  (let ((field (cbyas:current-field)))
    (cond ((and field
                (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          (t
           (insert " ")))))

(bind-key "SPC" 'cbyas:space yas-keymap)
#+end_src
** Evil
Customise yasnippet behaviour to work better with evil-mode.
#+begin_src emacs-lisp
(after 'evil

  (defadvice yas-prev-field (after insert-state activate)
    (when (true? evil-mode)
      (evil-insert-state)))

  (defadvice yas-prev-field (after insert-state activate)
    (when (true? evil-mode)
      (evil-insert-state)))

  (add-hook 'yas-before-expand-snippet-hook 'evil-insert-state))
#+end_src
* Evil
Evil-mode adds modal editing to emulate vim. Since this drastically changes
Emacs' key bindings, the =cb:use-vim-keybindings?= var can be set to nil to
prevent Evil from being loaded.
** CONDITIONAL
#+begin_src emacs-lisp
(when cb:use-vim-keybindings?
#+end_src
** Evil-mode
Activate evil-mode unless it has been disabled at the start of the config.
#+begin_src emacs-lisp
(cb:install-package 'evil t)
#+end_src
*** Use ESC as quit command in most situations.
#+begin_src emacs-lisp
(--each '(evil-normal-state-map
          evil-visual-state-map
          minibuffer-local-map
          minibuffer-local-ns-map
          minibuffer-local-completion-map
          minibuffer-local-must-match-map
          minibuffer-local-isearch-map)
  (define-key (eval it) [escape] 'keyboard-quit))
#+end_src
*** Customise variables
#+begin_src emacs-lisp
(setq evil-want-visual-char-semi-exclusive t
      evil-toggle-key (kbd "M-z")
      evil-default-cursor t)
(setq-default evil-shift-width 2)
(setq-default evil-symbol-word-search 'symbol)
#+end_src
*** Define a convenience macro for settings evil keys globally
#+begin_src emacs-lisp
(defmacro evil-global-set-keys (state &rest defs)
  "Variadic version of `evil-global-set-key'
Creates STATE bindings for DEFS. DEFS are comprised of alternating string-symbol pairs."
  (declare (indent 1))
  `(after 'evil
     ,@(-map (lambda+ ((key fn))
               `(evil-global-set-key ,state (kbd ,key) ,fn))
             (-partition-all 2 defs))))
#+end_src
*** Enable evil-mode
#+begin_src emacs-lisp
(evil-mode +1)
#+end_src
** Custom key definitions
*** Define a command to unset evil keys
#+begin_src emacs-lisp
(defun evil-undefine ()
  (interactive)
  (let (evil-mode-map-alist)
    (call-interactively (key-binding (this-command-keys)))))
#+end_src
*** Customise key bindings
#+begin_src emacs-lisp
(define-keys evil-normal-state-map
  "TAB" 'indent-according-to-mode
  "<backtab>" 'outdent
  "M-z" 'evil-emacs-state
  "C-z" 'evil-undefine
  "SPC" 'evil-toggle-fold
  "K"   'cbevil:get-documentation
  "u"   'undo-tree-undo
  "C-R" 'undo-tree-redo)

(define-key evil-insert-state-map (kbd "C-z") 'evil-undefine)
(define-key evil-emacs-state-map  (kbd "M-z") 'evil-normal-state)
(define-key evil-visual-state-map (kbd "C-z") 'evil-undefine)
#+end_src
** Add custom commands to emulate vim's dictionary editing commands
*** Impl
#+begin_src emacs-lisp
(autoload 'ispell-add-to-dict "cb-spelling")
(autoload 'ispell-add-per-file-word-list "ispell")

(defun evil-mark-word-as-good (word)
  "Add WORD at point to the Ispell dictionary."
  (interactive (list (thing-at-point 'word)))
  (ispell-add-to-dict word)
  (message "%s added to dictionary" (s-upcase word)))

(defun evil-correct-word (arg)
  "Corect the word at point with Ispell.
With a number ARG, select the nth replacement."
  (interactive "*P")
  (if (numberp arg)
      (dotimes (_ (1+ arg))
        (flyspell-auto-correct-word))
    (ispell-word)))

(defun evil-mark-word-as-locally-good (word)
  "Add WORD at point to the list of locally-defined words."
  (interactive (list (thing-at-point 'word)))
  (when word
    (ispell-add-per-file-word-list word)
    (message "%s added to local word list" (s-upcase word))))

(defun cbevil:error-backward-search-start-pos (pos)
  "Wrap the search to the end of the buffer if there are no
errors before POS."
  (if (and (eq (current-buffer) flyspell-old-buffer-error)
           (eq pos flyspell-old-pos-error))
      (cond
       ((= flyspell-old-pos-error (point-min))
        (message "Restarting from end of buffer")
        (point-max))
       (t
        (save-excursion
          (forward-word -1)
          (point))))
    (point)))

(defun cbevil:prev-spelling-error-pos ()
  (let ((pos (cbevil:error-backward-search-start-pos (point))))
    (while (and (> pos (point-min))
                (-none? 'flyspell-overlay-p (overlays-at pos)))
      (cl-decf pos))
    pos))

(defun evil-previous-spelling-error ()
  "Go to the previous flyspell error."
  (interactive)
  (let ((pos (cbevil:prev-spelling-error-pos)))
    ;; save the current location for next invocation
    (setq flyspell-old-pos-error pos)
    (setq flyspell-old-buffer-error (current-buffer))
    (goto-char pos)
    (when (= pos (point-min))
      (message "No more spelling errors"))))

(defun cbevil:error-forward-search-start-pos (pos)
  "Wrap the search to the beginning of the buffer if there are no
errors forward of POS."
  (if (and (eq (current-buffer) flyspell-old-buffer-error)
           (eq pos flyspell-old-pos-error))
      (cond
       ((= flyspell-old-pos-error (point-max))
        (message "Restarting from beginning of buffer")
        (point-min))
       (t
        (save-excursion
          (forward-word 1)
          (point))))
    (point)))

(defun cbevil:next-spelling-error-pos ()
  (let ((pos (cbevil:error-forward-search-start-pos (point))))
    (while (and (< pos (point-max))
                (-none? 'flyspell-overlay-p (overlays-at pos)))
      (cl-incf pos))
    pos))

(defun evil-next-spelling-error ()
  "Go to the next flyspell error."
  (interactive)
  (let ((pos (cbevil:next-spelling-error-pos)))
    ;; save the current location for next invocation
    (setq flyspell-old-pos-error pos)
    (setq flyspell-old-buffer-error (current-buffer))
    (goto-char pos)
    (when (= pos (point-max))
      (message "No more spelling errors"))))
#+end_src
*** Key bindings
#+begin_src emacs-lisp
(define-keys evil-normal-state-map
  "[s"  'evil-previous-spelling-error
  "]s"  'evil-next-spelling-error
  "z g" 'evil-mark-word-as-good
  "z G" 'evil-mark-word-as-locally-good
  "z =" 'evil-correct-word
  "z u" 'flyspell-auto-correct-word)
#+end_src
** Documentation search
Extend the 'K' key to support documentation searches using mode-specific search
commands.
#+begin_src emacs-lisp
(autoload 'Man-getpage-in-background "man")
(autoload 'woman-file-name-all-completions "woman")

(defvar evil-find-doc-hook nil
  "Hook run when finding documentation for the symbol at point.
Each handler should take the search string as an argument.")

(defmacro define-evil-doc-handler (modes &rest body)
  "Register a doc lookup function for MODES.

- MODES is a quoted symbol or list of symbols representing the
  modes in which this handler will be used.

- BODY are the forms to execute to show documentation."
  (let* ((modes (-listify (eval modes)))
         (fname (intern (format "cbevil:doc-search-%s" (car modes)))))
    (cl-assert modes nil "Must provide a mode or list of modes")
    (cl-assert (-all? 'symbolp modes))
    `(progn

       (defun ,fname ()
         ,(concat "Documentation search function for the following modes:"
                  "\n\n  - "
                  (s-join "\n\n  - " (-map 'symbol-name modes)))

         (when (apply 'derived-mode-p ',modes)
           ,@body
           major-mode))

       (add-hook 'evil-find-doc-hook ',fname))))

(defun get-manpage (candidate)
  "Show the manpage for CANDIDATE."
  (let ((wfiles (mapcar 'car (woman-file-name-all-completions candidate))))
    (condition-case _
        (if (> (length wfiles) 1)
            (woman-find-file
             (helm-comp-read
              "ManFile: " wfiles :must-match t))
          (woman candidate))
      ;; If woman is unable to format correctly use man instead.
      (error
       (kill-buffer)
       (Man-getpage-in-background candidate)))
    t))

(defun cbevil:get-documentation ()
  "Get documentation for string CANDIDATE.
Runs each handler added to `evil-find-doc-hook' until one of them returns non-nil."
  (interactive)
  (condition-case-unless-debug _
      (or (run-hook-with-args-until-success 'evil-find-doc-hook)
          (get-manpage (thing-at-point 'symbol)))
    (error
     (user-error "No documentation available"))))
#+end_src
** Use evil window shortcuts in Emacs state
Make evil emacs-state use the same window management bindings for consistency.
This makes switching to a buffer in Emacs state more tolerable.
#+begin_src emacs-lisp
(define-prefix-command 'cb:evil-window-emu)
(global-set-key (kbd "C-w") 'cb:evil-window-emu)
(bind-keys
  :overriding? t
  "C-w C-w" 'evil-window-prev
  "C-w C-s" 'split-window-vertically
  "C-w C-v" 'split-window-horizontally
  "C-w C-o" 'delete-other-windows
  "C-w C-c" 'delete-window
  "C-w w" 'evil-window-prev
  "C-w s" 'split-window-vertically
  "C-w v" 'split-window-horizontally
  "C-w o" 'delete-other-windows
  "C-w c" 'delete-window)
#+end_src
** Mode-specific key bindings
#+begin_src emacs-lisp
(evil-add-hjkl-bindings tar-mode-map)
(evil-add-hjkl-bindings occur-mode-map)
(evil-add-hjkl-bindings archive-mode-map)
(evil-add-hjkl-bindings package-menu-mode-map)

(after 'man
  (evil-define-key 'normal Man-mode-map (kbd "q") 'Man-kill))

(add-hook 'message-mode-hook 'evil-append-line)

(after 'undo-tree
  ;; Ensure undo-tree commands are remapped. The referenced keymap in
  ;; evil-integration is incorrect.
  (define-keys undo-tree-visualizer-mode-map
    [remap evil-backward-char] 'undo-tree-visualize-switch-branch-left
    [remap evil-forward-char]  'undo-tree-visualize-switch-branch-right
    [remap evil-next-line]     'undo-tree-visualize-redo
    [remap evil-previous-line] 'undo-tree-visualize-undo))

(evil-global-set-key 'insert (kbd "S-TAB") 'tab-to-tab-stop)
#+end_src
** Surround
Adds commands to manipulate braces and XML tags.
#+begin_src emacs-lisp
(cb:install-package 'surround t)
#+end_src
*** Remove padding around pairs.
#+begin_src emacs-lisp
(setq-default surround-pairs-alist
              '((?\( . ("(" . ")"))
                (?\[ . ("[" . "]"))
                (?\{ . ("{" . "}"))

                (?\) . ("(" . ")"))
                (?\] . ("[" . "]"))
                (?\} . ("{" . "}"))

                (?# . ("#{" . "}"))
                (?b . ("(" . ")"))
                (?B . ("{" . "}"))
                (?> . ("<" . ">"))
                (?t . surround-read-tag)
                (?< . surround-read-tag)
                (?f . surround-function)))
#+end_src
*** Define a specific set of pairs for emacs-lisp-mode
#+begin_src emacs-lisp
(hook-fn 'cb:elisp-modes-hook
  (make-local-variable 'surround-pairs-alist)
  (push '(?\` . ("`" . "'")) surround-pairs-alist))
#+end_src
*** Enable surround mode
#+begin_src emacs-lisp
(global-surround-mode +1)
#+end_src
** Evil numbers
Provides commands for incrementing and decrementing numbers at point.
#+begin_src emacs-lisp
(cb:install-package 'evil-numbers t)
#+end_src
*** Set key bindings
#+begin_src emacs-lisp
(define-keys evil-normal-state-map
  "C--" 'evil-numbers/dec-at-pt
  "C-+" 'evil-numbers/inc-at-pt)
#+end_src
** Vimrc mode
Provides a major mode for editing vimscript.
#+begin_src emacs-lisp
(cb:install-package 'vimrc-mode)
(add-to-list 'auto-mode-alist '("vimrc$" . vimrc-mode))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Flycheck
#+begin_src emacs-lisp
(cb:install-package 'flycheck)
(global-flycheck-mode)
#+end_src
** Ignore errors when checking a buffer.
#+begin_src emacs-lisp
(defadvice flycheck-buffer (around ignore-errors activate)
  (ignore-errors ad-do-it))
#+end_src
** Bind M-N and M-P to navigate errors
#+begin_src emacs-lisp
(bind-key "M-P" 'flycheck-previous-error flycheck-mode-map)
(bind-key "M-N" 'flycheck-next-error flycheck-mode-map)
#+end_src
* Spelling
** Ispell
#+begin_src emacs-lisp
(unless noninteractive (require 'ispell))
#+end_src
*** Use aspell where available
#+begin_src emacs-lisp
(setq ispell-program-name "aspell")
#+end_src
*** Use British English dictionary
#+begin_src emacs-lisp
(setq ispell-dictionary "en_GB")
#+end_src
*** Add words to dictionary without confirmation
#+begin_src emacs-lisp
(setq ispell-silently-savep t)
#+end_src
*** Define a command to programatically add a word to the dictionary
#+begin_src emacs-lisp
(defun ispell-add-to-dict (word)
  "Add WORD to the user's dictionary."
  (ispell-send-string (concat "*" word "\n"))
  (setq ispell-pdict-modified-p '(t))
  (ispell-pdict-save ispell-silently-savep))
#+end_src
** Flyspell
Checks spelling in the background and highlights mispelled words.
#+begin_src emacs-lisp
(unless noninteractive (require 'flyspell))
#+end_src
*** Check after 1 second of idle delay
#+begin_src emacs-lisp
(setq flyspell-delay 1)
#+end_src
*** Enable flyspell
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
(add-hook 'cb:xml-modes-hook 'flyspell-prog-mode)
#+end_src
*** Set key bindings
#+begin_src emacs-lisp
(after 'flyspell
  (define-key flyspell-mouse-map [down-mouse-3] 'flyspell-correct-word)
  (define-key flyspell-mouse-map [mouse-3] 'undefined)
  (define-key flyspell-mode-map (kbd "C-c $") nil))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'flyspell-mode-hook
  (diminish 'flyspell-mode))
#+end_src
** Flyspell-lazy
Improves the performance of flyspell.
#+begin_src emacs-lisp
(cb:install-package 'flyspell-lazy)
(add-hook 'flyspell-mode-hook 'flyspell-lazy-mode)
#+end_src
* Tags
ctags-related commands. Adapted from [[http://mattbriggs.net/blog/2012/03/18/awesome-emacs-plugins-ctags/][Awesome Emacs Plugins: CTags]]
** Make tags searches case-sensitive
#+begin_src emacs-lisp
(setq tags-case-fold-search nil)
#+end_src
** Install library used for tag searching
#+begin_src emacs-lisp
(cb:install-package 'etags-select)
#+end_src
** Define patterns to exclude
#+begin_src emacs-lisp
(defvar ctags-exclude-patterns '("db" "test" ".git" "public" "flycheck-"))
#+end_src
** Define a command for building tags
#+begin_src emacs-lisp
(defun cb:format-tags-excludes ()
  (let ((sep " --exclude="))
    (concat sep (s-join sep ctags-exclude-patterns))))

(defun cbtags:project-root ()
  (or (projectile-project-p) default-directory))

(defun build-ctags ()
  "Create a tags file at the root of the current project."
  (interactive)
  (message "Building project tags...")
  (let* ((dir (cbtags:project-root))
         (tags (concat dir "TAGS")))
    ;; Confirm when creating tags outside the home dir, or at the root of the
    ;; home dir.
    (unless (or (f-child-of? dir user-home-directory)
                (y-or-n-p (format "Really create tags in \"%s\"? " dir)))
      (error "Tags not created"))
    ;; Write tags.
    (if (zerop (%-sh "ctags -e -R --extra=+fq"
                     (cb:format-tags-excludes)
                     "-f" dir))
        (message "Tags written to \"%s\"" tags)
      (error "Failed to create tags"))))
#+end_src
** Define a command for visiting tags files.
#+begin_src emacs-lisp
(defun visit-ctags ()
  "Visit the tags file at the root of the current project."
  (interactive)
  (let ((tags-revert-without-query t))
    (visit-tags-table (cbtags:project-root))
    (message "Loaded %s" tags-file-name)))
#+end_src
** Define a command for creating and loading tags
#+begin_src emacs-lisp
(defun load-ctags ()
  "Create a tags file at the root of the current project, then load it."
  (interactive)
  (and (build-ctags) (visit-ctags)))
#+end_src
** Define a command for finding the tag at point
#+begin_src emacs-lisp
(defun find-ctag ()
  "Find the tags at point, creating a tags file if none exists."
  (interactive)
  (if (file-exists-p (f-join (cbtags:project-root) "TAGS"))
      (visit-ctags)
    (build-ctags))
  (etags-select-find-tag-at-point))
#+end_src
** Set key bindings for the above commands
#+begin_src emacs-lisp
(global-set-key (kbd "M-.") 'find-ctag)
#+end_src
** Evil
#+begin_src emacs-lisp
(after 'evil
  (evil-global-set-key 'normal (kbd "M-.") 'find-ctag)
  (evil-global-set-key 'normal (kbd "C-]") 'find-ctag))
#+end_src
** Auto-update tags
#+begin_src emacs-lisp
(cb:install-package 'ctags-update)
(add-hook 'prog-mode-hook 'turn-on-ctags-auto-update-mode)
#+end_src
*** Use a tmp dir for tags if the current project does not have a tags file
#+begin_src emacs-lisp
(setq tags-file-name (f-join (make-temp-file "tags" t) "TAGS"))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'ctags-auto-update-mode-hook
  (diminish 'ctags-auto-update-mode))
#+end_src
* Smartparens
Provides commands creating balanced parens and editing such expressions in a
structured way.
#+begin_src emacs-lisp
(cb:install-package 'smartparens t)
(smartparens-global-mode)
#+end_src
** Use strict version of smartparens for programming modes
#+begin_src emacs-lisp
(hook-fns '(prog-mode-hook cb:markup-modes-hook)
  (smartparens-strict-mode +1))
#+end_src
** Show matching parens
#+begin_src emacs-lisp
(show-smartparens-global-mode +1)
#+end_src
** Load default config
#+begin_src emacs-lisp
(require 'smartparens-config)
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'smartparens-mode)
#+end_src
** Wrapping
*** Make Paredit-style wrapping commands.
#+begin_src emacs-lisp
(sp-pair "(" ")" :bind "M-(")
(sp-pair "{" "}" :bind "M-{")
(sp-pair "[" "]" :bind "M-[")
(sp-pair "\"" "\"" :bind "M-\"")
(sp-pair "`" "`" :bind "M-`")
(sp-pair "'" "'" :actions '(:rem insert))
#+end_src
*** Use apostrophe pairs only for certain modes.
#+begin_src emacs-lisp
(sp-with-modes (-flatten (list cb:ruby-modes
                               cb:python-modes
                               'shell-script-mode
                               'makefile-mode
                               'conf-mode))
  (sp-local-pair
   "'" "'"
   :bind "M-'"
   :actions '(:add insert)
   :when '(:add sp-in-code-p)
   :unless '(:add sp-in-string-p)))
#+end_src
*** Don't wrap subsequent words when opening a pair
#+begin_src emacs-lisp
(setq sp-autoinsert-if-followed-by-word t)
#+end_src
** Keys
#+begin_src emacs-lisp
(define-keys sp-keymap
  "C-<backspace>" 'sp-backward-up-sexp
  "DEL"           'sp-backward-delete-char)

;; Use bind-key for keys that tend to be overridden.
(bind-key "C-M-," 'sp-backward-down-sexp sp-keymap)
(bind-key "C-M-." 'sp-next-sexp sp-keymap)
#+end_src
** Make sexp killing behaviour to be more like paredit's
#+begin_src emacs-lisp
(defun cb-sp:kill-blank-lines (&optional arg)
  (interactive "P")
  (cond
   ((s-blank? (s-trim (current-line)))
    (kill-whole-line))
   (t
    (sp-kill-sexp nil arg))))

(define-key sp-keymap (kbd "C-k") 'cb-sp:kill-blank-lines)
#+end_src
** Only enable smartparens in the minibuffer for certain commands.
#+begin_src emacs-lisp
(defvar sp-minibuffer-enabled-commands
  '(eval-expression calc-algebraic-entry quick-calc)
  "Commands that take input in the minibuffer for which smartparens should be used.")

(hook-fns '(minibuffer-setup-hook minibuffer-inactive-mode-hook)
  :append t
  (smartparens-mode (if (-contains? sp-minibuffer-enabled-commands this-command)
                        +1 -1)))
#+end_src
** Uilities
#+begin_src emacs-lisp
(defun sp-generic-leading-space (&optional id action ctx)
  "Pad ID with a leading space unless point is either:
1. at the start of a braced expression
2. at indentation."
  (when (and (equal 'insert action)
             (sp-in-code-p id action ctx))
    (save-excursion
      (search-backward id)
      (unless (s-matches?
               (rx (or (group bol (* space))
                       (any "(" "[" "{")) eol)
               (buffer-substring (line-beginning-position) (point)))
        (just-one-space)))))
#+end_src
** Always insert or move up delimiters
Mimic the paredit behaviour of never inserting more closing parens than needed,
and reformatting parens as closing parens are added.

*** Close paren keys move up sexp.
#+begin_src emacs-lisp
(setq sp-navigate-close-if-unbalanced t)
#+end_src
*** Insert parens or move up when typing a paren key
#+begin_src emacs-lisp
(defun sp-insert-or-up (delim &optional arg)
  "Insert a delimiter DELIM if inside a string, else move up."
  (interactive "sDelimiter:\nP")
  (cond ((or (emr-looking-at-string?) (emr-looking-at-comment?))
         (insert delim))
        (smartparens-mode
         (sp-up-sexp arg 'interactive))
        (t
         (insert delim))))
#+end_src

HACK: There seems to be a race condition that clobbers customisations to the
smartparens maps, so manually set custom bindings in a hook.
#+begin_src emacs-lisp
(defun cbsp:hacky-set-sp-bindings ()
  (cl-loop for key in '(")" "]" "}")
           for map in '(smartparens-mode-map smartparens-strict-mode-map)
           do (eval `(bind-key
                      (kbd key)
                      (command (with-demoted-errors
                                 (sp-insert-or-up ,key _arg)))
                      ,map))))

(hook-fns '(smartparens-mode-hook smartparens-strict-mode-hook)
  :append t
  (cbsp:hacky-set-sp-bindings))
#+end_src
** Evil
*** Bind navigation commands to paren keys
#+begin_src emacs-lisp
(after 'evil
  (evil-global-set-key 'normal "(" 'sp-backward-up-sexp)
  (evil-global-set-key 'normal ")" 'sp-forward-sexp))
#+end_src
*** Define a special paren state for evil-mode
#+begin_src emacs-lisp
(after 'evil
  (evil-define-state paren "Paren editing state."
    :tag " <P> "
    :message "-- PAREN --"
    :suppress-keymap t
    :cursor 'hollow)

  (hook-fn 'evil-paren-state-entry-hook
    (when (equal last-command 'evil-end-of-line)
      (forward-char)))

  ;; Configure entry and exit from paren state.
  (evil-global-set-key 'normal (kbd ",") 'evil-paren-state)
  (define-key evil-paren-state-map (kbd "ESC") 'evil-normal-state)
  (define-key evil-paren-state-map (kbd "C-g") 'evil-normal-state)
  ;; Define paren state keys.
  (evil-global-set-keys 'paren
    "A" 'sp-add-to-previous-sexp
    "a" 'sp-add-to-next-sexp
    "B" 'sp-backward-barf-sexp
    "b" 'sp-forward-barf-sexp
    "M" 'sp-backward-slurp-sexp
    "m" 'sp-forward-slurp-sexp
    "c" 'sp-convolute-sexp
    "D" 'sp-backward-kill-sexp
    "d" 'sp-kill-sexp
    "e" 'sp-emit-sexp
    "G" 'sp-end-of-sexp
    "g" 'sp-beginning-of-sexp
    "j" 'sp-join-sexp
    "K" 'sp-splice-sexp-killing-backward
    "k" 'sp-splice-sexp-killing-forward
    "n" 'sp-next-sexp
    "p" 'sp-previous-sexp
    "r" 'sp-raise-sexp
    "s" 'sp-splice-sexp-killing-around
    "t" 'sp-transpose-sexp
    "U" 'sp-backward-unwrap-sexp
    "u" 'sp-unwrap-sexp
    "w" 'sp-rewrap-sexp
    "x" 'sp-split-sexp
    "Y" 'sp-backward-copy-sexp
    "y" 'sp-copy-sexp
    "," 'sp-previous-sexp
    "." 'sp-next-sexp
    "<" 'sp-backward-down-sexp
    ">" 'sp-down-sexp))
#+end_src
** TeX
#+begin_src emacs-lisp
(after '(smartparens tex)
  (require 'smartparens-latex))
#+end_src
* Smart operators
Automatically format inserted operators.
#+begin_src emacs-lisp
(cb:install-package 'smart-operator t)
#+end_src
** Reindent the current line after inserting an equals
#+begin_src emacs-lisp
(defadvice smart-insert-operator (after indent-after-insert-equals activate)
  (when (equal (ad-get-arg 0) "=")
    (unless (apply 'derived-mode-p cb:whitespace-sensitive-languages)
      (save-excursion
        (indent-according-to-mode)))))
#+end_src
** Use self-insert rather than smart operator at strings or comments
#+begin_src emacs-lisp
(defadvice smart-insert-operator (around normal-insertion-for-string activate)
  (if (or
       ;; Looking at a string?
       (-contains? '(font-lock-string-face
                     font-lock-doc-face
                     font-lock-doc-string-face
                     font-lock-comment-face)
                   (face-at-point))
       ;; Looking at quotation mark?
       (-contains? '(?\" ?\') (char-after)))
      (insert (ad-get-arg 0))
    ad-do-it))
#+end_src
** Define a helper macro for defining smart operator commands
#+begin_src emacs-lisp
(defmacro smart-op (op)
  "Make a smart operator command that will insert OP."
  `(command (smart-insert-operator ,op)))
#+end_src
* EMR
Adds refactoring commands for Lisps.
#+begin_src emacs-lisp
(cb:install-package 'emr)
(add-hook 'prog-mode-hook 'emr-initialize)
#+end_src
** Set a key to show EMR menus.
#+begin_src emacs-lisp
(bind-key "C-M-<return>" 'emr-show-refactor-menu)
#+end_src
* Whitespace
Visualise whitespace chars.
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'whitespace-mode)
#+end_src
** Highlight trailing whitespace and long lines
#+begin_src emacs-lisp
(setq whitespace-line-column 80
      whitespace-style '(face lines-tail))
#+end_src
** Ignore errors when starting whitespace mode
#+begin_src emacs-lisp
(defadvice whitespace-turn-on (around ignore-errors activate)
  (condition-case _
      ad-do-it
    (void-function)))
#+end_src
** Diminish
#+begin_src emacs-lisp
(hook-fn 'whitespace-mode-hook
  (diminish 'whitespace-mode))
#+end_src
* highlight-symbol
Highlights the symbol at point.
#+begin_src emacs-lisp
(cb:install-package 'highlight-symbol)
(add-hook 'prog-mode-hook 'highlight-symbol-mode)
#+end_src
** Highlight after a delay
#+begin_src emacs-lisp
(setq highlight-symbol-idle-delay 0.5)
#+end_src
** Override default face
#+begin_src emacs-lisp
(defface highlight-symbol-face
  '((((class color) (background dark))
     (:bold t :foreground "wheat3"))
    (((class color) (background light))
     (:bold t :foreground "wheat4")))
  "Face used by `highlight-symbol-mode'."
  :group 'highlight-symbol)
#+end_src
** Diminish
#+begin_src emacs-lisp
(hook-fn 'highlight-symbol-mode-hook
  (diminish 'highlight-symbol-mode))
#+end_src
* Modeline
Use a custom mode line.
** Faces
#+begin_src emacs-lisp
(defface mode-line-tramp-separator
  '((((background dark))
     (:foreground "gray45"))
    (((background light))
     (:foreground "gray80"))
    (t
     (:inherit 'mode-line)))
  "Face for separator characters in modeline."
  :group 'modeline)

(defface mode-line-tramp-method
  '((t (:inherit 'mode-line)))
  "Face for tramp method in modeline."
  :group 'modeline)

(defface mode-line-tramp-user
  '((t (:foreground "VioletRed3" :inherit 'mode-line)))
  "Face for tramp user indicator in modeline."
  :group 'modeline)

(defface modeline-vc-unknown-face
  '((((background dark))
     (:foreground "yellow"))
    (((background light))
     (:foreground "blue"))
    (t
     (:inherit 'mode-line)))
  "Face for unknown vc file status."
  :group 'modeline)

(defface mode-line-read-only
  '((t (:foreground "#4271ae"
                    :box '(:line-width 2 :color "#4271ae")
                    :inherit 'mode-line)))
  "Face for readonly indicator."
  :group 'modeline)

(defface mode-line-modified
  '((t (:foreground "#c82829" :inherit 'mode-line)))
  "Face for modified indicator."
  :group 'modeline)

(defface mode-line-directory
  '((((background dark))
     (:foreground "gray60"))
    (((background light))
     (:foreground "gray70"))
    (t
     (:inherit 'mode-line)))
  "Face for the directory component of the current filename."
  :group 'modeline)

(defface mode-line-filename
  '((((background light))
     (:foreground "darkgoldenrod4" :weight bold))
    (((background dark))
     (:foreground "#eab700" :weight bold))
    (t
     (:inherit 'mode-line)))
  "Face for the name component of the current filename."
  :group 'modeline)

(defface mode-line-position
  `((((background dark))
     (:family ,(monospace-font)
              :height 100
              :foreground "gray60"))
    (((background light))
     (:family ,(monospace-font)
              :height 100
              :foreground "gray50"))
    (t
     (:inherit 'mode-line)))
  "Face for the position indicators."
  :group 'modeline)

(defface mode-line-mode
  '((((background dark))
     (:foreground "gray70"))
    (((background light))
     (:foreground "gray40"))
    (t
     (:inherit 'mode-line)))
  "Face for the current major mode indicator."
  :group 'modeline)

(defface mode-line-minor-mode
  '((((background dark))
     (:foreground "gray40" :height 110))
    (((background light))
     (:foreground "gray70" :height 110))
    (t (:inherit 'mode-line-mode)))
  "Face for the current minor mode indicators."
  :group 'modeline)

(defface mode-line-process
  '((t (:foreground "#718c00" :inherit 'mode-line)))
  "Face for the current process."
  :group 'modeline)

(defface mode-line-80col
  '((((background dark))
     (:foreground "#eab700"))
    (((background light))
     (:foreground "#b58900"))
    (t
     (:inherit 'mode-line-position)))
  "Face for the warning when point is past column 80."
  :group 'modeline)

(defface modeline-org-notes-file-indicator
  `((t (:foreground
        ,solarized-hl-magenta
        :inherit
        'mode-line-position)))
  "Face for the indicator showing the name of the current org notes file."
  :group 'modeline)

#+end_src
** Vars
#+begin_src emacs-lisp
(defvar modeline-mail-indicator nil)

(defvar modeline-custom-description-functions nil
  "A list of functions.
The first function returning non-nil is used for the description
section in the modeline.")
#+end_src
** Auxiliary functions
#+begin_src emacs-lisp
(cl-defun cb:vc-state->letter (&optional (file (buffer-file-name)))
  "Return a single letter to represent the current version-control status."
  (cl-case (ignore-errors (vc-state file))
    ((up-to-date)           " ")
    ((edited)               (propertize "M" 'face '(:foreground "red")))
    ((needs-merge conflict) (propertize "!" 'face '(:foreground "red")))
    ((added)                (propertize "A" 'face '(:foreground "green")))
    ((removed)              (propertize "D" 'face '(:foreground "red")))
    ((ignored)              (propertize "-" 'face 'modeline-vc-unknown-face))
    (t                      (propertize "?" 'face 'modeline-vc-unknown-face))))

(cl-defun cb:vc-file-uptodate? (&optional (file (buffer-file-name)))
  "Non-nil if FILE is up-to-date."
  (ignore-errors
    (vc-state-refresh file 'git)
    (equal 'up-to-date (vc-state file))))

(cl-defun cb:shorten-directory (dir &optional (max-length 30))
  "Show up to MAX-LENGTH characters of a directory name DIR."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
        (output ""))
    (when (and path (equal "" (car path)))
      (setq path (cdr path)))
    ;; Ellipsize the path if it is too long.
    ;; `2` is the length of the path separator + ellipsis.
    (while (and path (< (length output) (- max-length 2)))
      (setq output (concat (car path) "/" output))
      (setq path (cdr path)))
    (when path
      (setq output (concat "…/" output)))
    output))

(cl-defun cb:propertize-file-directory
    (&optional (filepath (file-name-directory (buffer-file-name))))
  "Separate tramp info from the given filepath."
  (cl-flet ((face
             (str face)
             (propertize str 'face face)))

    (cl-destructuring-bind (&optional method user host file &rest rs)
        (mapcar 'identity (ignore-errors
                            (tramp-dissect-file-name filepath)))
      (concat
       (when host
         (concat
          (face "/" 'mode-line-tramp-separator)
          (face method 'mode-line-tramp-method)
          (face ":" 'mode-line-tramp-separator)
          (face user 'mode-line-tramp-user)
          (face "@" 'mode-line-tramp-separator)
          host
          (face ":" 'mode-line-tramp-separator)))
       (face (cb:shorten-directory (or file filepath)) 'mode-line-directory)))))

(defun cbmd:description ()
  "Format the mode line description.
This will normally be the path and buffer name, unless there is a suitable
entry in `modeline-custom-description-functions'."
  (or
   (-when-let (s (-first 'funcall modeline-custom-description-functions))
     (propertize (funcall s) 'face 'mode-line-filename))
   (concat
    (if (buffer-file-name) (cb:propertize-file-directory) "")
    (propertize (buffer-name) 'face 'mode-line-filename))))
#+end_src
** Unread mail count
** Mode line format
#+begin_src emacs-lisp
(setq-default
 mode-line-format
 `(
   ;; --------------------------------------------------------------------------
   ;; Line and column number.
   (:propertize " %4l:" face mode-line-position)
   (:eval
    ;; Warn if over 80 columns.
    (propertize "%3c" 'face
                (if (>= (current-column) 80)
                    'mode-line-80col
                  'mode-line-position)))

   " "

   ;; Evil state
   (:eval
    (if (and (featurep 'evil) (true? evil-mode))
        evil-mode-line-tag
      ""))

   ;; --------------------------------------------------------------------------
   ;; Mail status.
   (:eval (or (and (true? cbm:mode-line-indicator)
                   (concat " " cbm:mode-line-indicator " "))
              ""))

   ;; Pomodoro
   (:eval (or (and (true? org-pomodoro-mode-line)
                   (s-join "" org-pomodoro-mode-line))
              ""))

   ;; Current org notes file
   (:eval (or (and (true? org-init-notes-file)
                   (not (equal org-init-notes-file org-default-notes-file))
                   (propertize (concat " ["
                                       (f-filename (f-no-ext org-default-notes-file))
                                       "] ")
                               'face 'modeline-org-notes-file-indicator))
              ""))

   ;; --------------------------------------------------------------------------
   ;; File status.
   (:eval
    (let ((blank "    "))
      (cond
       ;; Do not show status for special buffers.
       ((and (s-starts-with? "*" (buffer-name))
             (not (buffer-file-name)))
        blank)

       ;; Show read-only indicator.
       (buffer-read-only
        (propertize " RO " 'face 'mode-line-read-only))

       ;; Show modified and vc status.
       (t
        (format " %s%s "
                (if (ignore-errors (vc-git-root (buffer-file-name)))
                    (cb:vc-state->letter)
                  " ")
                (if (buffer-modified-p)
                    (propertize "*" 'face 'mode-line-modified)
                  " "))))))
   " "
   ;; --------------------------------------------------------------------------
   ;; Buffer name and path.
   (:eval (cbmd:description))

   ;; --------------------------------------------------------------------------
   ;; Narrowing
   " %n "

   ;; --------------------------------------------------------------------------
   ;; Mode details.

   ;; Major mode.
   " %["
   (:propertize mode-name
                face mode-line-mode)
   "%] "

   ;; Minor modes.
   (:eval (propertize (format-mode-line minor-mode-alist)
                      'face 'mode-line-minor-mode))
   (:propertize mode-line-process
                face mode-line-process)
   " "
   (:eval (or (ignore-errors
                (propertize modeline-mail-indicator 'face 'mode-line-emphasis))
              ""))
   " "
   (global-mode-string global-mode-string)))
#+end_src
* Git
** Magit
Magit provides a convenient interface to git commands.
#+begin_src emacs-lisp
(cb:install-package 'magit)
#+end_src
*** Declare a key binding to show magit fullscreen
#+begin_src emacs-lisp
(declare-modal-executor magit-status
  :command (call-interactively 'magit-status)
  :bind    "M-G")
#+end_src
*** Use ido to read the magit directory
#+begin_src emacs-lisp
(after 'magit
  (declare-ido-wrapper magit-read-top-dir))
#+end_src
*** Customise magit according to global git config
#+begin_src emacs-lisp
(add-hook 'magit-mode-hook 'magit-load-config-extensions)
#+end_src
*** Evil
**** DEFER
#+begin_src emacs-lisp
(after '(magit evil)
#+end_src
**** Bind common magit commands to the /g/ prefix in normal state
#+begin_src emacs-lisp
(evil-global-set-keys 'normal
 "g P" 'magit-key-mode-popup-pushing
 "g c" 'magit-key-mode-popup-committing
 "g l" 'magit-log
 "g r" 'magit-reflog
 "g D" 'magit-diff-working-tree
 "g B" 'magit-blame-mode
 "g b" (command
        (with-window-restore
          (magit-branch-manager)
          (buffer-local-set-key (kbd "q") (command (restore))))))
#+end_src
**** Use evil key bindings in magit diff mode
#+begin_src emacs-lisp
(define-keys magit-diff-mode-map
  "C-f" 'evil-scroll-page-down
  "C-b" 'evil-scroll-page-up
  "j"   'evil-next-line
  "k"   'evil-previous-line
  "/"   'evil-search-forward)
#+end_src
**** END
#+begin_src emacs-lisp
)
#+end_src
*** Dired
Override dired's default bindings to enable Magit from dired mode.
#+begin_src emacs-lisp
(after 'dired
  (define-key dired-mode-map (kbd "M-G") 'magit-status))
#+end_src
*** Modal views
Declare modal views for magit.
#+begin_src emacs-lisp
(declare-modal-view magit-status)
(declare-modal-view magit-log)
(declare-modal-view magit-reflog)
(declare-modal-view magit-diff-working-tree)
(declare-modal-view magit-diff)
#+end_src
*** Modeline
Update git status in the modeline magit commands.
**** Define a hook for all magit commands
#+begin_src emacs-lisp
(define-combined-hook cb:magit-command-hook
  (--filter-atoms (s-matches? "^magit-.*-command-hook$" (symbol-name it))))
#+end_src
**** Use this hook to force modeline updates
#+begin_src emacs-lisp
(hook-fn 'cb:magit-command-hook
  (force-mode-line-update t))
#+end_src
** git-auto-commit-mode
Minor mode that will automatically commit changes on save.
#+begin_src emacs-lisp
(cb:install-package 'git-auto-commit-mode)
#+end_src
*** Mark variables as safe
#+begin_src emacs-lisp
(add-to-list 'safe-local-variable-values '(gac-automatically-push-p . t))
#+end_src
** git-commit-mode
Provides a major mode for editing commit messages. Used by magit.
#+begin_src emacs-lisp
(add-hook 'git-commit-mode-hook 'turn-on-auto-fill)
(put 'git-commit-mode 'fill-column 72)
#+end_src
*** Evil
Enter insertion state when prompted to enter commit messages.
#+begin_src emacs-lisp
(add-hook 'git-commit-mode-hook 'evil-insert-state)
#+end_src
** Gist
Provides an Elisp interface to GitHub Gists.
#+begin_src emacs-lisp
(cb:install-package 'gist)
#+end_src
** gitconfig-mode
Provides a major mode for editing git config files.
#+begin_src emacs-lisp
(cb:install-package 'gitconfig-mode)
#+end_src
** git-gutter+
Marks unstaged and deleted hunks in the gutter.
#+begin_src emacs-lisp
(cb:install-package 'git-gutter+)
#+end_src
*** Defer loading until we navigate to a file under version control
#+begin_src emacs-lisp
(hook-fns '(find-file-hook after-save-hook)
  (when (vc-git-root (buffer-file-name))
    (require 'magit)
    (require 'git-gutter+)
    (ignore-errors (git-gutter+-mode +1))))
#+end_src
*** Refresh git gutter after saving
#+begin_src emacs-lisp
(hook-fn 'after-save-hook
  (when (true? git-gutter+-mode)
    (ignore-errors
      (git-gutter+-refresh))))
#+end_src
*** Use an idle timer to refresh git gutter status
#+begin_src emacs-lisp
(defvar cb-git:gutter-refresh-idle-timer
  (unless noninteractive
    (run-with-idle-timer 1.5 t (lambda ()
                                 (when (true? git-gutter+-mode)
                                   (ignore-errors (git-gutter+-refresh)))))))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'git-gutter+-mode-hook
  (diminish 'git-gutter+-mode))
#+end_src
** Hacky fixes

Internal functions attempt to call =magit-read-top-dir= as a variable. Bind a
variable to prevent errors.
#+begin_src emacs-lisp
(defvar magit-read-top-dir 'magit-read-top-dir)
#+end_src

The close buffer function is broken. Redefine it so that it works.
#+begin_src emacs-lisp
(after 'git-gutter+
  (defun git-gutter+-close-commit-edit-buffer ()
    "Abort edits and discard commit message being composed."
    (interactive)
    (remove-hook 'kill-buffer-hook 'server-kill-buffer t)
    (remove-hook 'kill-buffer-query-functions 'git-commit-kill-buffer-noop t)
    (let ((clients (git-commit-buffer-clients)))
      (if clients
          (dolist (client clients)
            (server-send-string client "-error Commit aborted by user")
            (delete-process client))
        (kill-buffer)))

    (set-window-configuration git-gutter+-pre-commit-window-config)))
#+end_src
** Utilities
Define a command to add the current buffer to git, or stage all changes.
#+begin_src emacs-lisp
(defun cb-git:add ()
  "Run 'git add' on the file for the current buffer."
  (interactive)
  (cond
   ((not (buffer-file-name))
    (user-error "Buffer has no corresponding file"))
   ((not (vc-git-root (buffer-file-name)))
    (user-error "Not a git repository"))
   ((yes-or-no-p "Stage all changes to this file?")
    (save-buffer)
    (vc-git-register (list (buffer-file-name)))
    (message "Done.")))
  (git-gutter+-refresh))
#+end_src
** Evil
Define bindings for working with git hunks under the /g/ prefix.
#+begin_src emacs-lisp
(after '(git-gutter+ evil)
  (evil-global-set-keys 'normal
    "g n" (lambda (arg)
            (interactive "p")
            (git-gutter+-refresh)
            (git-gutter+-next-hunk arg))
    "g p" (lambda (arg)
            (interactive "p")
            (git-gutter+-refresh)
            (git-gutter+-previous-hunk arg))
    "g h" 'git-gutter+-popup-hunk
    "g x" 'git-gutter+-revert-hunk
    "g s" 'git-gutter+-stage-hunks
    "g a" 'cb-git:add)

  (add-hook 'magit-commit-mode-hook 'evil-insert-state))
#+end_src
** git-gutter-fringe+
I'm using a submodule version right now because the MELPA version has
unsatisfiable dependencies.
#+begin_src emacs-lisp
(cb:install-package 'fringe-helper)
(after 'git-gutter+ (require 'git-gutter-fringe+))
#+end_src
* Diffs
** Ediff
Configure ediff variables.
#+begin_src emacs-lisp
(setq diff-switches "-u"
      ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src
** Use /q/ to close diffs.
#+begin_src emacs-lisp
(defun cb-diff:close ()
  (interactive)
  (when (> (length (window-list)) 1)
    (kill-buffer-and-window)))

(after 'diff-mode
  (define-key diff-mode-map (kbd "q") 'cb-diff:close))
#+end_src
** Evil
*** Disable evil-mode when running diffs
#+begin_src emacs-lisp
(after 'evil
  (add-hook 'ediff-startup-hook 'turn-off-evil-mode))
#+end_src
*** Use /q/ to close diffs.
#+begin_src emacs-lisp
(after 'evil
  (evil-define-key 'normal diff-mode-map (kbd "q") 'cb-diff:close))
#+end_src
* Popwin
Allows you to declare buffers as popups and customise their properties.
#+begin_src emacs-lisp
(cb:install-package 'popwin t)
#+end_src
** Customise buffer handling.
#+begin_src emacs-lisp
(setq display-buffer-function 'popwin:display-buffer
      popwin:special-display-config
      '(("*Help*"  :height 30 :stick t)
        ("*Completions*" :noselect t)
        ("*Shell Command Output*")
        ("*compilation*" :noselect t)
        ("*Compile-Log*" :height 7 :noselect t)
        ("*Messages*" :height 30)
        ("* Racket REPL *" :height 7 :stick t)
        ("*Geiser dbg*" :height 7)
        ("*execute scheme*" :height 7 :noselect t)
        ("*haskell*" :height 7 :stick t)
        ("*Directory*")
        ("*Org Note*")
        ("*jedi:doc*" :height 30)
        ("*robe-doc*" :height 30)
        ("*idris-repl*" :height 30)
        ("\\*cider-repl " :height 7 :regexp t :stick t)
        ("*cider doc*" :height 30)
        ("*bbdb*")
        ("*BBDB*")
        ("*Occur*" :noselect t)
        ("\\*Slime Description.*" :noselect t :regexp t :height 30)
        ("\\*Slime Inspector.*" :regexp t :height 30)
        ("*sldb.*" :regexp t :height 30)
        ("*Ido Completions*" :noselect t :height 30)
        (".*overtone.log" :regexp t :height 30)
        ("*gists*" :height 30)))
#+end_src
* Dired
#+begin_src emacs-lisp
(setq dired-auto-revert-buffer t)
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'dired
#+end_src
** Show directories before files
#+begin_src emacs-lisp
(setq dired-listing-switches "-al --group-directories-first")
#+end_src
** Define compressed file types.
#+begin_src emacs-lisp
(setq dired-compress-file-suffixes
      '(("\\.zip\\'" ".zip" "unzip")
        ("\\.gz\\'" "" "gunzip")
        ("\\.tgz\\'" ".tar" "gunzip")
        ("\\.Z\\'" "" "uncompress")
        ("\\.z\\'" "" "gunzip")
        ("\\.dz\\'" "" "dictunzip")
        ("\\.tbz\\'" ".tar" "bunzip2")
        ("\\.bz2\\'" "" "bunzip2")
        ("\\.xz\\'" "" "unxz")
        ("\\.tar\\'" ".tgz" nil)))
#+end_src
** Don't bind C-x C-j to dired-jump
This interferes with bindings in ansi-term.
#+begin_src emacs-lisp
(setq dired-bind-jump nil)
#+end_src
** dired-details
Toggle file and directory details, such as size and permissions.
#+begin_src emacs-lisp
(cb:install-package 'dired-details t)
(dired-details-install)
#+end_src
*** Use an ellipsis to indicate hidden details
#+begin_src emacs-lisp
(setq-default dired-details-hidden-string "… ")
#+end_src
** Omit certain files
Use =dired-omit-mode= to hide boring files from dired views.
#+begin_src emacs-lisp
(require 'dired-x)
(add-hook 'dired-mode-hook 'dired-omit-mode)
#+end_src
*** Configure files to hide.
#+begin_src emacs-lisp
(setq dired-omit-files
      (regexp-opt (list "^\\.?#" "^\\.$" "^\\.\\.$"
                        "\\.DS_Store$" "\\$RECYCLE.BIN")))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'dired-omit-mode-hook
  (diminish 'dired-omit-mode))
#+end_src
** hl-line compatability
Advise hl-line functions not to apply highlight to dired directory headers.
#+begin_src emacs-lisp
(defun cb:line-is-dired-header? ()
  (equal 'dired-header
         (ignore-errors
           (save-excursion
             (move-to-column 3)
             (face-at-point)))))

(defadvice global-hl-line-highlight (around suppress-on-subdir-header activate)
  "Do not highlight the line if looking at a dired header."
  (if (and (derived-mode-p 'dired-mode) (cb:line-is-dired-header?))
      (global-hl-line-unhighlight)
    ad-do-it))

(defadvice hl-line-highlight (around suppress-on-subdir-header activate)
  "Do not highlight the line if looking at a dired header."
  (if (and (derived-mode-p 'dired-mode) (cb:line-is-dired-header?))
      (hl-line-unhighlight)
    ad-do-it))
#+end_src
** OS X
Use GNU version of =ls= where available.
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
  (-when-let (gls (executable-find "gls"))
    (setq ls-lisp-use-insert-directory-program t
          insert-directory-program gls)))
#+end_src
** Define keys to navigate by subdirs
#+begin_src emacs-lisp
(define-key dired-mode-map (kbd "M-N") 'dired-next-subdir)
(define-key dired-mode-map (kbd "M-P") 'dired-prev-subdir)
#+end_src
** Evil
Load the following after =evil=.
#+begin_src emacs-lisp
(after 'evil
#+end_src
*** Define bindings for working with subdirs
#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map (kbd "SPC") 'dired-hide-subdir)
(evil-define-key 'normal dired-mode-map (kbd "TAB") 'dired-hide-subdir)
(evil-define-key 'normal dired-mode-map [backtab] 'dired-hide-all)
(evil-define-key 'normal dired-mode-map [backspace] 'dired-kill-subdir)
#+end_src
*** Bind commands to show containing folder in dired
#+begin_src emacs-lisp
(bind-key* "M-d" 'dired-jump)
(bind-key* "M-D" 'dired-jump-other-window)
#+end_src
#+begin_src emacs-lisp
)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Fortune
** Define a command to show the output of the =fortune= command
#+begin_src emacs-lisp
(defun fortune ()
  "Display a quotation from the 'fortune' program."
  (interactive)
  (-when-let (fortune (--first (ignore-errors (file-exists-p it))
                               (list (executable-find "fortune")
                                     "/usr/bin/fortune"
                                     "/usr/local/bin/fortune" )))
    (message (s-trim (shell-command-to-string (concat fortune " -s -n 250"))))))
#+end_src
** Show fortune after init
#+begin_src emacs-lisp
(defun cb:show-fortune ()
  "Show fortune if started without a file to visit."
  (run-with-idle-timer
   0.1 nil
   (lambda ()
     (when (or (-contains? '("*scratch*" "notes.org" "todo.org") (buffer-name))
               (derived-mode-p 'org-agenda-mode))
       (fortune)))))

(hook-fn 'after-make-frame-functions (cb:show-fortune))
(add-hook 'after-init-hook 'cb:show-fortune)
#+end_src

* TeX
Auctex provides a development environment for tex
#+begin_src emacs-lisp
(cb:install-package 'auctex)
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'tex
#+end_src

** Configure autex style variables
#+begin_src emacs-lisp
(setq TeX-auto-save t
      TeX-parse-self t)
#+end_src
** Position point inside braces when completing environments
#+begin_src emacs-lisp
(defadvice TeX-complete-symbol (after position-point activate)
  "Position point inside braces."
  (when (equal (char-before) ?\})
    (forward-char -1)))
#+end_src
** whizzytex
Provides live output display with incremental compilation.
#+begin_src emacs-lisp
(require 'whizzytex)
#+end_src
*** Configure whizzytex environment.
#+begin_src emacs-lisp
(defvar whizzytex-sty-installation "/usr/local/share/whizzytex/latex/whizzytex.sty"
  "Path to the whizzytex macro package.")

(defvar whizzytex-src (f-join cb:lib-dir "whizzytex" "src")
  "Path to the whizzytex sources.")

(defvar whizzy-command-name (f-join whizzytex-src "whizzytex"))
#+end_src
*** Enable =whizzytex= in tex buffers.
#+begin_src emacs-lisp
(defun cbwh:install-tex-macros ()
  "Prompt the user to install the tex macros if they do not exist."
  (unless (f-exists? whizzytex-sty-installation)
    (when (y-or-n-p (format "Install whizzytex macros into %s? "
                            (f-dirname whizzytex-sty-installation)))
      ;; Make installation directory and copy package there.
      (%-sudo (%-sh "mkdir -p" (f-dirname whizzytex-sty-installation)))
      (%-sudo (%-sh "cp -f"
                    (%-quote (f-join whizzytex-src "whizzytex.sty"))
                    (%-quote whizzytex-sty-installation))))))

(hook-fn 'tex-mode-hook
  (cbwh:install-tex-macros)
  (whizzytex-mode +1))
#+end_src
** PDF support
#+begin_src emacs-lisp
(TeX-global-PDF-mode +1)
#+end_src
** Show inline images
#+begin_src emacs-lisp
(require 'preview)
(require 'latex)
#+end_src
** Flycheck
Bind error navigation keys.
#+begin_src emacs-lisp
(after 'flycheck
  (bind-keys
    :map TeX-mode-map
    "M-P" 'flycheck-previous-error
    "M-N" 'flycheck-next-error
    "TAB" 'TeX-complete-symbol))
#+end_src
** Folding
=tex-fold= is part of auctex and provides improved folding commands over the
defaults provided by tex-mode.
#+begin_src emacs-lisp
(autoload 'TeX-fold-mode "tex-fold")
(hook-fns '(tex-mode-hook latex-mode-hook)
  (TeX-fold-mode +1))
#+end_src
** Evil
Configure environment folding for =evil-mode=.
#+begin_src emacs-lisp
(after '(evil tex)
  (evil-define-key 'normal TeX-mode-map
    (kbd "z m") 'TeX-fold-buffer
    (kbd "z r") 'TeX-fold-clearout-buffer
    (kbd "SPC") 'TeX-fold-dwim))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Info
Configue info-mode.
#+begin_src emacs-lisp
(defun cbinfo:configure ()
  (setq line-spacing 2))

(add-hook 'Info-mode-hook 'cbinfo:configure)
#+end_src
* Compilation
** Configure variables
#+begin_src emacs-lisp
(setq compilation-window-height    12
      compilation-scroll-output    'first-error)
#+end_src
** Add global compilation bindings
#+begin_src emacs-lisp
(bind-key "C-c b" 'complie)
(bind-key "C-c C-b" 'recomplie)
#+end_src
** Find makefiles in projects
#+begin_src emacs-lisp
(autoload 'projectile-project-root "projectile")
(autoload 'projectile-project-p "projectile")

(hook-fn 'find-file-hook
  (when (projectile-project-p)
    (setq-local compilation-directory (projectile-project-root))))
#+end_src
** Colourise output
Interpret ANSI colour codes in compilation output buffers.
#+begin_src emacs-lisp
(defun cb:ansi-colourise-compilation ()
      (ansi-color-apply-on-region compilation-filter-start (point)))

(add-hook 'compilation-filter-hook 'cb:ansi-colourise-compilation)
#+end_src
** Automatically close compilation buffers on success
#+begin_src emacs-lisp
(defun cb:compile-autoclose (buf string)
  "Automatically close the compile window."
  (cond
   ;; Ignore if this isn't a normal compilation window.
   ((not (equal (buffer-name buf) "*compilation*")))

   ((not (s-contains? "finished" string))
    (message "Compilation exited abnormally: %s" string))

   ((s-contains? "warning" (with-current-buffer buf
                             (buffer-string)) 'ignore-case)
    (message "Compilation succeeded with warnings"))

   (t
    (ignore-errors
      (delete-window (get-buffer-window buf)))
    (message "Compilation succeeded"))))

(add-to-list 'compilation-finish-functions 'cb:compile-autoclose)
#+end_src
* eshell
Provides a shell implemented in emacs-lisp.
** Redirect attempts to edit files to =find-file=
#+begin_src emacs-lisp
(setenv "EDITOR" "emacsclient")
#+end_src
** Use case-insenitive file completion
#+begin_src emacs-lisp
(setq eshell-cmpl-ignore-case t)
#+end_src
** Cycle command
Create a key-binding for showing and hiding the terminal.
*** Impl
#+begin_src emacs-lisp
(defun cb:term-cycle (&optional arg)
  "Cycle through various terminal window states."
  (interactive)
  (cond

   ;; If terminal is maximized, restore previous window config.
   ((and (derived-mode-p 'eshell-mode)
         (equal 1 (length (window-list)))
         (equal (buffer-name) "*eshell*"))
    (or (ignore-errors (jump-to-register :term-fullscreen) t)
        (bury-buffer)))

   ;; If we're looking at the terminal, maximise it.
   ((derived-mode-p 'eshell-mode)
    (delete-other-windows))

   ;; Otherwise show the terminal.
   (t
    ;; Hide the term window if it's visible.
    (-when-let (win (--first (equal (buffer-name (window-buffer it))
                                    "*eshell*")
                             (window-list)))
      (delete-window win))
    ;; Save this configuration to a register so that it can be restored
    ;; for later positions in the cycle.
    (window-configuration-to-register :term-fullscreen)
    ;; Show terminal.
    (eshell arg))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(bind-key* "<f1>" 'cb:term-cycle)
#+end_src
** Clear command
Define a command to clear the eshell buffer.

#+begin_src emacs-lisp
(defun eshell/clear ()
  "Clear the eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (delete-region (point-min)
                   (save-excursion
                     (goto-char (point-max))
                     (search-backward-regexp eshell-prompt-regexp)
                     (let ((prompt-line (line-beginning-position)))
                       (forward-line -1)
                       (if (s-matches? (rx bol (+ space "[")) (current-line))
                           (line-beginning-position)
                         prompt-line))))))
#+end_src

Bind the above command. It must be set in a hook, because the map isn't created
until =eshell-mode= is called.

#+begin_src emacs-lisp
(hook-fn 'eshell-mode-hook
  (define-key eshell-mode-map (kbd "C-l") 'eshell/clear))
#+end_src

** Custom prompt

Define a custom eshell prompt with the following features:
- Displays the current working directory only when it changes
- Shows git status.

Define a face for prompt separators.

#+begin_src emacs-lisp
(defface eshell-prompt-sep
  '((t :inherit 'font-lock-comment-face))
  "Face for separators in the eshell prompt."
  :group 'cb-eshell)
#+end_src

Do not use the built-in highlight.

#+begin_src emacs-lisp
(setq eshell-highlight-prompt nil)
#+end_src

Tell eshell how to find the prompt.

#+begin_src emacs-lisp
(setq eshell-prompt-regexp (rx bol (* space) (or "#" ":") space))
 #+end_src

Define utilities to format the prompt.

#+begin_src emacs-lisp
(defun cb-eshell:current-dir ()
  (let* ((cwd (f-short (eshell/pwd)))
         (colour (if (s-starts-with? "/" cwd)
                     solarized-hl-orange
                   solarized-hl-cyan)))
    (propertize cwd 'face `(:foreground ,colour))))

(defun cb-eshell:git-status ()
  (require 'magit)
  (when (and (executable-find "git")
             (locate-dominating-file (eshell/pwd) ".git"))
    (concat
     (propertize " | " 'face 'eshell-prompt-sep)
     ;; Branch
     (propertize (%-string "git rev-parse --abbrev-ref HEAD")
                 'face `(:foreground ,solarized-hl-yellow))
     ;; @
     (propertize "@" 'face 'eshell-prompt-sep)
     ;; Rev
     (substring (%-string "git rev-parse HEAD") 0 7)
     ;; State

     (let ((s (concat (when (magit-anything-unstaged-p)
                        (propertize "M" 'face `(:foreground ,solarized-hl-orange)))
                      (when (magit-anything-staged-p)
                        (propertize "+" 'face `(:foreground ,solarized-hl-green))))))
       (unless (s-blank? s)
         (concat " " s))))))

(defun cb-eshell:prompt-symbol ()
  (let ((ch (if (= (user-uid) 0) "#" ":"))
        (colour (if (zerop eshell-last-command-status)
                    solarized-hl-cyan
                  solarized-hl-red)))
    (propertize ch 'face (list :foreground colour))))

(defvar cb-eshell:last-header nil)

(defun cb-eshell:format-header ()
  (concat
   (when cb-eshell:last-header "\n")
   (propertize " [ " 'face 'eshell-prompt-sep)
   (cb-eshell:current-dir)
   (cb-eshell:git-status)
   (propertize " ]" 'face 'eshell-prompt-sep)
   "\n"))

(defun cb-eshell:format-prompt ()
  "Format the prompt to display in eshell."
  (let* ((h (cb-eshell:format-header))
         (changed? (not (equal h cb-eshell:last-header)))
         (p (concat (when changed? h) " " (cb-eshell:prompt-symbol) " ")))
    (setq cb-eshell:last-header h)
    (propertize p 'read-only t 'front-sticky 'read-only 'rear-nonsticky 'read-only)))
#+end_src

Use the above prompt functions.

#+begin_src emacs-lisp
(setq eshell-prompt-function 'cb-eshell:format-prompt)
#+end_src

** Smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (add-hook 'eshell-mode-hook 'smartparens-mode))
#+end_src

* lambda-mode
Overlay greek lambda symbol in languages with lambda functions..
#+begin_src emacs-lisp
(require 'lambda-mode)
(setq lambda-symbol (string (make-char 'greek-iso8859-7 107)))
#+end_src
** Apply lambda-mode to the hooks
#+begin_src emacs-lisp
(add-hook 'cb:scheme-modes-hook    'lambda-mode)
(add-hook 'inferior-lisp-mode-hook 'lambda-mode)
(add-hook 'lisp-mode-hook          'lambda-mode)
(add-hook 'cb:elisp-modes-hook     'lambda-mode)
(add-hook 'cb:python-modes-hook    'lambda-mode)
(add-hook 'cb:slime-modes-hook     'lambda-mode)
#+end_src
** Diminish
#+begin_src emacs-lisp
(hook-fn 'lambda-mode-hook
  (diminish 'lambda-mode))
#+end_src
* csv-mode
#+begin_src emacs-lisp
(cb:install-package 'csv-mode)
(add-to-list 'auto-mode-alist '("\\.[Cc][Ss][Vv]\\'" . csv-mode))
#+end_src
** Customise separator face
#+begin_src emacs-lisp
(after 'csv-mode
  (set-face-foreground csv-separator-face solarized-hl-orange))
#+end_src
** Override broken variable
#+begin_src emacs-lisp
(defconst csv-mode-line-help-echo "")
#+end_src
* Supercollider
** sclang
Basic configuration. Man, I wish this package was less crappy.
#+begin_src emacs-lisp
(autoload 'sclang-mode "sclang")
(autoload 'sclang-start "sclang")
(add-to-list 'auto-mode-alist '("\\.sc$" . sclang-mode))
#+end_src
*** Define a convenience command for launching supercollider.
#+begin_src emacs-lisp
(defun supercollider ()
  "Start SuperCollider and open the SC Workspace."
  (interactive)
  (switch-to-buffer
   (get-buffer-create "*sclang workspace*"))
  (sclang-mode))
#+end_src
*** Customise variables.
#+begin_src emacs-lisp
(setq sclang-auto-scroll-post-buffer   t
      sclang-eval-line-forward         nil
      sclang-show-workspace-on-startup nil)
#+end_src
** sclang-extensions
Extensions that makes sclang-mode a bit more conventional.
#+begin_src emacs-lisp
(cb:install-package 'sclang-extensions)
(add-hook 'sclang-mode-hook 'sclang-extensions-mode)
#+end_src
** Smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (hook-fn 'sclang-mode-hook
    (smartparens-mode +1)))
#+end_src
** Smart operators
#+begin_src emacs-lisp
(after 'smart-operator
  (hook-fn 'sclang-mode-hook
    (smart-insert-operator-hook)
    (local-unset-key (kbd "|"))
    (local-unset-key (kbd "."))))
#+end_src
* Makefiles
** DEFER
#+begin_src emacs-lisp
(after 'make-mode
#+end_src
** Undefine comment-region binding
#+begin_src emacs-lisp
(define-key makefile-mode-map (kbd "C-c C-c") nil)
#+end_src
** auto-complete
#+begin_src emacs-lisp
(after 'auto-complete
  (add-to-list 'ac-modes 'makefile-mode)
  (add-hook 'makefile-mode-hook 'auto-complete-mode))
#+end_src
** Ensure tabs are used in makefiles.
#+begin_src emacs-lisp
(defun convert-leading-spaces-to-tabs ()
  "Convert sequences of spaces at the beginning of a line to tabs."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward-regexp (rx bol (group (>= 4 space))) nil t)
      (replace-match "\t"))))

(hook-fn 'makefile-mode-hook
  (setq indent-tabs-mode t)
  (add-hook 'before-save-hook 'convert-leading-spaces-to-tabs nil t))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* undo-tree
Provides a graphical view of the undo history.
#+begin_src emacs-lisp
(cb:install-package 'undo-tree t)
(global-undo-tree-mode +1)
#+end_src
** Set global key binding
#+begin_src emacs-lisp
(bind-key "C-x u" 'undo-tree-visualize)
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'undo-tree-mode)
#+end_src
* iedit
Provides commands for transforming and replacing occurrences of a symbol in the
buffer.
#+begin_src emacs-lisp
(cb:install-package 'iedit)
#+end_src
** Define a global key binding
#+begin_src emacs-lisp
(bind-key "C-<return>" 'iedit-mode)
#+end_src
** Quick rename commands
Define utilities for renaming the symbol at point.
*** Impl
#+begin_src emacs-lisp
(defun rename-symbol-in-defun ()
  (interactive)
  (iedit-mode 0)
  (unwind-protect
      (iedit-replace-occurrences (read-string "Replace in function: "))
    (iedit-done)))

(defun rename-symbol-in-buffer ()
  (interactive)
  (iedit-mode)
  (unwind-protect
      (iedit-replace-occurrences (read-string "Replace in buffer: "))
    (iedit-done)))
#+end_src
*** Key bindings
#+begin_src emacs-lisp
(bind-key "M-r" 'rename-symbol-in-defun)
(bind-key "M-R" 'rename-symbol-in-buffer)
#+end_src
** iedit command picker
*** Utilities
#+begin_src emacs-lisp
(defun cbiedit:replace-read ()
  (iedit-replace-occurrences (read-string "Replace in buffer: ")))

(defun cbiedit:restrict-to-region ()
  (iedit-restrict-region (region-beginning) (region-end)))

(defun cbiedit:remove-region ()
  (iedit-restrict-region (region-beginning) (region-end) t))

(defun cbiedit:replace-in-region ()
  (cbiedit:restrict-to-region)
  (cbiedit:replace-read))
#+end_src
*** Impl
#+begin_src emacs-lisp
(define-command-picker iedit-picker
  :title "*iedit*"
  :options
  '(("e" "Expand"
     iedit-expand-by-a-line
     :unless region-active-p)

    ("p" "Expand (up)"
     iedit-expand-up-a-line
     :unless region-active-p)

    ("n" "Expand (down)"
     iedit-expand-down-a-line
     :unless region-active-p)

    ("r" "Replace (in region)"
     cbiedit:replace-in-region
     :when region-active-p)

    ("r" "Replace"
     cbiedit:replace-read
     :unless region-active-p)

    ("k" "Delete Matches"
     iedit-delete-occurrences
     :unless region-active-p)

    ("l" "Restrict (line)"
     iedit-restrict-current-line
     :unless region-active-p)

    ("R" "Restrict (region)"
     cbiedit:restrict-to-region
     :when region-active-p)

    ("x" "Remove (region)"
     cbiedit:remove-region
     :when region-active-p)
    ("f" "Restrict (function)"
     iedit-restrict-function
     :when (lambda () (thing-at-point 'defun)))

    ("c" "Toggle Case-Sensitivity" iedit-toggle-case-sensitive)
    ("t" "Toggle at Point" iedit-toggle-selection)
    ("d" "Done" iedit-done)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(after 'iedit
  (bind-key "C-<return>" 'iedit-picker iedit-mode-keymap))
#+end_src
* smooth-scrolling
Changes the default scrolling behaviour to keep point away from the top or
bottom of the window in order to show scrolling context.
#+begin_src emacs-lisp
(cb:install-package 'smooth-scrolling t)
#+end_src
* midnight
Runs a hook at midnight. By default it will clean unused buffers.
#+begin_src emacs-lisp
(cb:install-package 'midnight t)
#+end_src
* ack
Provide an Emacs interface to ack.
#+begin_src emacs-lisp
(cb:install-package 'ack-and-a-half)
#+end_src
* hideshow
Provides code folding. Used by evil-mode.
** Diminish hideshow
#+begin_src emacs-lisp
(hook-fn 'hs-minor-mode-hook
  (diminish 'hs-minor-mode))
#+end_src
* abbrev
Declare abbreviations that will be automatically expanded when typed. I don't
actually use this, but python mode seems to load it.
** Create abbrev file in tmp.
#+begin_src emacs-lisp
(setq abbrev-file-name (f-join cb:tmp-dir "abbrev_defs"))
#+end_src
* dictionary
Provides dictionary search functions.
#+begin_src emacs-lisp
(cb:install-package 'dictionary t )
#+end_src
* auto-revert
Minor mode that reverts the buffer if it changes on disk.
** Diminish auto-revert
#+begin_src emacs-lisp
(hook-fn 'auto-revert-mode-hook
  (diminish 'auto-revert-mode))
#+end_src
* file-template
Provides file skeletons.
#+begin_src emacs-lisp
(unless noninteractive (require 'file-template))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'file-template
#+end_src
** Insert file templates automatically when creating new files
#+begin_src emacs-lisp
(add-hook 'find-file-not-found-hooks
          'file-template-find-file-not-found-hook 'append)

(setq file-template-insert-automatically t)
#+end_src
** Add personal file templates directory
#+begin_src emacs-lisp
(defvar cb:file-templates-dir (f-join user-emacs-directory "templates"))
(setq file-template-paths (list cb:file-templates-dir))
#+end_src
** Load file templates programatically from personal templates directory
#+begin_src emacs-lisp
(setq file-template-mapping-alist
      (->> (f-files cb:file-templates-dir)
        (-map 'f-filename)
        (--map (cons (format "\\.%s$" (f-ext it)) it))))
#+end_src
** After inserting file templates, reset the undo history
#+begin_src emacs-lisp
(hook-fn 'file-template-insert-hook
      (setq buffer-undo-list nil
            buffer-undo-tree nil))
#+end_src
** define helper function for org template
#+begin_src emacs-lisp
(defun cbtmpl:org-skeleton-title (filename)
  "Format the title to use for the given FILENAME."
  (->> (f-filename (f-no-ext filename))
    s-split-words
    (-map 's-capitalize)
    (s-join " ")))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* expand-region
Provides commands for expanding and contracting the active region.
#+begin_src emacs-lisp
(cb:install-package 'expand-region)
#+end_src
** Set global bindings for expanding and contracting regions
#+begin_src emacs-lisp
(global-set-key (kbd "M-<up>") 'er/expand-region)
(global-set-key (kbd "M-<down>") 'er/contract-region)
#+end_src
* artist
Provides ascii-art drawing functions.
** If evil-mode is active, use emacs state for artist mode
#+begin_src emacs-lisp
(after 'evil-mode
  (add-hook 'artist-mode-hook 'evil-emacs-state))
#+end_src
* ace-jump-mode
Provides commands for quickly moving around the visible part of the buffer.
#+begin_src emacs-lisp
(cb:install-package 'ace-jump-mode)
#+end_src
** Bind a global hotkey
#+begin_src emacs-lisp
(bind-key "S-<return>" 'ace-jump-word-mode)
#+end_src
** Use ESC to quit ace-jump
#+begin_src emacs-lisp
(hook-fns '(ace-jump-line-mode ace-jump-word-mode ace-jump-char-mode)
  (local-set-key (kbd "ESC") 'keyboard-quit))
#+end_src
** Exit recursive edits when jumping
#+begin_src emacs-lisp
(hook-fn 'ace-jump-mode-end-hook
  (ignore-errors (exit-recursive-edit)))
#+end_src
* multiple-cursors
Lets you perform editing commands on different lines simultaneously.
#+begin_src emacs-lisp
(cb:install-package 'multiple-cursors)
#+end_src
** Define the location of the list file
This defines the commands that interact with multiple-cursors.
#+begin_src emacs-lisp
(setq mc/list-file (f-join cb:tmp-dir "multiple-cursors-list.el"))
#+end_src
** Define global key bindings
#+begin_src emacs-lisp
(bind-keys
  :overriding? t
  "C-c m m" 'mc/edit-lines
  "C-c m a" 'mc/mark-all-dwim
  "C-c m n" 'mc/mark-next-like-this
  "C-c m p" 'mc/mark-previous-like-this)
#+end_src
* BBDB
Provides an address book for emacs and integrates with many modes.
#+begin_src emacs-lisp
(cb:install-package 'bbdb)
#+end_src
** Set the location of the user BBDB file
#+begin_src emacs-lisp
(setq bbdb-file (concat user-dropbox-directory ".bbdb"))
#+end_src
** Customise popup appearance
#+begin_src emacs-lisp
(setq bbdb-use-popup t
      bbdb-pop-up-window-size 0.5
      bbdb-mua-popup-window-size 4
      bddb-popup-target-lines 1)
#+end_src
** Offer to add message senders to BBDB
#+begin_src emacs-lisp
(setq bbdb-offer-save 1
      bbdb-always-add-address t)
#+end_src
** Do not add automated messages to contacts
#+begin_src emacs-lisp
(setq bbdb/mail-auto-create-p 'bbdb-ignore-some-messages-hook)
(setq bbdb-ignore-some-messages-alist
      '(( "From" . "no.?reply\\|DAEMON\\|daemon\\|facebookmail\\|twitter")))
#+end_src
** Configure display style
#+begin_src emacs-lisp
(setq bbdb-complete-name-allow-cycling t
      bbdb-use-alternate-names t
      bbdb-elided-display t)
#+end_src
** Configure completion behaviour
#+begin_src emacs-lisp
(setq bbdb-electric t
      bbdb-completion-type nil)
#+end_src
** Customise Miscellaneous variables
#+begin_src emacs-lisp
(setq bbdb-dwim-net-address-allow-redundancy t
      bbdb-quiet-about-name-mismatches 2
      bbdb-canonicalize-redundant-nets-p t
      bbbd-message-caching-enabled t)
#+end_src
** Configure BBDB support in other modes
#+begin_src emacs-lisp
(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
(add-hook 'message-mode-hook 'bbdb-insinuate-mail)
#+end_src
** Evil
Add evil key bindings to BBDB.
#+begin_src emacs-lisp
(after '(bbdb evil)
  (define-key bbdb-mode-map (kbd "j") 'bbdb-next-record)
  (define-key bbdb-mode-map (kbd "k") 'bbdb-prev-record)
  (define-key bbdb-mode-map (kbd "l") 'bbdb-next-field)
  (define-key bbdb-mode-map (kbd "h") 'bbdb-prev-field))
#+end_src
* w3m
Configure w3m bindings for Emacs. w3m is a command-line web browser.
#+begin_src emacs-lisp
(when (executable-find "w3m")
  (cb:install-package 'w3m))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'w3m
#+end_src
** Increase default line spacing
#+begin_src emacs-lisp
(hook-fn 'w3m-mode-hook (setq line-spacing 5))
#+end_src
** Executor
Declare a modal command to show w3m.
#+begin_src emacs-lisp
(declare-modal-executor w3m
  :command w3m
  :bind "M-W"
  :restore-bindings '("M-W" "M-E"))
#+end_src
** Evil
*** Define evil-style movement keys for w3m
#+begin_src emacs-lisp
(after 'evil
  (bind-keys
    :map w3m-mode-map
    "z t" 'evil-scroll-line-to-top
    "z b" 'evil-scroll-line-to-bottom
    "z z" 'evil-scroll-line-to-center
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up
    "y"   'evil-yank
    "p"   'evil-paste-after
    "/"   'evil-search-forward
    "?"   'evil-search-backward
    "n"   'evil-search-next
    "N"   'evil-search-previous))
#+end_src
*** Define a command to open the URL at point with w3m.
#+begin_src emacs-lisp
(autoload 'thing-at-point-url-at-point "thingatpt")

(defun w3m-browse-dwim (url)
  "Browse to URL, ensuring it begins with http:// as required by w3m."
  (interactive
   (list
    (read-string "Go to URL: "
                 (thing-at-point-url-at-point)
                 t)))
  (with-window-restore
    (w3m-browse-url
     (if (s-starts-with? "http://" url)
         url
       (concat "http://" url)))
    (local-set-key (kbd "q") (command (restore)))))

(after 'evil
  (bind-key* "M-e" 'cb:w3m-browse-dwim))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* message
Provides emailing and messaging functions.
#+begin_src emacs-lisp
(setq message-kill-buffer-on-exit t)
#+end_src
** Background message sending
Send messages in the background instead of blocking Emacs.
*** Define a hook to be run after sending messages in the background
#+begin_src emacs-lisp
(defvar async-smtpmail-sent-hook nil)
#+end_src
*** Use the =async= library to send messages in a background process.
#+begin_src emacs-lisp
(defun async-smtpmail-send-it (&rest _)
  "Send mail asynchronously using another Emacs process."
  (let ((to (message-field-value "To")))
    (message "Delivering message to %s..." to)
    (async-start
     `(lambda ()
        (require 'smtpmail)
        (with-temp-buffer
          (insert ,(buffer-string))
          ;; Pass in the variable environment for smtpmail.
          ,(async-inject-variables (rx (or "user" "mail")))
          (smtpmail-send-it)))
     `(lambda (&optional ignore)
        (message "Delivering message to %s...done" ,to)
        (run-hooks 'async-smtpmail-sent-hook)))))

(setq message-send-mail-function 'async-smtpmail-send-it
      send-mail-function 'async-smtpmail-send-it)
#+end_src
*** Play the sent mail sound on OS X
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
  (hook-fn 'async-smtpmail-sent-hook
    (let ((snd "/Applications/Mail.app/Contents/Resources/Mail Sent.aiff"))
      (when (file-exists-p snd)
        (start-process "Mail sent" " mail sent" "afplay" snd)))))
#+end_src
** Add attachments with ido
*** Impl
#+begin_src emacs-lisp
(defun mail-add-attachment-ido (file)
  (interactive (list (ido-read-file-name "Attach file: " )))
  (mail-add-attachment file))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(after 'message
  (define-key message-mode-map (kbd "C-c C-a") 'mail-add-attachment-ido))
#+end_src
* notmuch
Provides mail indexing and search.
#+begin_src emacs-lisp
(when (executable-find "notmuch")
  (cb:install-package 'notmuch))
#+end_src
** Evil
Define evil-style navigation keys for notmuch.
#+begin_src emacs-lisp
(after '(notmuch evil)
  (define-keys notmuch-search-mode-map
    "j" 'next-line
    "k" 'previous-line
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up)

  (define-keys notmuch-show-mode-map
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up)
  (evil-add-hjkl-bindings notmuch-show-mode-map))
#+end_src
* Winner-mode
Provides an undo history for window changes.
#+begin_src emacs-lisp
(winner-mode +1)
#+end_src
* transpose-frame
Provides commands to rotate buffers within frames.
** Define autoloads
#+begin_src emacs-lisp
(autoload 'transpose-frame "transpose-frame")
(autoload 'flip-frame "transpose-frame")
(autoload 'flop-frame "transpose-frame")
(autoload 'rotate-frame "transpose-frame")
(autoload 'rotate-frame-clockwise "transpose-frame")
(autoload 'rotate-frame-anticlockwise "transpose-frame")
#+end_src
** Add global key bindings
#+begin_src emacs-lisp
(bind-key "C-x t" 'transpose-frame)
(bind-key "s-t"   'transpose-frame)
(bind-key "C-x f" 'rotate-frame)
(bind-key "s-r"   'rotate-frame)
#+end_src
* Org
org-mode is a suite of editing and management tools centred around
human-readable text files. See http://orgmode.org/.
** Set file paths
*** Create a var to hold the original value of the notes file
=org-default-notes-file= may be changed interactively by
=cb-org:set-notes-file=, so we need a reference to the original for some
functions.
#+begin_src emacs-lisp
(defvar org-init-notes-file org-default-notes-file
  "Captures the original value of the `org-default-notes-file'.")
#+end_src
*** Clock persist file
The clock persist file is used to save clocking data between sessions. It allows
org to restart interrupted clocks.
#+begin_src emacs-lisp
(setq org-clock-persist-file  (f-join org-directory ".org-clock-save"))
#+end_src
*** Miscellaneous file paths.
#+begin_src emacs-lisp
(setq org-id-locations-file   (f-join cb:tmp-dir "org-id-locations")
      org-agenda-diary-file   (f-join org-directory "diary.org")
      calendar-date-style     'european)
#+end_src
** Customise miscellaneous vars
#+begin_src emacs-lisp
(setq org-completion-use-ido t
      org-link-mailto-program (quote (compose-mail "%a" "%s"))
      org-insert-heading-respect-content nil
      org-M-RET-may-split-line nil
      org-blank-before-new-entry nil
      org-catch-invisible-edits 'smart
      org-return-follows-link t)
#+end_src
** Automatically renumber footnotes
#+begin_src emacs-lisp
(setq org-footnote-auto-adjust t)
#+end_src
** Auto-revert org files
Since they are under VC with git-auto-push, this should keep them in sync if
they are changed on different computers.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-revert-mode)
#+end_src
** Use auto-fill
This will automatically insert line breaks to keep lines shorter
than =fill-column=.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
** Diminish org minor modes
#+begin_src emacs-lisp
(hook-fn 'cb:org-minor-modes-hook
  (--each cb:org-minor-modes
    (ignore-errors (diminish it))))
#+end_src
** Drawers
#+begin_src emacs-lisp
(setq org-drawers '("COMMENTS" "NOTES" "PROPERTIES"
                    "CLOCK" "LOGBOOK" "RESULTS"))
#+end_src
** Display style
#+begin_src emacs-lisp
(setq org-put-time-stamp-overlays t
      org-indirect-buffer-display 'current-window
      org-startup-indented t
      org-startup-with-inline-images t
      org-cycle-separator-lines 0)
#+end_src
** Render latex-style character sequences as unicode chars
#+begin_src emacs-lisp
(setq org-pretty-entities t)
#+end_src
** Logging
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-log-done 'time
      org-reverse-note-order nil)
#+end_src
** Modal views
Add executors for common org views.
#+begin_src emacs-lisp
(declare-modal-executor org-agenda-fullscreen
  :command (org-agenda current-prefix-arg "A"))

(declare-modal-executor org-show-todo-list
  :command (progn
             (org-agenda prefix-arg "t")
             (org-agenda-filter-apply '("-someday") 'tag)))

(declare-modal-executor org-tags-view-todos-fullscreen
  :command (org-tags-view t))

(declare-modal-executor org-tags-view-all-fullscreen
  :command (org-tags-view nil))

(declare-modal-executor org-search-view
  :command (call-interactively 'org-search-view))
#+end_src
** Org command picker
*** Utilities
#+begin_src emacs-lisp
(defun cb-org:yank-region-as-quote (beg end)
  "Yank the current region as an org quote."
  (interactive "r")
  (if (region-active-p)
      (progn
        (kill-new (cb-org:buffer-substring-to-quote beg end))
        (deactivate-mark)
        (message "Region yanked as quote."))
    (error "No region is active, so no quote could be yanked")))

(defun cb-org:set-notes-file (file)
  "Select the notes file to use as the default.
This will set which file org-capture will capture to."
  (interactive
   (list
    (let* ((fs (org-files-list))
           (selected
            (ido-completing-read
             "File: "
             (->> fs
               (-remove (C (~ equal "org_archive") f-ext))
               (-map 'f-filename)))))
      (-first (C (~ equal selected) f-filename) fs))))
  (setq org-default-notes-file file))

(defun cb-org:find-diary ()
  (interactive)
  (find-file org-agenda-diary-file))

(defun cb-org:find-notes ()
  (interactive)
  (find-file org-default-notes-file))

(defun cb-org:capture ()
  "Adapt `org-capture' to my own selection widget."
  (interactive)
  (let ((k (car (read-option "*Org Capture*" 'car 'cadr
                             org-capture-templates))))
    (org-capture nil k)))
#+end_src
*** Impl
#+begin_src emacs-lisp
(define-command-picker org-action-picker
  :title "*Org Commands*"
  :options
  `(("a" "Agenda" org-agenda)
    ("b" "Buffers" org-iswitchb)
    ("c" "Follow Clock" org-clock-goto)
    ("d" "Go to Diary" cb-org:find-diary)
    ("f" "Set Notes File" cb-org:set-notes-file)
    ("g" "Go to Subtree" ,(command (org-refile 'goto)))
    ("k" "Capture" cb-org:capture)
    ("l" "Store Link" org-store-link)
    ("n" "Go to Notes" cb-org:find-notes)
    ("s" "Search" executor:org-search-view)
    ("t" "Todo List" executor:org-show-todo-list)
    ("v" "View Tags (todos)" executor:org-tags-view-todos-fullscreen)
    ("V" "View Tags (all)" executor:org-tags-view-all-fullscreen)
    ("y" "Yank Region as Quote" cb-org:yank-region-as-quote :when region-active-p)))
#+end_src

** Key bindings
Define global key bindings for org commands.
#+begin_src emacs-lisp
(bind-keys
  :overriding? t
  "C-c a" 'org-agenda
  "C-c l" 'org-store-link
  "<f6>" (command (org-capture nil "t"))
  "<f7>" 'cb-org:capture
  "<f8>" 'org-action-picker
  "<f9>" 'executor:org-agenda-fullscreen)
#+end_src

Define keys for org-mode.
#+begin_src emacs-lisp
(define-keys org-mode-map
  "C-c C-." 'org-time-stamp-inactive
  "C-c o" 'org-attach-open
  "M-p" 'org-metaup
  "M-n" 'org-metadown
  "C-c c" 'org-columns
  "C-c C-j" (command (org-refile 'goto))
  ;; disable annoying comment toggle key
  "C-c ;" nil)
#+end_src
** Notes
*** Enter insert state for popup notes
#+begin_src emacs-lisp
(after 'evil
  (hook-fn 'org-mode-hook
    (when (and (equal (buffer-name) "*Org Note*"))
      (evil-insert-state))))
#+end_src
*** Prevent attempts to expand the minibuffer
#+begin_src emacs-lisp
(defadvice org-add-log-note (before exit-minibuffer activate)
  (when (minibufferp (window-buffer (selected-window)))
    (other-window 1)))
#+end_src
** Statistics
Perhaps confusingly, setting hierarchy vars to non-nil values makes statistics
functions shallow.
#+begin_src emacs-lisp
(setq org-hierarchical-todo-statistics nil
      org-checkbox-hierarchical-statistics t)
#+end_src
** Tags
#+begin_src emacs-lisp
(setq org-tag-persistent-alist
      '(("finance" . ?f)
        ("hold" . ?H)
        ;; Financial tags
        (:startgroup . nil)
        ("debt" . ?d)
        ("reimbursement" . ?r)
        (:endgroup . nil)
        ;; Context tags
        (:startgroup . nil)
        ("@computer" . ?c)
        ("@errand" . ?e)
        ("@home" . ?h)
        ("@leisure" . ?l)
        ("@phone" . ?p)
        ("@work" . ?w)
        (:endgroup . nil)))
#+end_src
** Clocking
#+begin_src emacs-lisp
(require 'org-clock)
#+end_src
*** Persist the clock across Emacs sessions
#+begin_src emacs-lisp
(setq org-clock-persist t)
(org-clock-persistence-insinuate)
#+end_src
*** Clock out of tasks automatically when they are marked as DONE
#+begin_src emacs-lisp
(setq org-clock-out-when-done t)
#+end_src
*** Automatically resume interrupted clocks when starting Emacs
#+begin_src emacs-lisp
(setq org-clock-persist-query-resume nil)
#+end_src
*** Add clocking info to a special drawer
#+begin_src emacs-lisp
(setq org-clock-into-drawer t)
#+end_src
*** Increase clock history length
#+begin_src emacs-lisp
(setq org-clock-history-length 20)
#+end_src
*** Customise clock resolution
#+begin_src emacs-lisp
(setq org-clock-in-resume t
      org-clock-auto-clock-resolution 'when-no-clock-is-running)
#+end_src
*** Include the running clock when generating clocking reports
#+begin_src emacs-lisp
(setq org-clock-report-include-clocking-task t)
#+end_src
*** Utilities used by clocking customisations
#+begin_src emacs-lisp
(defun cb-org:project? ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun cb-org:task? ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
#+end_src
*** Clocking into a TODO changes state to NEXT
#+begin_src emacs-lisp
(defun cb-org:clock-in-to-next-state (_kw)
  "Move a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO."
  (unless (true? org-capture-mode)
    (cond
     ((and (-contains? '("TODO") (org-get-todo-state))
           (cb-org:task?))
      "NEXT")
     ((and (-contains? '("NEXT") (org-get-todo-state))
           (cb-org:project?))
      "TODO"))))

(setq org-clock-in-switch-to-state 'cb-org:clock-in-to-next-state)
#+end_src

*** Automatically change clocked projects from NEXT to TODO
#+begin_src emacs-lisp
(defun cb-org:mark-next-parent-tasks-todo ()
  "Visit each parent task and change state to TODO"
  (let ((mystate (or (and (fboundp 'org-state)
                          state)
                     (nth 2 (org-heading-components)))))
    (when mystate
      (save-excursion
        (while (org-up-heading-safe)
          (when (-contains? '("NEXT" "WAITING" "MAYBE")
                            (nth 2 (org-heading-components)))
            (org-todo "TODO")))))))

(hook-fns '(org-after-todo-state-change-hook org-clock-in-hook)
  :append t
  (cb-org:mark-next-parent-tasks-todo))
#+end_src
*** Remove empty clock entries
#+begin_src emacs-lisp
(setq org-clock-out-remove-zero-time-clocks t)
#+end_src
*** Remove empty LOGBOOK drawers when clocking out
#+begin_src emacs-lisp
(hook-fn 'org-clock-out-hook
  :append t
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at "LOGBOOK" (point))))
#+end_src

** Effort estimates
#+begin_src emacs-lisp
(add-to-list 'org-global-properties
             `("Effort_ALL" . ,(concat "1:00 2:00 3:00 4:00 "
                                       "5:00 6:00 7:00 8:00 9:00 "
                                       "0:05 0:10 0:30")))
#+end_src
** Projects
#+begin_src emacs-lisp
(setq org-stuck-projects
      '("+project&TODO={.+}/-DONE-CANCELLED"
        ("NEXT" "TODO") nil "\\<IGNORE\\>"))
#+end_src
** Refiling
#+begin_src emacs-lisp
(setq org-refile-use-outline-path t
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm
      org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))
#+end_src
*** Exclude todo keywords with a DONE state from refile targets.
#+begin_src emacs-lisp
(setq org-refile-target-verify-function
      (lambda ()
        (not (member (nth 2 (org-heading-components))
                     org-done-keywords))))
#+end_src
** Attachments
#+begin_src emacs-lisp
(require 'org-attach)
(setq org-link-abbrev-alist '(("att" . org-attach-expand-link))
      org-attach-directory (f-join org-directory "data"))
#+end_src
*** Redefine `org-attach-attach' to use helm to read files
#+begin_src emacs-lisp
(defun org-attach-attach (file &optional visit-dir method)
  "Move/copy/link FILE into the attachment directory of the current task.
If VISIT-DIR is non-nil, visit the directory with dired.
METHOD may be `cp', `mv', `ln', or `lns' default taken from
`org-attach-method'."
  (interactive
   (list
    (helm-read-file-name "File to keep as an attachment: ")
    current-prefix-arg))
  (setq method (or method org-attach-method))
  (let ((basename (file-name-nondirectory file)))
    (when (and org-attach-file-list-property (not org-attach-inherited))
      (org-entry-add-to-multivalued-property
       (point) org-attach-file-list-property basename))
    (let* ((attach-dir (org-attach-dir t))
           (fname (expand-file-name basename attach-dir)))
      (cond
       ((eq method 'mv) (rename-file file fname))
       ((eq method 'cp) (copy-file file fname))
       ((eq method 'ln) (add-name-to-file file fname))
       ((eq method 'lns) (make-symbolic-link file fname)))
      (org-attach-commit)
      (org-attach-tag)
      (cond ((eq org-attach-store-link-p 'attached)
             (org-attach-store-link fname))
            ((eq org-attach-store-link-p t)
             (org-attach-store-link file)))
      (if visit-dir
          (dired attach-dir)
        (message "File \"%s\" is now a task attachment." basename)))))
#+end_src
** Archiving
#+begin_src emacs-lisp
(require 'org-archive)
#+end_src
*** Apply inherited tags to archived items
#+begin_src emacs-lisp
(defadvice org-archive-subtree
  (before add-inherited-tags-before-org-archive-subtree activate)
  "Add inherited tags before org-archive-subtree."
  (org-set-tags-to (org-get-tags-at)))
#+end_src
*** Archive only DONE tasks by default
#+begin_src emacs-lisp
(defun cb-org:archive-done-tasks ()
  (interactive)
  (atomic-change-group
    (org-map-entries (lambda ()
                       ;; Ensure point does not move past the next item to
                       ;; archive.
                       (setq org-map-continue-from (point))
                       (org-archive-subtree))
                     "/DONE|PAID|VOID|CANCELLED" 'tree)))

(setq org-archive-default-command 'cb-org:archive-done-tasks)
#+end_src
** Encryption
#+begin_src emacs-lisp
(require 'org-crypt)
#+end_src
*** Enable auto-encryption
#+begin_src emacs-lisp
(org-crypt-use-before-save-magic)
(setq org-crypt-disable-auto-save 'encypt)
#+end_src
*** Do not inherit encryption property
Prevents nested encrypting.
#+begin_src emacs-lisp
(add-to-list 'org-tags-exclude-from-inheritance "crypt")
#+end_src
*** Extend org C-c C-c command to decrypt entry at point
#+begin_src emacs-lisp
(defun cb-org:looking-at-pgp-section? ()
  (unless (org-before-first-heading-p)
    (save-excursion
      (org-back-to-heading t)
      (let ((heading-point (point))
            (heading-was-invisible-p
             (save-excursion
               (outline-end-of-heading)
               (outline-invisible-p))))
        (forward-line)
        (looking-at "-----BEGIN PGP MESSAGE-----")))))

(defun cb-org:decrypt-entry ()
  (when (cb-org:looking-at-pgp-section?)
    (org-decrypt-entry)
    t))

(add-hook 'org-ctrl-c-ctrl-c-hook 'cb-org:decrypt-entry)
#+end_src
** MIME
Provides MIME exporting functions, allowing you to export org buffers to HTML
emails.
#+begin_src emacs-lisp
(require 'org-mime)
#+end_src
*** Define key bindings for HTML convertsion commands.
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c M-o") 'org-mime-org-buffer-htmlize)

(after 'message
  (define-key message-mode-map  (kbd "C-c M-o") 'org-mime-htmlize))
#+end_src
*** Offset block quotes and source code.
#+begin_src emacs-lisp
(hook-fn 'org-mime-html-hook
  (org-mime-change-element-style
   "blockquote" "border-left: 2px solid #B0B0B0; padding-left: 4px;")
  (org-mime-change-element-style
   "pre" "border-left: 2px solid #B0B0B0; padding-left: 4px;"))
#+end_src
** Export
#+begin_src emacs-lisp
(setq org-export-exclude-tags '("noexport" "crypt"))
#+end_src
*** HTML
**** Use HTML5 tags.
#+begin_src emacs-lisp
(setq org-html-html5-fancy t)
#+end_src
**** Do not export a postamble
The postamble usually displays the creator, org version, etc.
#+begin_src emacs-lisp
(setq org-html-postamble nil)
#+end_src
*** texinfo
#+begin_src emacs-lisp
(require 'ox-texinfo)
(add-to-list 'org-export-snippet-translation-alist
             '("info" . "texinfo"))
#+end_src
*** ox-koma-letter
#+begin_src emacs-lisp
(require 'ox-koma-letter)
(add-to-list 'org-latex-classes '("koma-letter" "
\\documentclass[paper=A4,pagesize,fromalign=right,
               fromrule=aftername,fromphone,fromemail,
               version=last]{scrlttr2}
\\usepackage[english]{babel}
\\usepackage[utf8]{inputenc}
\\usepackage[normalem]{ulem}
\\usepackage{booktabs}
\\usepackage{graphicx}
[NO-DEFAULT-PACKAGES]
[EXTRA]
[PACKAGES]"))
#+end_src
** Habits
#+begin_src emacs-lisp
(require 'org-habit)
(setq org-habit-preceding-days 14
      org-habit-following-days 4
      org-habit-graph-column 70)
#+end_src
** Tree killing
Define a command for killing the subtree at point. If we're in a special org
buffer, this should fall back to the cancel action.
*** Impl
#+begin_src emacs-lisp
(defun cb-org:ctrl-c-ctrl-k (&optional n)
  "Kill subtrees, unless we're in a special buffer where it should cancel."
  (interactive "p")
  (if (s-starts-with? "*Org" (buffer-name))
      (org-kill-note-or-show-branches)
    (org-cut-subtree n)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c C-k") 'cb-org:ctrl-c-ctrl-k)
#+end_src
** Special C-c C-RET command
Define a custom command to insert todo headings, etc. This is mainly needed
because the default keybinding conflicts with my window manager on OS X.
*** Impl
#+begin_src emacs-lisp
(defun cb-org:ctrl-c-ret ()
  "Call `org-table-hline-and-move' or `org-insert-todo-heading' dep. on context."
  (interactive)
  (cond
   ((org-at-table-p) (call-interactively 'org-table-hline-and-move))
   (t (call-interactively 'org-insert-todo-heading))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c RET") 'cb-org:ctrl-c-ret)
#+end_src
** Define a command to tidy org buffers.
#+begin_src emacs-lisp
(defun tidy-org-buffer ()
  "Perform cosmetic fixes to the current org-mode buffer."
  (save-restriction
    (org-table-map-tables 'org-table-align 'quiet)
    ;; Realign tags.
    (org-set-tags 4 t)
    ;; Remove empty properties drawers.
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp ":PROPERTIES:" nil t)
        (save-excursion
          (org-remove-empty-drawer-at "PROPERTIES" (match-beginning 0)))))))
#+end_src
** Tidy org buffers when saving
#+begin_src emacs-lisp
(hook-fn 'org-mode-hook
  (add-hook 'before-save-hook 'tidy-org-buffer nil t))
#+end_src
** Customise capture templates
#+begin_src emacs-lisp
(require 'org-capture)
(-each `(("t" "Todo" entry
          (file+headline org-default-notes-file "Tasks")
          ,(s-unlines
            "* TODO %?                               :@computer:"
            "SCHEDULED: %t"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("s" "Someday" entry
          (file+headline org-default-notes-file "Someday")
          ,(s-unlines
            "* MAYBE %?                              :@computer:"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("d" "Diary" entry
          (file+datetree org-agenda-diary-file)
          "* %?\n%^t"
          :clock-keep t)

         ("h" "Habit" entry
          (file+headline org-default-notes-file "Habits/Recurring")
          ,(s-unlines
            "* TODO %?"
            "SCHEDULED: %t"
            ":PROPERTIES:"
            ":STYLE: habit"
            ":END:"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("p" "Phone Call (in)" entry
          (file+headline org-default-notes-file "Calls")
          ,(s-unlines
            "* %U"
            "- From :: %?"
            "- To :: "
            "- Subject :: ")
          :clock-in t
          :clock-resume t)

         ("o" "Phone Call (out)" entry
          (file+headline org-default-notes-file "Calls")
          ,(s-unlines
            "* %U"
            "- To :: %^{To}"
            "- Subject :: %^{Subject}"
            "%?")
          :clock-in t
          :clock-resume t)

         ("b" "Bill" entry
          (file+olp org-default-notes-file "Finance" "Bills")
          ,(s-unlines
            "* TODO %?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("l" "Link" entry
          (file+headline org-default-notes-file "Links")
          ,(s-unlines
            "* %c"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:"
            "%i")
          :immediate-finish t
          :clock-keep t)

         ("m" "Listening" entry
          (file+olp org-default-notes-file "Someday" "Listening")
          ,(s-unlines
            "* MAYBE Listen to %i%?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("v" "Viewing" entry
          (file+olp org-default-notes-file "Someday" "Viewing")
          ,(s-unlines
            "* MAYBE Watch %i%?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("r" "Reading" entry
          (file+olp org-default-notes-file "Someday" "Reading")
          ,(s-unlines
            "* MAYBE Read %i%?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("n" "Note" entry
          (file+headline org-default-notes-file "Notes")
          ,(s-unlines
            "* %i%?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t)

         ("z" "Task Note" entry
          (clock)
          ,(s-unlines
            "* %i%?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t
          :kill-buffer t)

         ("L" "Task Link" entry
          (clock)
          ,(s-unlines
            "* %a%?"
            ":PROPERTIES:"
            ":CAPTURED: %U"
            ":END:")
          :clock-keep t
          :kill-buffer t)
         )
       (~ add-to-list 'org-capture-templates))
#+end_src
** Agenda
#+begin_src emacs-lisp
(require 'org-agenda)
#+end_src
*** Show appointment notifications in the modeline
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook 'org-agenda-to-appt)
#+end_src
*** Read all org files in the org directory for items to add to the agenda
#+begin_src emacs-lisp
(add-to-list 'org-agenda-files org-directory)
#+end_src
*** Use the timestamp set in diary entries
#+begin_src emacs-lisp
(setq org-agenda-insert-diary-extract-time t)
#+end_src
*** Show the whole coming week in the agenda
#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday nil
      org-agenda-span 'week
      org-agenda-ndays 7)
#+end_src
*** Define a hook for setting up agenda windows
#+begin_src emacs-lisp
(defvar org-agenda-customise-window-hook nil
  "Relay hook for `org-agenda-mode-hook'. Suitable for setting up the window.")

(hook-fn 'org-agenda-mode-hook
  (run-hooks 'org-agenda-customise-window-hook))
#+end_src
*** Show today's agenda after a period of inactivity
#+begin_src emacs-lisp
(defvar cb-org:show-agenda-idle-delay (* 30 60)
  "The delay in seconds after which to pop up today's agenda.")

(defvar cb-org:show-agenda-idle-timer
  (unless noninteractive
    (run-with-idle-timer cb-org:show-agenda-idle-delay t
                         'executor:org-agenda-fullscreen))
  "Idle timer that will display today's org agenda.
See `cb-org:show-agenda-idle-delay'.")
#+end_src
*** Exclude tasks with :hold: tag
#+begin_src emacs-lisp
(defun cb-org:exclude-tasks-on-hold (tag)
  (and (equal tag "hold") (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'cb-org:exclude-tasks-on-hold)
#+end_src
*** Searches include archives.
#+begin_src emacs-lisp
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+end_src
*** Searches are boolean, like a Google search.
#+begin_src emacs-lisp
(setq org-agenda-search-view-always-boolean t)
#+end_src
*** Deadlines
Don't show deadlines or scheduled tasks that have been completed.
#+begin_src emacs-lisp
(setq org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-prewarning-if-scheduled t)
#+end_src
*** Add GTD agenda views
They should be displayed modally.
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      (->> '(("A" "Agenda+NEXT"
              ((agenda "" ((org-agenda-ndays 1)))
               (tags-todo "-someday/NEXT")))
             ("n" "Next actions"
              ((tags-todo "-someday/NEXT")))
             ("w" "Weekly Review"
              ((agenda "" ((org-agenda-ndays 7)))
               (stuck "")
               (todo "WAITING")
               (tags-todo "someday-media-skill")
               (tags-todo "someday&skill")
               (tags-todo "someday&media")))
             ("g" . "GTD contexts")
             ("gg" "Anywhere"
              ((tags-todo "@computer")
               (tags-todo "@errand")
               (tags-todo "@home")
               (tags-todo "@leisure")
               (tags-todo "@phone")
               (tags-todo "@work")))
             ("ge" "Errands"  tags-todo "@errand")
             ("gp" "Phone"    tags-todo "@phone")
             ("gw" "Work"     tags-todo "@work")
             ("gh" "Home"     tags-todo "@home")
             ("gl" "Leisure"  tags-todo "@leisure"))
        (--map-when (listp (cdr it))
                    (append it
                            '(((org-agenda-customise-window-hook
                                'delete-other-windows)))))))
#+end_src
*** Sort order
#+begin_src emacs-lisp
(setq org-agenda-sorting-strategy
      '((agenda habit-down time-up priority-down category-keep)
        (todo priority-down category-keep scheduled-up)
        (tags priority-down category-keep)
        (search category-keep)))
#+end_src
*** Navigation commands
Define commands for skipping through agenda sections.
**** Impl
#+begin_src emacs-lisp
(defun cb-org:agenda-next-section ()
  "Move to the next section in the agenda."
  (interactive)
  (save-match-data
    (cond ((search-forward-regexp (rx bol (+ "="))
                                  nil t)
           (goto-char (line-beginning-position))
           (org-agenda-next-item 1))
          (t
           (goto-char (point-max))
           (goto-char (line-beginning-position))))))

(defun cb-org:agenda-prev-section ()
  "Move to the previous section in the agenda."
  (interactive)
  (save-match-data
    (cl-flet ((goto-section-start ()
                                  (when (search-backward-regexp (rx bol (+ "=")) nil t)
                                    (org-agenda-next-item 1)
                                    (goto-char (line-beginning-position))
                                    (point))))
      (let ((current-section-start (save-excursion (goto-section-start))))
        (cond
         ((and (equal (point) current-section-start)
               (search-backward-regexp (rx bol (+ "=")) nil t 2)))
         ((search-backward-regexp (rx bol (+ "=")) nil t))
         (t
          (goto-char (point-min)))

         (forward-line 1)
         (goto-char (line-beginning-position)))))))
#+end_src
**** Key bindings
#+begin_src emacs-lisp
(define-key org-agenda-mode-map (kbd "M-N") 'cb-org:agenda-next-section)
(define-key org-agenda-mode-map (kbd "M-P") 'cb-org:agenda-prev-section)
#+end_src
*** Disable smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (hook-fn 'org-agenda-mode-hook
    (smartparens-mode -1)))
#+end_src
** Define commands for use in diary entries
*** Find the closest date to the given date an a certain day of the week
#+begin_src emacs-lisp
(defvar date nil
  "Dynamic var bound to current date by calendaring functions.")

(autoload 'calendar-extract-year "calendar")
(autoload 'calendar-day-number "calendar")
(autoload 'calendar-day-of-week "calendar")

(defun calendar-nearest-to (target-dayname target-day target-month)
  "Non-nil if the current date is a certian weekday close to an anniversary.

TARGET-DAYNAME is the day of the week that we want to match,
 while TARGET-DAY and TARGET-MONTH are the anniversary."
  (interactive)
  (let* ((dayname (calendar-day-of-week date))
         (target-date (list target-month target-day (calendar-extract-year date)))
         (days-diff (abs (- (calendar-day-number date)
                            (calendar-day-number target-date)))))
    (and (= dayname target-dayname)
         (< days-diff 4))))

#+end_src
*** Find dates that occur at regular intervals of N days/weeks/months
#+begin_src emacs-lisp
(defun diary-limited-cyclic (recurrences interval m d y)
  "For use in emacs diary. Cyclic item with limited number of recurrences.
Occurs every INTERVAL days, starting on YYYY-MM-DD, for a total of
RECURRENCES occasions."
  (let ((startdate (calendar-absolute-from-gregorian (list m d y)))
        (today (calendar-absolute-from-gregorian date)))
    (and (not (cl-minusp (- today startdate)))
         (zerop (% (- today startdate) interval))
         (< (floor (- today startdate) interval) recurrences))))

#+end_src
*** Define a command to read a class sexpr and insert at point.
#+begin_src emacs-lisp
(cl-defun cb-org:format-class-sexpr ((s1 m1 h1 d1 m1 y1 . _)
                                     (s2 m2 h2 d2 m2 y2 . _)
                                     desc)
  "Parse dates into an org-class s-expression."
  (let* ((time (unless (or (zerop m1) (zerop h1))
                 (format " %.2i:%.2i %s" h1 m1 desc)))
         (date-range (list (list y1 m1 d1) (list y2 m2 d2)))
         (date-cols (-map (C
                           (~ s-pad-right 12 " ")
                           (~ s-join " ")
                           (~ -map (C (~ s-pad-left 2 " ")
                                      'number-to-string)))
                          date-range))
         (day-of-week (number-to-string (calendar-day-of-week (list m1 d1 y1)))))
    (concat "<%%(org-class   "
            (s-join " "  (-concat date-cols (list day-of-week)))
            ")>" time)))

(defun org-read-class ()
  "Read a class diary sexp with a description.
The starting day is taken to be the weekday on which the event will repeat."
  (let ((desc (read-string "Description: ")))
    (cb-org:format-class-sexpr
     (org-parse-time-string (org-read-date nil nil nil "Start date: "))
     (org-parse-time-string (org-read-date nil nil nil "End date: "))
     desc)))

(defun org-insert-class ()
  "Read and insert a class diary sexp at point."
  (interactive "*")
  (insert (org-read-class)))
#+end_src
** Babel
*** Load languages
#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (ledger . t)
   (C . t)
   (ditaa . t)
   (sh . t)
   (calc . t)
   (scala . t)
   (emacs-lisp . t)
   (ruby . t)
   (clojure . t)
   (haskell . t)))
#+end_src
*** Apply font-locking to source blocks
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src
*** Do not prompt for confirmation when eval'ing source blocks
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src
*** Do not indent source blocks
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
#+end_src
*** Run a hook when exiting source blocks
#+begin_src emacs-lisp
(defvar org-edit-src-before-exit-hook nil
  "Hook run before exiting a code block.")

(defadvice org-edit-src-exit (before run-hook activate)
  (run-hooks 'org-edit-src-before-exit-hook))
#+end_src
*** Do not add a final newline to org source buffers
#+begin_src emacs-lisp
(hook-fn 'org-src-mode-hook
  (setq-local require-final-newline nil))
#+end_src
*** Remove trailing spaces when exiting org code blocks
#+begin_src emacs-lisp
(add-hook 'org-edit-src-before-exit-hook 'delete-trailing-whitespace)
#+end_src
** Todos
*** Do not allow todos to be marked as DONE when children are not DONE
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src
*** Define todo keywords
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
         "TODO(t)" "NEXT(n!)" "MAYBE(m!)"
         "OUTSTANDING(o)" "WAITING(w@/!)" "APPT(a!)"
         "|"
         "DONE(d!)" "PAID(p!)" "VOID(v@)" "CANCELLED(c@)" "DELEGATED(D@)")))
#+end_src
*** Use special face for NEXT keyword
#+begin_src emacs-lisp
(defface org-todo-next
  '((((background dark))
     (:foreground "OrangeRed1" :bold t))
    (((background light))
     (:foreground "OrangeRed4" :bold t))
    (t
     (:inherit org-todo)))
  "Face for todos with the NEXT label."
  :group 'org-faces)

(setq org-todo-keyword-faces '(("NEXT" . org-todo-next)))
#+end_src
*** Sub-task completion triggers parent completion
#+begin_src emacs-lisp
(hook-fn 'org-after-todo-statistics-hook
  :arglist (n-done n-not-done)
  (let (org-log-done org-log-states) ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
#+end_src
** orglink
Adds support for org-mode-style and plain links in other modes.
#+begin_src emacs-lisp
(cb:install-package 'orglink t)
#+end_src
*** Define which link types to highlight
#+begin_src emacs-lisp
(setq orglink-activate-links '(angle plain))
#+end_src
*** Don't show in the modeline
#+begin_src emacs-lisp
(setq orglink-mode-lighter nil)
#+end_src
*** Use orglink in most modes
#+begin_src emacs-lisp
(hook-fns '(prog-mode-hook text-mode-hook comint-mode)
  (ignore-errors
    (unless (derived-mode-p 'org-mode 'nxml-mode 'sgml-mode 'snippet-mode)
      (orglink-mode +1))))
#+end_src
** org-pomodoro
Implements Pomodoro timers using org-mode's clocking functions. I have my own
fork, since the original wasn't keeping up with pull requests and has since
diverged.
*** Set a key binding for starting a pomodoro
#+begin_src emacs-lisp
(autoload 'org-pomodoro "org-pomodoro")
(bind-key* "<f5>" 'org-pomodoro)
#+end_src
*** Set pomodoro length
#+begin_src emacs-lisp
(setq org-pomodoro-long-break-length 25)
#+end_src
*** Customise display format
#+begin_src emacs-lisp
(setq org-pomodoro-format "• %s"
      org-pomodoro-short-break-format "Break %s"
      org-pomodoro-long-break-format "Break %s"
      org-pomodoro-show-seconds nil)
#+end_src
Don't use the built-in display mechanism, since I use custom logic in my
modeline format string.
#+begin_src emacs-lisp
(setq org-pomodoro-show-in-mode-line nil)
#+end_src
** appt
=appt= is emacs' generic scheduling system for calendar. Configure it to hook
into org-mode.
#+begin_src emacs-lisp
(require 'appt)
(setq appt-message-warning-time 60
      appt-display-interval 15)

(save-window-excursion
  (appt-activate +1))
#+end_src
*** Update appointments when saving the diary file
#+begin_src emacs-lisp
(defun cb-org:save-diary ()
  (save-restriction
    (save-window-excursion
      (org-agenda-to-appt t)
      (appt-check 'force))))

(hook-fn 'org-mode-hook
  (when (equal (buffer-file-name) org-agenda-diary-file)
    (add-hook 'after-save-hook 'cb-org:save-diary nil t)))
#+end_src
** org-protocol
Allows other applications to connect to Emacs and prompt org-mode to perform
certain actions, including saving links.
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src
** org-reveal
Provides a Reveal.js exporter for making presentations.
#+begin_src emacs-lisp
(cb:install-package 'ox-reveal t)
#+end_src
*** Set path to reveal.js
#+begin_src emacs-lisp
(setq org-reveal-root (concat "file://" (f-join cb:lib-dir "reveal.js")))
#+end_src
*** Define auxiliary functions for snippets.
#+begin_src emacs-lisp
(defun cb-org:reveal-read-transition ()
  (popup-menu*
   (-map 'popup-make-item
         '("Cube" "Page" "Concave" "Zoom" "Linear" "Fade" "None" "Default"))
   :isearch t))

(defun cb-org:reveal-read-theme ()
  (popup-menu*
   (-map 'popup-make-item
         '("Default" "Sky" "Beige" "Simple" "Serif" "Night Moon" "Simple" "Solarized"))
   :isearch t))

(defun cb-org:reveal-read-frag-style ()
  (popup-menu*
   (-map 'popup-make-item
         '("grow" "shrink" "roll-in" "fade-out"
           "highlight-red" "highlight-green" "highlight-blue"))
   :isearch t))
#+end_src
** Display inline images in org buffers
#+begin_src emacs-lisp
(after 'org
  (require 'iimage))
#+end_src
*** Show images in file links
#+begin_src emacs-lisp
(after 'iimage
  (add-to-list 'iimage-mode-image-regex-alist
               (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                             "\\)\\]")  1)))
#+end_src
*** Define a command to toggle images
#+begin_src emacs-lisp
(defun org-toggle-iimage-in-org ()
  "Display images in the current orgmode buffer."
  (interactive)
  (if (face-underline-p 'org-link)
      (set-face-underline-p 'org-link nil)
    (set-face-underline-p 'org-link t))
  (iimage-mode))
#+end_src
** flyspell
Prevent flyspell from incorrectly flagging common org-mode content such as code
blocks and encrypted regions.
*** Define a structure element for suppressing spell checks
#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
             '("n" "#+begin_nospell\n?\n#+end_nospell" "?"))
#+end_src
*** Define a custom flyspell predicate for org buffers
#+begin_src emacs-lisp
(defun cb-org:in-no-spellcheck-zone? ()
  (thing-at-point-looking-at (rx "#+begin_nospell" (*? anything ) "#+end_nospell")))

(defun cb-org:flyspell-verify ()
  "Prevent common flyspell false positives in org-mode."
  (and (ignore-errors
         (org-mode-flyspell-verify))
       (not (or
             (ignore-errors (org-at-encrypted-entry-p))
             (ignore-errors (org-in-src-block-p))
             (ignore-errors (org-at-TBLFM-p))
             (ignore-errors (org-in-block-p '("src" "example" "latex" "html")))
             (ignore-errors (org-in-verbatim-emphasis))
             (ignore-errors (org-in-drawer-p))
             (thing-at-point-looking-at (rx bol "#+" (* nonl) eol))
             (cb-org:in-no-spellcheck-zone?)))))
#+end_src
*** Apply custom flyspell predicate
#+begin_src emacs-lisp
(put 'org-mode 'flyspell-mode-predicate 'cb-org:flyspell-verify)

(hook-fn 'org-mode-hook
  (setq-local flyspell-generic-check-word-predicate 'cb-org:flyspell-verify))
#+end_src
** Use lowercase structure keys, e.g. "begin_src" instead of "BEGIN_SRC"
#+begin_src emacs-lisp
(setq org-structure-template-alist
      (-map (~ -map 's-downcase) org-structure-template-alist))
#+end_src
** Disable auto-complete
#+begin_src emacs-lisp
(after 'auto-complete
  (hook-fn 'org-mode-hook
    (setq-local ac-sources nil)
    (auto-complete-mode -1)))
#+end_src
** Evil
*** Enter insertion mode in capture buffer
#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src
*** Use evil key bindings in agenda

#+begin_src emacs-lisp
(after '(evil org-agenda)
  (bind-keys
    :map org-agenda-mode-map
    "C" 'org-agenda-capture
    "g" 'org-agenda-goto-date
    "j" 'org-agenda-next-item
    "k" 'org-agenda-previous-item
    "L" 'org-agenda-log-mode
    "l" 'evil-forward-char
    "h" 'evil-backward-char
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up))
#+end_src
*** Advise header insertion commands to enter evil insert state
#+begin_src emacs-lisp
(defadvice org-insert-heading (after insert-state activate)
  "Enter evil insert state"
  (when (fboundp 'evil-insert-state)
    (evil-insert-state nil)))

(defadvice org-insert-todo-heading (after insert-state activate)
  "Enter evil insert state"
  (when (fboundp 'evil-insert-state)
    (evil-insert-state nil)))
#+end_src
*** Adapt outline fold commands for Evil
#+begin_src emacs-lisp
(defadvice org-toggle-heading (after goto-line-end activate)
  "Prevent point from being moved to the line beginning."
  (when (s-matches? (rx bol (+ "*") (* space) eol) (current-line))
    (goto-char (line-end-position))))

(defun cborg-evil-fold ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (org-global-cycle 1)
    (recenter)))

(defun cborg-evil-reveal ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (org-global-cycle 16)
    (recenter)))

(evil-define-key 'normal org-mode-map
  (kbd "<return>") 'org-return
  (kbd "M-P") 'outline-previous-visible-heading
  (kbd "M-N") 'outline-next-visible-heading
  (kbd "SPC") 'org-cycle
  (kbd "z m") 'cborg-evil-fold
  (kbd "z r") 'cborg-evil-reveal)
#+end_src
*** Advise org-return not to insert newlines unless we're in insertion state
#+begin_src emacs-lisp
(defadvice org-return (around newlines-only-in-insert-state activate)
  "Only insert newlines if we're in insert state."
  (noflet ((newline (&rest args)
                    (when (evil-insert-state-p)
                      (funcall this-fn args))))
      ad-do-it))
#+end_src
** Growl
Show growl notifications.
#+begin_src emacs-lisp
(defconst org-unicorn-png
  (f-join user-emacs-directory "assets" "org_unicorn.png"))
#+end_src
*** CONDITIONAL
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
#+end_src
*** Advise appt to show Growl notifications for appointments.
#+begin_src emacs-lisp
(defun cb-appt:growl (title mins)
  (growl (cond ((zerop mins) "Appointment (now)")
               ((= 1 mins)   "Appointment (1 min)")
               (t (format "Appointment (%s mins)" mins)))
         (cl-destructuring-bind (whole time desc)
             (s-match (rx bol
                          (group (+ digit) ":" (+ digit))
                          (* space)
                          (group (* nonl)))
                      title)
           desc)))

(defadvice appt-display-message (around growl-with-sound activate)
  "Play a sound and display a growl notification for appt alerts."
  ;; Show notification.
  (let ((title (-listify (ad-get-arg 0)))
        (mins (-listify (ad-get-arg 1))))
    (-each (-zip-with 'list title mins)
           (-applify 'cb-appt:growl)))
  ;; Play sound.
  (osx-play-system-sound "blow"))
#+end_src
*** Show Growl notification for countdown timers
#+begin_src emacs-lisp
(hook-fn 'org-timer-start-hook (growl "Timer Started" "" org-unicorn-png))
(hook-fn 'org-timer-done-hook (growl "Timer Finished" "" org-unicorn-png))
(hook-fn 'org-timer-done-hook (osx-play-system-sound "glass"))
#+end_src
*** Show Growl notifications when capturing links from a browser
#+begin_src emacs-lisp
(defadvice org-protocol-do-capture (after show-growl-notification activate)
  "Show Growl notification when capturing links."
  (let* ((parts (org-protocol-split-data (ad-get-arg 0) t org-protocol-data-separator))
         ;; Pop the template selector if present.
         (template (or (and (>= 2 (length (car parts))) (pop parts))
                       org-protocol-default-template-key))
         (url (org-protocol-sanitize-uri (car parts)))
         (type (if (string-match "^\\([a-z]+\\):" url)
                   (match-string 1 url)))
         (title (or (cadr parts) "")))
    (growl "Link Stored" (or title url) org-unicorn-png)))
#+end_src
*** Use system sounds for pomodoro notifications on OS X
#+begin_src emacs-lisp
(let ((snd (osx-find-system-sound "purr")))
  (setq org-pomodoro-sound snd
        org-pomodoro-short-break-sound snd
        org-pomodoro-long-break-sound snd))
#+end_src
*** Show growl notifications for pomodoros
#+begin_src emacs-lisp
(defun cb-org:pomodoro-growl ()
  (growl "Pomodoro"
         (cl-case org-pomodoro-state
           (:pomodoro (format "Timer started (%s/%s)"
                              (1+ (mod org-pomodoro-count
                                       org-pomodoro-long-break-frequency))
                              org-pomodoro-long-break-frequency))
           (:short-break "Short break")
           (:long-break  "Long break")
           (otherwise "Stopped"))
         (f-join cb:assets-dir "org-pomodoro.png")))

(add-hook 'org-pomodoro-finished-hook 'cb-org:pomodoro-growl)
(add-hook 'org-pomodoro-started-hook 'cb-org:pomodoro-growl)
(add-hook 'org-pomodoro-killed-hook 'cb-org:pomodoro-growl)

(defun cb-org:pomodoro-growl-end-break ()
  (growl "Pomodoro"
         "Break finished"
         (f-join cb:assets-dir "org-pomodoro.png")))

(add-hook 'org-pomodoro-short-break-finished-hook 'cb-org:pomodoro-growl-end-break)
(add-hook 'org-pomodoro-short-break-finished-hook 'cb-org:pomodoro-growl-end-break)
#+end_src
*** END
#+begin_src emacs-lisp
)
#+end_src
** Show the agenda after init
#+begin_src emacs-lisp
(when (or (daemonp) (display-graphic-p))
  (hook-fn 'after-init-hook
    (unless noninteractive
      (executor:org-agenda-fullscreen))))
#+end_src
** Auto-save notes file
Run an idle timer to save the notes file.

This has the nice side-effect that encrypted regions will be automatically
re-encrypted after a period of inactivity.
#+begin_src emacs-lisp
(defvar cb-org:notes-save-idle-delay 60)

(defun cb-org:save-notes ()
  "Save the notes file."
  (-when-let (buf (--first-buffer (equal (buffer-file-name it)
                                         org-default-notes-file)))
    (with-current-buffer buf
      (when (buffer-modified-p)
        (save-buffer)))))

(defvar cb-org:notes-save-timer
  (unless noninteractive
    (run-with-idle-timer cb-org:notes-save-idle-delay t 'cb-org:save-notes))
  "Timer that automatically saves the notes buffer on idle.")
#+end_src
** Capture tasks, notes, etc from emails
#+begin_src emacs-lisp
(require 'cb-org-email-capture)

(unless noninteractive
  (hook-fn 'after-init-hook
    (defvar cbom:capture-timer
      (run-with-timer 5 60 (lambda ()
                              (with-demoted-errors
                                  (org-capture-messages)))))))
#+end_src
* Circe
Circe is an Emacs IRC client.
#+begin_src emacs-lisp
(cb:install-package 'circe)
#+end_src
** Enable flyspell for input in circe buffers
#+begin_src emacs-lisp
(setq lui-flyspell-p t)
#+end_src
** Detect long URLs and replace with a link using a paste service
#+begin_src emacs-lisp
(after 'circe (require 'lui-autopaste))
(add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
#+end_src
** Show time stamps in margin
#+begin_src emacs-lisp
(setq lui-time-stamp-position 'right-margin
      lui-time-stamp-format "%H:%M")

(put 'lui-mode 'right-margin-width 5)
#+end_src
** Define a command to show all circe buffers
#+begin_src emacs-lisp
(defun show-irc ()
  "Show all IRC buffers."
  (interactive)
  (with-window-restore
    ;; Start IRC.
    (unless (--first-buffer (derived-mode-p 'circe-server-mode))
      (call-interactively 'circe))
    ;; Select IRC buffers.
    (let ((bufs (->> (--filter-buffers (derived-mode-p 'circe-chat-mode
                                                       'circe-channel-mode))
                  (-sort (-on 'string< 'buffer-name)))))
      ;; Show all IRC buffers.
      (expose-buffers bufs)
      ;; Set up restore bindings.
      (--each bufs (buffer-local-set-key (kbd "C-c C-k") (command (restore)))))))
#+end_src
** Text formatting
*** Disable text filling.
#+begin_src emacs-lisp
(setq lui-fill-type nil)
#+end_src
*** Configure text wrapping
#+begin_src emacs-lisp
(defun cbcirce:wrapping-setup ()
  (setq
   fringes-outside-margins t
   right-margin-width 5
   word-wrap t
   wrap-prefix "    "))

(add-hook 'lui-mode-hook 'cbcirce:wrapping-setup)
#+end_src
** Bots and lurkers
*** Define list of bots and lurkers
#+begin_src emacs-lisp
(setq circe-bot-list '("fsbot" "rudybot"))
#+end_src
*** Hide status messages by lurkers
#+begin_src emacs-lisp
(setq circe-reduce-lurker-spam t)
#+end_src
*** Dim messages from bots
#+begin_src emacs-lisp
(defun cbcirce:message-option-bot (nick &rest ignored)
  (when (member nick circe-bot-list)
    '((text-properties . (face circe-fool-face lui-do-not-track t)))))

(add-hook 'circe-message-option-functions 'cbcirce:message-option-bot)
#+end_src
** Customise circe faces
#+begin_src emacs-lisp
(after 'circe
  (set-face-foreground 'circe-server-face
                       (face-foreground 'font-lock-comment-face))

  (set-face-foreground 'circe-fool-face
                       (face-foreground 'font-lock-comment-face))

  (set-face-foreground 'lui-time-stamp-face
                       (face-foreground 'font-lock-comment-face))

  (set-face-foreground 'circe-my-message-face solarized-hl-orange)
  (set-face-foreground 'lui-button-face solarized-hl-yellow)
  (set-face-foreground 'circe-originator-face solarized-hl-violet)
  (set-face-foreground 'circe-highlight-nick-face solarized-hl-cyan))
#+end_src
** Customise prompt
*** Apply in hooks
#+begin_src emacs-lisp
(defun cbcirce:set-prompt ()
  (let ((prompt (propertize (format "%s: " (circe-server-nick))
                            'face circe-prompt-face)))
    (lui-set-prompt prompt)))

(add-hook 'circe-nickserv-authenticated-hook 'cbcirce:set-prompt)
(add-hook 'circe-server-connected-hook 'cbcirce:set-prompt)
(add-hook 'circe-channel-mode-hook 'cbcirce:set-prompt)
#+end_src
*** Customise prompt face
#+begin_src emacs-lisp
(after 'circe
  (set-face-foreground 'circe-prompt-face solarized-hl-orange)
  (set-face-background 'circe-prompt-face nil))
#+end_src
** Evil
Use evil insert state in Circe.
#+begin_src emacs-lisp
(after '(evil circe)
  (add-hook 'circe-server-mode-hook 'evil-insert-state)
  (add-hook 'circe-channel-mode-hook 'evil-insert-state)
  (add-hook 'circe-chat-mode-hook 'evil-insert-state))
#+end_src
** Smartparens
Fix delete key behaviour in circe message mode.
#+begin_src emacs-lisp
(defun cbcirce:del ()
  "Delete command for Circe buffers that works with smartparens."
  (interactive)
  (call-interactively
   (if (sp-get-sexp t) 'sp-backward-delete-char 'delete-backward-char)))

(after '(circe smartparens)
  (define-key circe-channel-mode-map (kbd "<backspace>") 'cbcirce:del))
#+end_src
* ledger
** ledger-mode
Provides support for ledger files.
#+begin_src emacs-lisp
(cb:install-package 'ledger-mode)
(add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
#+end_src

Use 2 spaces for indentation.
#+begin_src emacs-lisp
(setq ledger-post-account-alignment-column 2)
#+end_src

Use ido for completion.
#+begin_src emacs-lisp
(setq ledger-post-use-completion-engine :ido)
#+end_src
** Org
*** Add a command to the org picker to go to the ledger file
#+begin_src emacs-lisp
(add-to-list 'org-action-picker-options
             '("$" "Go to ledger" (lambda () (find-file ledger-file))))
#+end_src
*** Define capture template for expenses
#+begin_src emacs-lisp
(after 'org-capture

  (defmacro cbledger:with-ledger-buffer (&rest body)
    "Execute BODY forms in a ledger buffer.
Use `ledger-buffer' if the current buffer is not in ledger-mode."
    (declare (indent 0))
    `(with-current-buffer ,(if (derived-mode-p 'ledger-mode)
                               (current-buffer)
                             (find-file-noselect ledger-file))
       ,@body))

  (defun cbledger:read-date ()
    (s-replace "-" "/" (car (s-split " " (org-read-date)))))

  (defun cbledger:read-payee ()
    (cbledger:with-ledger-buffer
      (ido-completing-read "Payee: " (ledger-payees-in-buffer))))

  (defun cbledger:read-clear-state ()
    (if (y-or-n-p "Transaction cleared? ") " * " " "))

  (defun cbledger:read-amount ()
    (format "$ %.2f" (read-number "Amount $: ")))

  (defun cbledger:accounts ()
    "Find all accounts in the current ledger buffer, or in the `ledger-file'."
    (cbledger:with-ledger-buffer
      (->> (s-match-strings-all
            (rx bol (+ space) (group (+ (not space)) ":" (+? nonl))
                (or eol "  "))
            (buffer-string))
        (-map 'cadr)
        (-uniq)
        (-sort 'string<))))

  (defun cbledger:read-account (prompt initial-input)
    (ido-completing-read prompt (cbledger:accounts) nil nil initial-input))

  (defun cbledger:read-expense ()
    (let ((date (cbledger:read-date))
          (payee (cbledger:read-payee))
          (to-account (cbledger:read-account "To: " "Expenses:"))
          (amount (cbledger:read-amount))
          (from-account (cbledger:read-account "From: " "Assets:"))
          (cleared? (cbledger:read-clear-state)))
      (concat date cleared? payee "\n"
              "  " to-account "  " amount "\n"
              "  " from-account)))

  (add-to-list 'org-capture-templates
               `("$" "Expense" plain (file ,ledger-file)
                 (function cbledger:read-expense)
                 :empty-lines 1
                 :clock-keep t
                 :jump-to-captured t
                 :immediate-finish t)))
#+end_src

** DEFER
#+begin_src emacs-lisp
(after 'ledger-mode
#+end_src
** Utilities for finding the bounds of transactions
#+begin_src emacs-lisp
(defvar cbledger:transaction-start (rx bol (any digit "~" "="))
  "Regex matching the start of a transaction line.")

(cl-defun ledger-transaction-at-pt (&optional (pt (point)))
  "Return the transaction at PT."
  (goto-char pt)
  (-when-let* ((beg (ledger-transaction-start-pos))
               (end (ledger-transaction-end-pos)))
    (buffer-substring-no-properties beg end)))

(cl-defun ledger-cur-transaction-date ()
  "Return the date for the transaction at point"
  (-when-let (trans (ledger-transaction-at-pt))
    (car (s-match ledger-full-date-regexp trans))))

(defun ledger-transaction-start-pos ()
  "Return the buffer position where the transaction at point begins."
  (save-excursion
    (if (s-matches? cbledger:transaction-start (current-line))
        (goto-char (line-beginning-position))
      (ignore-errors
        (ledger-prev-transaction)))))

(defun ledger-transaction-end-pos ()
  "Return the buffer position where the transaction at point ends."
  (save-excursion
    (or (ignore-errors (ledger-next-transaction))
        (goto-char (point-max)))

    (let (pos)
      (forward-line -1)
      (goto-char (line-end-position))
      (setq pos (point))
      (while (s-matches? (rx bol (* space) eol) (current-line))
        (forward-line -1)
        (goto-char (line-end-position))
        (setq pos (point)))
      pos)))
#+end_src
** Move by date
Define a command to move to transactions of a certain date.
*** Impl
#+begin_src emacs-lisp
(defun ledger-move-to-date (date)
  "Move to DATE in the ledger file."
  ;; Use slashes for consistency with ledger's date format.
  (interactive (list (s-replace "-" "/" (org-read-date))))
  (cl-destructuring-bind (y m d) (-map 'string-to-number (s-split "/" date))
    (ledger-xact-find-slot (encode-time 0 0 0 d m y))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "C-c C-d") 'ledger-move-to-date)
#+end_src
** Buffer formatting
*** Define format buffer command
#+begin_src emacs-lisp
(defun ledger-format-buffer ()
  "Reformat the buffer."
  (interactive "*")
  (let ((pt (point)))
    (save-excursion
      (ledger-post-align-postings (point-min) (point-max))
      (ledger-sort-buffer)
      (message "Formatted buffer"))
    (goto-char pt)))
#+end_src
*** Automatically reformat the buffer on save.
#+begin_src emacs-lisp
(hook-fn 'ledger-mode-hook
  (add-hook 'before-save-hook 'ledger-format-buffer nil t))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "M-q") 'ledger-format-buffer)
#+end_src
** Custom newline command
Define a custom newline command.
*** Impl
#+begin_src emacs-lisp
(defun ledger-ret ()
  "Newline and format."
  (interactive "*")
  (cond
   ((s-matches? (rx bol (* space) eol) (current-line))
    (delete-horizontal-space)
    (newline))
   (t
    (ledger-post-align-postings)
    (newline)
    (indent-to ledger-post-account-alignment-column))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "RET") 'ledger-ret)
#+end_src
** Movement by transactions
Define commands for moving by transactions.
*** Impl
#+begin_src emacs-lisp
(defun ledger-prev-transaction (&optional count)
  "Move backward to the start of the last transaction."
  (interactive)
  (goto-char (line-beginning-position))
  (cond
   ((bobp)
    (user-error "Beginning of buffer"))
   ((search-backward-regexp cbledger:transaction-start nil t count)
    (goto-char (line-beginning-position)))
   (t
    (goto-char (point-min)))))

(defun ledger-next-transaction (&optional count)
  "Move forward to the start of the next transaction."
  (interactive)
  (let ((start (point)))
    (goto-char (line-end-position))
    (if (search-forward-regexp cbledger:transaction-start nil t count)
        (goto-char (line-beginning-position))
      (goto-char start)
      (user-error "End of buffer"))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "M-P") 'ledger-prev-transaction)
(define-key ledger-mode-map (kbd "M-N") 'ledger-next-transaction)
#+end_src
** Deleting transactions
Define a command to kill the transaction at point.
*** Impl
#+begin_src emacs-lisp
(defun cbledger:delete-transaction-at-pt ()
  "Kill the current transaction.
Behaves correctly for transactions that are not separated by blank lines."
  (when (s-blank? (ledger-transaction-at-pt))
    (error "Not at a transaction"))
  (delete-region (ledger-transaction-start-pos)
                 (ledger-transaction-end-pos))
  (collapse-vertical-whitespace)
  (forward-line))

    (defun ledger-kill-transaction-at-pt ()
      "Kill the transaction at point and add it to the kill ring."
      (interactive "*")
      (-if-let (trans (ledger-transaction-at-pt))
          (progn
            (kill-new trans)
            (cbledger:delete-transaction-at-pt)
            (when (called-interactively-p nil)
              (message "Transaction copied to kill-ring"))
            trans)
        (user-error "Point is not at a transaction")))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "C-c C-k") 'ledger-kill-transaction-at-pt)
#+end_src
** Transposing transactions
Define a command to transpose transactions around point.
#+begin_src emacs-lisp
(defun ledger-periodic-transaction? (str)
  "Non-nil if STR is a periodic transaction."
  (when str (s-starts-with? "~" str)))

(defun ledger-transpose-transactions ()
  "Swap the current transaction with the preceding one.
The transactions must have matching dates."
  (interactive "*")
  (let ((start (point)))
    (goto-char (ledger-transaction-start-pos))
    (let* ((trans (ledger-transaction-at-pt))
           (date (ledger-cur-transaction-date))
           (periodic? (ledger-periodic-transaction? trans)))
      (cond
       ((null trans)
        (goto-char start)
        (user-error "Point is not at a valid transaction"))

       ((and (null date) (not periodic?))
        (goto-char start)
        (error "Invalid date for current transaction"))

       ((save-excursion
          (ledger-prev-transaction)
          (equal periodic? (not (ledger-periodic-transaction?
                                 (ledger-transaction-at-pt)))))
        (goto-char start)
        (user-error "Incompatable transaction types"))

       ;; Inspect the preceding transaction to see whether we can transpose.
       ((save-excursion
          (ledger-prev-transaction)
          (equal date (ledger-cur-transaction-date)))

        (unwind-protect
            (atomic-change-group
              (ledger-kill-transaction-at-pt)
              (ledger-prev-transaction)
              (forward-line -1)
              (unless (bobp) (newline))
              (save-excursion
                (insert trans)
                (newline)
                (collapse-vertical-whitespace)))

          (pop kill-ring)))

       (t
        (goto-char start)
        (user-error "Transaction dates do not match"))))))
#+end_src
** Re-ordering transactions
Define commands to move transactions up or down.
*** Impl
#+begin_src emacs-lisp
(defun ledger-move-transaction-up ()
  "Move the current transaction up.
Signal an error of doing so would break date ordering."
  (interactive "*")
  (ledger-transpose-transactions))

(defun ledger-move-transaction-down ()
  "Move the current transaction down.
Signal an error of doing so would break date ordering."
  (interactive "*")
  (let ((pt (point)))
    (unwind-protect
        (progn
          (ledger-next-transaction)
          (ledger-transpose-transactions))
      (goto-char pt))
    (ledger-next-transaction)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "M-<up>") 'ledger-move-transaction-up)
(define-key ledger-mode-map (kbd "M-<down>") 'ledger-move-transaction-down)
#+end_src
** Key bindings
Define key bindings for stock ledger commands.
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "C-c C-c") 'ledger-report)
(define-key ledger-mode-map (kbd "M-RET") 'ledger-toggle-current-transaction)
#+end_src
** Custom reports
Define custom reports.
#+begin_src emacs-lisp
(--each
    '(("net worth" "ledger -f %(ledger-file) bal ^assets ^liabilities")
      ("cash flow" "ledger -f %(ledger-file) bal ^income ^expenses")
      ("week budget"
       "ledger -f %(ledger-file) -p 'this month' --add-budget --weekly reg checking"))
  (add-to-list 'ledger-reports it t))
#+end_src
** Fixes
Modify =ledger-report-payee-format-specifier= to prevent errors passing nil
string to regexp-quote.
#+begin_src emacs-lisp
(defun ledger-report-payee-format-specifier ()
  (let ((payee (ledger-xact-payee)))
    (ledger-read-string-with-default
     "Payee" (when payee (regexp-quote payee)))))
#+end_src
** Font lock
*** Customise existing ledegr faces
#+begin_src emacs-lisp
(set-face-background 'ledger-font-xact-highlight-face nil)
(set-face-foreground 'ledger-font-comment-face
                     (face-foreground 'font-lock-comment-face))
(set-face-foreground 'ledger-font-posting-account-face
                     (face-foreground 'default))

(set-face-foreground 'ledger-font-pending-face solarized-hl-orange)
(set-face-foreground 'ledger-font-payee-cleared-face solarized-hl-green)
(set-face-foreground 'ledger-font-payee-uncleared-face solarized-hl-orange)
#+end_src
*** Define faces for dates
#+begin_src emacs-lisp
(defface ledger-date
  `((t :inherit org-date :underline nil :foreground ,solarized-hl-cyan))
  "Face for dates at start of transactions."
  :group 'ledger-faces)

(defface ledger-periodic-header
  `((t :foreground ,solarized-hl-violet :bold t))
  "Face for the header for periodic transactions."
  :group 'ledger-faces)

(defface ledger-year-line
  `((t :foreground ,solarized-hl-violet))
  "Face for year declarations."
  :group 'ledger-faces)
#+end_src
*** Add font-locking for dates
#+begin_src emacs-lisp
(font-lock-add-keywords
 'ledger-mode
 `((,(rx bol (+ (any digit "=" "/"))) . 'ledger-date)
   (,(rx bol "~" (* nonl)) . 'ledger-periodic-header)
   (,(rx bol "year" (+ space) (+ digit) (* space) eol) . 'ledger-year-line)))
#+end_src
** Flycheck
Use flycheck-ledger.
#+begin_src emacs-lisp
(after 'flycheck
  (cb:install-package 'flycheck-ledger t))
#+end_src
** Hideshow
Add support for hideshow to ledger.
#+begin_src emacs-lisp
(defvar ledger--transaction-start-re (rx bol (any digit "~" "="))
  "Regex matching the start of a transaction line.")

(defun ledger--hs-forward (&optional n)
  "Forward motion command for ledger-mode's hideshow support.
Argument N is provided for compatibility and is not used."
  (forward-line 1)
  (or (when (search-forward-regexp ledger--transaction-start-re nil t)
        (forward-line -1)
        (goto-char (line-end-position))
        t)
      (goto-char (point-max))))

(eval-after-load 'hideshow
  '(add-to-list 'hs-special-modes-alist
                `(ledger-mode
                  ,ledger--transaction-start-re
                  nil
                  nil
                  ledger--hs-forward
                  nil)))

(add-hook 'ledger-mode-hook 'hs-minor-mode)
#+end_src
** Evil
*** Evil motions in ledger reports
#+begin_src emacs-lisp
(evil-define-key 'normal ledger-report-mode-map
  "e" 'ledger-report-edit
  "q" 'ledger-report-kill
  "r" 'ledger-report-redo
  "s" 'ledger-report-save)
#+end_src
*** Enter insert state after inserting a new transaction
#+begin_src emacs-lisp
(add-hook 'ledger-transaction-inserted-hook 'evil-insert-state)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* assembler
** DEFER
#+begin_src emacs-lisp
(after 'asm-mode
#+end_src
** Set tab width
Use wide tab-width for assembler.
#+begin_src emacs-lisp
(put 'asm-mode 'tab-width 8)
#+end_src
** Smart-operator
#+begin_src emacs-lisp
(hook-fn 'asm-mode-hook
  (smart-insert-operator-hook)
  (local-unset-key (kbd "%"))
  (local-unset-key (kbd "-"))
  (local-unset-key (kbd ".")))
#+end_src
** Tab command
Define a context-sensitive tab command.
*** Impl
#+begin_src emacs-lisp
(defun cb:asm-toggling-tab ()
  (interactive)
  (if (equal (line-beginning-position)
             (progn (back-to-indentation) (point)))
      (indent-for-tab-command)
    (indent-to-left-margin)))

(defun cb:asm-tab ()
  "Perform a context-sensitive indentation."
  (interactive)
  (if (s-contains? ":" (thing-at-point 'line))
      (indent-to-left-margin)
    (cb:asm-toggling-tab)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key asm-mode-map (kbd "<tab>") 'cb:asm-tab)
#+end_src
** Colon command
Define a custom colon command.
*** Impl
#+begin_src emacs-lisp
(defun cb:asm-electric-colon ()
  "Insert a colon, indent, then newline."
  (interactive)
  (atomic-change-group
    (unless (thing-at-point-looking-at (rx ":" (* space) eol))
      (insert ":"))
    (cb:asm-tab)
    (newline-and-indent)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key asm-mode-map (kbd ":") 'cb:asm-electric-colon)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* PDF utilities
Define commands to work with PDF files.
#+begin_src emacs-lisp
(require 'cb-file-picker-widget)

(defun pdf-combine ()
  "Concatenate the given PDF files."
  (interactive)
  (file-picker
   "*Select PDFs*"
   :on-accept
   (lambda (pdfs)
     (let ((dest (read-file-name "Destination: " "~/" nil nil ".pdf")))
       (when (zerop (pdf-combine-command dest pdfs))
         (kill-new dest)
         (message "PDF path copied to kill-ring."))))))

(defun pdf-combine-command (destination pdfs)
  "Concatenate the given PDF files and output to DESTINATION."
  (%-sh (format "pdftk %s cat output %s"
                (s-join " " (-map (C %-quote f-expand) pdfs))
                (%-quote (f-expand destination)))))

(cl-defun tiff->pdf (file)
  "Convert the tiff at FILE to PDF. "
  (let* ((dest (concat (f-no-ext file) ".pdf"))
         (cmd (concat "cupsfilter -i image/tiff " (%-quote file) " > " (%-quote dest))))
    (when (zerop (%-sh cmd))
      dest)))
#+end_src
* Scanning
** Single scans
Define a command to scan a single file to disk.
*** utilities
#+begin_src emacs-lisp
(defun cbscan:scan-to-file (colour-mode path)
  "Scan to PATH. Return nil if scanning failed, or PATH if succeeded."
  (when (zerop (%-sh (concat "scanimage"
                             " --mode=" colour-mode
                             " --format=tiff"
                             " > " path)))
    path))

(defun scan-file (colour-mode destination &optional async?)
  "Scan as a TIFF to a temp file, then export to PDF with CUPS.

COLOUR-MODE should be either \"colour\" or \"grayscale\".

The document will be created at DESTINATION.

If ASYNC? is non-nil, the scan will be performed in the background."
  (save-window-excursion
    (let* ((tmpfile (make-temp-file "scan--" nil ".tiff"))
           (command (concat "scanimage"
                            " --mode=" colour-mode
                            " --format=tiff"
                            " > " tmpfile
                            " && cupsfilter -D -i image/tiff " tmpfile
                            " > " (%-quote (f-expand destination)))))
      (cond (async? (%-async command))
            ((zerop (%-sh command))
             destination)))))
#+end_src
*** impl
#+begin_src emacs-lisp
(defun scan (colour-mode destination)
  "Scan using the default scanner to a PDF file.

COLOUR-MODE should be either \"colour\" or \"grayscale\".

The document will be created at DESTINATION."
  (interactive
   (list
    (ido-completing-read "Mode: " '("Colour" "Grayscale"))
    (read-file-name "Destination: " "~/" nil nil ".pdf")))

  (scan-file colour-mode destination 'async)
  (kill-new destination)
  (message "Scan started. Destination path copied to kill-ring."))
#+end_src
** Batch scanning
#+begin_src emacs-lisp
(defun scan-batch-to-file (colour-mode destination)
  "Scan several files from the document feeder then export to a single PDF.
The args COLOUR-MODE and DESTINATION are the same as for `scan-file'."
  (interactive
   (list
    (ido-completing-read "Mode: " '("Colour" "Grayscale"))
    (read-file-name "Destination: " "~/" nil nil ".pdf")))

  (read-char-choice "Press <return> to start." (list ?\^M))
  (let (pdfs)
    ;; Scan PDFs in flatbed.
    (save-window-excursion
      (let ((tmpdir (make-temp-file "scan-" t)))

        ;; Scan with document feeder.
        (unless (zerop (%-sh (concat "scanimage"
                                     " --mode=" colour-mode
                                     " --format=tiff"
                                     " --batch=" (f-join tmpdir "scan--%d.tiff"))))
          (error "Scanning failed"))
        (let ((pdfs)))
        ;; Export files to PDFs.
        (unless (->> (f-files tmpdir)

                  (--map (%-sh "cupsfilter -D -i image/tiff" (%-quote it)
                               ">" (%-quote (concat it ".pdf"))))
                  (-all? 'zerop))
          (error "PDF export failed"))
        ;; Combine PDFs.
        (unless (zerop (pdf-combine-command destination (f-files tmpdir)))
          (error "PDF combination failed"))))

    (kill-new destination)
    (message "PDF path copied to kill-ring.")))
#+end_src
** Combined scanning
Define a function for scanning multiple docmunts and combining them to a single
PDF.
*** Utils
#+begin_src emacs-lisp
(defun cbscan:read-continue? ()
  "Prompt the user whether to continue scanning."
  (equal ?\^M (read-char-choice "Press <return> to scan or C-d to finish."
                                (list ?\^M ?\^D))))
#+end_src
*** Impl
#+begin_src emacs-lisp
(defun scan-then-combine (colour-mode destination)
  "Scan several documents on the flatbed, then combine to a single PDF.

COLOUR-MODE should be either \"colour\" or \"grayscale\".

The document will be created at DESTINATION."
  (interactive
   (list
    (ido-completing-read "Mode: " '("Colour" "Grayscale"))
    (read-file-name "Destination: " "~/" nil nil ".pdf")))

  (save-window-excursion
    (let ((tmpdir (make-temp-file "scan-" t))
          (n 1))
      ;; Scan PDFs in flatbed.
      (while (cbscan:read-continue?)
        (message "Scanning...")
        (if (cbscan:scan-to-file colour-mode (f-join tmpdir (format "%03i.tiff" n)))
            (cl-incf n)
          (or (y-or-n-p "Scan failed.  Try again? ")
              (error "Scanning failed"))))

      ;; Export files to PDFs.
      (let ((pdfs (-map 'tiff->pdf (f-files tmpdir))))
        (when (-any? 'null pdfs)
          (error "PDF export failed"))

        ;; Combine PDFs.
        (unless (zerop (pdf-combine-command destination pdfs))
          (error "PDF combination failed"))

        (f-delete tmpdir 'force)

        (when (called-interactively-p nil)
          (kill-new destination)
          (message "%s page(s) scanned. PDF path copied to kill-ring." (length pdfs)))

        destination))))
#+end_src
** Org
Define a command to scan and attach documents to the subtree at point.
#+begin_src emacs-lisp
(defun org-attach-from-scanner (colour-mode)
  "Scan a document and attach it to the current org heading.

- COLOUR-MODE is either \"colour\" or \"grayscale\"."
  (interactive (list (ido-completing-read "Mode: " '("Colour" "Grayscale"))))
  (let ((file (scan-then-combine colour-mode (make-temp-file "scan--"))))
    (org-attach-attach file nil 'mv))

  (message "Scanning...Done"))
#+end_src

** Command picker
Define a command picker for printer and scanner functions.
*** Impl
#+begin_src emacs-lisp
(define-command-picker printer-scanner-picker
  :title
  "*Print/Scan*"
  :options
  '(("p" "Print Buffer" print-buffer)
    ("r" "Print Region" print-region)
    ("s" "Scan (flatbed)" scan)
    ("m" "Scan Multiple & Combine (flatbed)" scan-then-combine)
    ("u" "Scan (document feeder)" scan-batch-to-file)
    ("a" "Scan and Attach (org)" org-attach-from-scanner
     :when (lambda () (derived-mode-p 'org-mode)))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(bind-key* "<f10>" 'printer-scanner-picker)
#+end_src

* JSON
#+begin_src emacs-lisp
(cb:install-package 'json-mode)
#+end_src
** Define key command to format buffer
#+begin_src emacs-lisp
(after 'json-mode
  (define-key json-mode-map (kbd "M-q") 'json-mode-beautify))
#+end_src
** auto-complete
#+begin_src emacs-lisp
(add-to-list 'ac-modes 'json-mode)
#+end_src
* fsharp-mode
#+begin_src emacs-lisp
(cb:install-package 'fsharp-mode)
#+end_src
** auto-complete
#+begin_src emacs-lisp
(after 'auto-complete
  (add-to-list 'ac-modes 'fsharp-mode))
#+end_src
** Do not show ac popup in terminal
#+begin_src emacs-lisp
(unless (display-graphic-p)
  (setq fsharp-ac-use-popup nil))
#+end_src
* SML
#+begin_src emacs-lisp
(cb:install-package 'sml-mode)
#+end_src
** Customise variables
#+begin_src emacs-lisp
(setq sml-indent-level 2)
#+end_src
** Ignore compiled ML files
#+begin_src emacs-lisp
(add-to-list 'completion-ignored-extensions "\\.cm")
(add-to-list 'completion-ignored-extensions "\\.CM")
#+end_src
* XML
Enable nxml-mode if when visiting a file with a DTD.
#+begin_src emacs-lisp
(hook-fn 'find-file-hook
  (when (s-starts-with? "<?xml " (buffer-string))
    (nxml-mode)))
#+end_src
** Formatting
Define a command to reformat the current XML buffer.

#+begin_src emacs-lisp
(defun tidy-xml-buffer ()
  "Reformat the current XML buffer using Tidy."
  (interactive)
  (save-excursion
    (call-process-region (point-min) (point-max) "tidy" t t nil
                         "-xml" "-i" "-wrap" "0" "-omit" "-q")))
#+end_src

Set a key binding for the above command.

#+begin_src emacs-lisp
(after 'nxml-mode
  (define-key nxml-mode-map (kbd "M-q") 'tidy-xml-buffer))
#+end_src

* SGML
#+begin_src emacs-lisp
(setq-default sgml-xml-mode t)
#+end_src

#+begin_src emacs-lisp
(after 'sgml-mode
  (define-key sgml-mode-map (kbd "M-q") 'tidy-xml-buffer))
#+end_src
* Markdown
#+begin_src emacs-lisp
(cb:install-package 'markdown-mode)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'markdown-mode
#+end_src
** Imenu
#+begin_src emacs-lisp
(put 'markdown-mode 'imenu-generic-expression
     '(("title"  "^\\(.*\\)[\n]=+$" 1)
       ("h2-"    "^\\(.*\\)[\n]-+$" 1)
       ("h1"   "^# \\(.*\\)$" 1)
       ("h2"   "^## \\(.*\\)$" 1)
       ("h3"   "^### \\(.*\\)$" 1)
       ("h4"   "^#### \\(.*\\)$" 1)
       ("h5"   "^##### \\(.*\\)$" 1)
       ("h6"   "^###### \\(.*\\)$" 1)
       ("fn"   "^\\[\\^\\(.*\\)\\]" 1)))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (sp-with-modes '(markdown-mode)
    (sp-local-pair "```" "```")))
#+end_src
** Faces
#+begin_src emacs-lisp
(set-face-attribute markdown-header-face-1 nil :height 1.3)
(set-face-attribute markdown-header-face-2 nil :height 1.1)
#+end_src
** Evil
Define keys to move by headlines in normal state.
#+begin_src emacs-lisp
(after 'evil
  (evil-define-key 'normal markdown-mode-map
    (kbd "M-P") 'outline-previous-visible-heading
    (kbd "M-N") 'outline-next-visible-heading))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* C
** DEFER
#+begin_src emacs-lisp
(after 'cc-mode
#+end_src
** Use clang as c compiler
#+begin_src emacs-lisp
(when (executable-find "clang")
  (setq cc-compilers-list (list "clang")
        cc-default-compiler "clang"
        cc-default-compiler-options "-fno-color-diagnostics -g"))
#+end_src
** Key bindings
#+begin_src emacs-lisp
(define-key c-mode-map (kbd "M-q") 'indent-dwim)
#+end_src
** Insert headers
#+begin_src emacs-lisp
(after 'emr

  (defun helm-insert-c-header ()
    (interactive)
    (helm :sources
          `((name . "C Headers")
            (candidates . ,(-concat emr-c:standard-headers
                                    (emr-c:headers-in-project)))
            (action .
                    (lambda (c)
                      (emr-c-insert-include
                       (format (if (-contains? emr-c:standard-headers c)
                                   "<%s>"
                                 "\"%s\"")
                               c))))
            (volatile))
          :prompt "Header: "
          :buffer "*Helm C Headers*"))

  (add-to-list 'insertion-picker-options
               '("i" "Header Include" helm-insert-c-header
                 :modes (c-mode c++-mode))))
#+end_src
** Switch between header and impl
Define a command to switch between header file and implementation.
*** Impl
#+begin_src emacs-lisp
(defun cb-c:switch-between-header-and-impl ()
  "Switch between a header file and its implementation."
  (interactive)
  (let ((sans (file-name-sans-extension (buffer-file-name)))
        (ext  (file-name-extension (buffer-file-name))))
    (if (equal "h" ext)
        (find-file (concat sans ".c"))
      (find-file (concat sans ".h")))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key c-mode-map (kbd "C-c C-j") 'cb-c:switch-between-header-and-impl)
#+end_src
** Utility functions
Define functions used to parse the context around point.
#+begin_src emacs-lisp
(defun cb-c:looking-at-flow-control-header? ()
  (thing-at-point-looking-at
   (rx (* nonl) (? ";") (* space)
       (or "if" "when" "while" "for")
       (* nonl)
       "("
       (* (not (any ")"))))))

(defun cb-c:looking-at-flow-control-keyword? ()
  (thing-at-point-looking-at
   (rx (or (group (or "if" "when" "while" "for") (or (+ space) "("))
           (group (or "do" "else") (* space))))))

(defun cb-c:looking-at-assignment-right-side? ()
  (save-excursion
    (thing-at-point-looking-at
     (rx "=" (* space)
         ;; Optional casts
         (? (group "(" (* nonl) ")"))
         (* space)))))

(defun cb-c:looking-at-cast? ()
  (let ((cast (rx

               (or
                "return"
                (any
                 ;; Operator
                 "+" "-" "*" "/" "|" "&" ">" "<"
                 ;; Expression delimiter
                 ";" "[" "{" "(" ")" "="))

               (* space)

               ;; Cast and type
               "(" (* nonl) ")"

               (* space)))
        )
    (and (thing-at-point-looking-at cast)
         (save-excursion
           (search-backward-regexp cast)
           (not (cb-c:looking-at-flow-control-keyword?))))))

(defun cb-c:looking-at-struct-keyword? ()
  (save-excursion
    (beginning-of-sexp)
    (thing-at-point-looking-at (rx (or "{" " " "(" ",") "."))))
#+end_src
** Smart operators
Add special smart ops for C/C++.
*** Utilities
#+begin_src emacs-lisp
(defun c-insert-smart-op (str)
  "Insert a smart operator with special formatting in certain expressions."
  (if (cb-c:looking-at-flow-control-header?)
      (insert str)
    (smart-insert-operator str)))

(defun cb-c:maybe-remove-spaces-after-insertion (pred-regex op-start-regex)
  (when (thing-at-point-looking-at pred-regex)
    (save-excursion
      (let ((back-limit (save-excursion
                          (search-backward-regexp op-start-regex)
                          (point))))
        (while (search-backward-regexp (rx space) back-limit t)
          (delete-horizontal-space)))
      (indent-according-to-mode))))

(defun cb-c:just-one-space-after-semicolon ()
  (save-excursion
    (when (search-backward-regexp (rx ";" (* space)) (line-beginning-position) t)
      (replace-match "; " nil))))

#+end_src
*** Definitions
#+begin_src emacs-lisp
(defun c-insert-smart-equals ()
  "Insert an '=' with context-sensitive formatting."
  (interactive)
  (if (or (cb-c:looking-at-flow-control-header?)
          (cb-c:looking-at-struct-keyword?))
      (insert "=")
    (smart-insert-operator "=")))

(defun c-insert-smart-star ()
  "Insert a * with padding in multiplication contexts."
  (interactive)
  (cond
   ((s-matches? (rx bol (* space) eol)
                (buffer-substring (line-beginning-position) (point)))
    (indent-according-to-mode)
    (insert "*"))
   ((thing-at-point-looking-at (rx (any "(" "{" "[") (* space)))
    (insert "*"))
   ((thing-at-point-looking-at (rx (any digit "*") (* space)))
    (smart-insert-operator "*"))
   (t
    (just-one-space)
    (insert "*"))))

(defun c-insert-smart-minus ()
  "Insert a minus with padding unless a unary minus is more appropriate."
  (interactive)
  (atomic-change-group
    ;; Handle formatting for unary minus.
    (if (thing-at-point-looking-at
         (rx (or "return" "," "(" "[" "(" ";" "=") (* space)))
        (insert "-")
      (c-insert-smart-op "-"))
    ;; Collapse whitespace for decrement operator.
    (cb-c:maybe-remove-spaces-after-insertion
     (rx "-" (* space) "-" (* space))
     (rx (not (any "-" space))))
    (cb-c:just-one-space-after-semicolon)))

(defun c-insert-smart-gt ()
  "Insert a > symbol with formatting.
If the insertion creates an right arrow (->), remove surrounding whitespace."
  (interactive)
  (c-insert-smart-op ">")
  (cb-c:maybe-remove-spaces-after-insertion
   (rx "-" (* space) ">" (* space))
   (rx (not (any space "-" ">")))))

(defun c-insert-smart-plus ()
  "Insert a + symbol with formatting.
Remove horizontal whitespace if the insertion results in a ++."
  (interactive)
  (c-insert-smart-op "+")
  (cb-c:maybe-remove-spaces-after-insertion
   (rx "+" (* space) "+" (* space))
   (rx (not (any space "+"))))
  (cb-c:just-one-space-after-semicolon))

#+end_src
*** Set bindings
#+begin_src emacs-lisp
(define-key c-mode-map (kbd ",") 'cb:comma-then-space)
(define-key c-mode-map (kbd "=") 'c-insert-smart-equals)
(define-key c-mode-map (kbd "|") (smart-op "|"))
(define-key c-mode-map (kbd "?") (smart-op "?"))
(define-key c-mode-map (kbd ":") (smart-op ":"))
(define-key c-mode-map (kbd "+") 'c-insert-smart-plus)
(define-key c-mode-map (kbd ">") 'c-insert-smart-gt)
(define-key c-mode-map (kbd "-") 'c-insert-smart-minus)
(define-key c-mode-map (kbd "*") 'c-insert-smart-star)
#+end_src
** Smartparens
Automatically format curly braces on insertion.
*** Define commands
#+begin_src emacs-lisp
(defun cb-c:format-after-brace (_id action contexxt)
  "Apply formatting after a brace insertion."
  (when (and (equal action 'insert)
             (equal context 'code)
             (save-excursion
               ;; Search backward for flow control keywords.
               (search-backward "{")
               (or (thing-at-point-looking-at
                    (rx symbol-start (or "else" "do")))
                   (progn
                     (sp-previous-sexp)
                     (thing-at-point-looking-at
                      (rx symbol-start (or "if" "for" "while")))))))
    ;; Insert a space for padding.
    (save-excursion
      (search-backward "{")
      (just-one-space))
    ;; Put braces on new line.
    (newline)
    (save-excursion (newline-and-indent))
    (c-indent-line)))

(defun cb-c:format-after-paren (_id action context)
  "Insert a space after flow control keywords."
  (when (and (equal action 'insert)
             (equal context 'code)
             (save-excursion
               (search-backward "(")
               (thing-at-point-looking-at
                (rx symbol-start (or "=" "return" "if" "while" "for")
                    (* space)))))
    (save-excursion
      (search-backward "(")
      (just-one-space))))
#+end_src
*** Register with smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (sp-with-modes '(c-mode cc-mode c++-mode)
    (sp-local-pair "{" "}" :post-handlers '(:add cb-c:format-after-brace))
    (sp-local-pair "(" ")" :post-handlers '(:add cb-c:format-after-paren))))
#+end_src
** Flyspell
Do not parse include directives for spelling errors.
#+begin_src emacs-lisp
(defun cbclang:flyspell-verify ()
  (not (s-matches? (rx bol (* space) "#include ") (current-line))))

(hook-fns '(c-mode-hook c++-mode-hook)
  (setq-local flyspell-generic-check-word-predicate 'cbclang:flyspell-verify))
#+end_src
** Fixes
Ignore errors thrown by internals.
#+begin_src emacs-lisp
(defadvice c-inside-bracelist-p (around ignore-errors activate)
  (ignore-errors ad-do-it))
#+end_src
** auto-complete
#+begin_src emacs-lisp
(cb:install-package 'ac-c-headers)
(cb:install-package 'auto-complete-clang-async)
#+end_src
*** Set sources
#+begin_src emacs-lisp
(put 'cc-mode 'ac-sources
     '(ac-source-clang-async
       ac-source-yasnippet
       ac-source-c-headers
       ac-source-c-header-symbols
       ac-source-words-in-buffer))
#+end_src
*** Configure faces
#+begin_src emacs-lisp
(after 'auto-complete
  (copy-face 'ac-candidate-face 'ac-clang-candidate-face)
  (copy-face 'ac-selection-face 'ac-clang-selection-face))
#+end_src
** eldoc
#+begin_src emacs-lisp
(cb:install-package 'c-eldoc)
(add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Lisp
#+begin_src emacs-lisp
(hook-fn 'cb:lisp-modes-hook
  (local-set-key (kbd "M-q") 'indent-dwim))
#+end_src
** smartparens
Configure special paren formatting behaviours for lisp modes.
*** Reformat on close paren
Add lisp modes to =sp-navigate-reindent-after-up=. Provides Paredit-style paren
reindentation when closing parens.
#+begin_src emacs-lisp
(let ((ls (assoc 'interactive sp-navigate-reindent-after-up)))
  (setcdr ls (-uniq (-concat (cdr ls) cb:lisp-modes))))
#+end_src
*** Pad with spaces
Pad parens and other delimiters with spaces to emulate paredit's behaviour.
**** Define helper functions
#+begin_src emacs-lisp
(defun cblisp:just-inserted-double-quotes? (id action ctx)
  (and (sp-in-string-p id action ctx)
       (s-matches? (rx (not (any "\\")) "\"" eol)
                   (buffer-substring (line-beginning-position) (point)))))

(defun sp-lisp-just-one-space (id action ctx)
  "Pad LISP delimiters with spaces."
  (when (and (equal 'insert action)
             (or (sp-in-code-p id action ctx)
                 (cblisp:just-inserted-double-quotes? id action ctx)))
    ;; Insert a leading space, unless
    ;; 1. this is a quoted form
    ;; 2. this is the first position of another list
    ;; 3. this form begins a new line.
    (save-excursion
      (search-backward id)
      (unless (s-matches?
               (rx (or (group bol (* space))
                       (any "," "`" "'" "@" "#" "~" "(" "[" "{")
                       ;; HACK: nREPL prompt
                       (and (any alnum "." "/" "-") ">" (* space)))
                   eol)
               (buffer-substring (line-beginning-position) (point)))
        (just-one-space)))
    ;; Insert space after separator, unless
    ;; 1. this form is at the end of another list.
    ;; 2. this form is at the end of the line.
    (save-excursion
      (search-forward (sp-get-pair id :close))
      (unless (s-matches? (rx (or (any ")" "]" "}")
                                  eol))
                          (buffer-substring (point) (1+ (point))))
        (just-one-space)))))
#+end_src
**** Register with smartparens
#+begin_src emacs-lisp
(sp-with-modes cb:lisp-modes
  (sp-local-pair "\"" "\"" :post-handlers '(:add sp-lisp-just-one-space))
  (sp-local-pair "{" "}" :post-handlers '(:add sp-lisp-just-one-space))
  (sp-local-pair "[" "]" :post-handlers '(:add sp-lisp-just-one-space))
  (sp-local-pair "(" ")" :post-handlers '(:add sp-lisp-just-one-space))
  (sp-local-pair "'" nil :actions nil))
#+end_src
** parenface-plus
Adds a face for parentheses. Use to dim parens.
#+begin_src emacs-lisp
(cb:install-package 'parenface-plus t)
#+end_src
** eval-sexp-fu
Adds a flash when running eval-expression.
#+begin_src emacs-lisp
(cb:install-package 'highlight)
(require 'eval-sexp-fu)
(add-hook 'cb:lisp-modes-hook 'turn-on-eval-sexp-fu-flash-mode)
(setq eval-sexp-fu-flash-duration 0.2)
#+end_src
** slime
Adds support for inferior Common Lisp processes.
#+begin_src emacs-lisp
(cb:install-package 'slime)
(setq slime-lisp-implementations `((lisp ("sbcl" "--noinform"))))
#+end_src
*** Define a command to interactively run SLIME
#+begin_src emacs-lisp
(defun run-slime ()
  "Run slime, prompting for a lisp implementation."
  (interactive)
  (let ((current-prefix-arg '-))
    (slime)))
#+end_src
** ac-slime
Adds an auto-complete source for slime.
#+begin_src emacs-lisp
(cb:install-package 'ac-slime)
(add-hook 'slime-modes-hook 'set-up-slime-ac)
(add-to-list 'ac-modes 'slime-repl-mode)
#+end_src
** eldoc
Shows documentation hints in the minibuffer.
*** Enable for all Lisps
#+begin_src emacs-lisp
(add-hook 'cb:lisp-modes-hook 'turn-on-eldoc-mode)
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'eldoc-mode-hook
  (diminish 'eldoc-mode))
#+end_src
** Redshank
Provides refactoring commands for lisps.
#+begin_src emacs-lisp
(cb:install-package 'redshank)
#+end_src
*** Enable for all Lisps
#+begin_src emacs-lisp
(add-hook 'cb:lisp-modes-hook 'turn-on-redshank-mode)
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'redshank-mode-hook
  (diminish 'redshank-mode))
#+end_src
* Elisp
** auto-mode-alist
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("Cask$" . emacs-lisp-mode))
(add-to-list 'auto-mode-alist '("Carton" . emacs-lisp-mode))
#+end_src
** flycheck
Add the lib-dir to the elisp checker path.

#+begin_src emacs-lisp
(setq-default flycheck-emacs-lisp-load-path (list cb:lib-dir "./"))
#+end_src

Given a function that tests whether the current buffer is a 'special'
(non-source) elisp buffer,

#+begin_src emacs-lisp
(defun cb:special-elisp-buffer? ()
  (and (derived-mode-p 'emacs-lisp-mode)
       (or
        (true? scratch-buffer)
        (s-ends-with? "-steps.el" (buffer-name))
        (s-matches? (rx bol (? (any "*" "."))
                        (or "org-"
                            "Org "
                            "Cask"
                            "Carton"
                            "scratch"
                            "emacs-lisp"
                            "autoloads"
                            (group "-pkg.el")
                            (group "Pp" (* anything) "Output")
                            "dir-locals"))
                    (buffer-name)))))
#+end_src

prevent flycheck from running checkdoc for certain elisp file types or when the
buffer is narrowed.

#+begin_src emacs-lisp
(defun cbel:configure-flycheck ()
  (when (and (derived-mode-p 'emacs-lisp-mode)
             (or (cb:special-elisp-buffer?) (buffer-narrowed-p)))
    (ignore-errors
      (flycheck-select-checker 'emacs-lisp))))

(add-hook 'flycheck-mode-hook 'cbel:configure-flycheck)
#+end_src
** smartparens
Reserve backtick pair handling hyperlinks.
#+begin_src emacs-lisp
(sp-local-pair (-difference cb:lisp-modes cb:elisp-modes)
               "`" "`" :when '(sp-in-string-p))
#+end_src
** auto-complete
#+begin_src emacs-lisp
(after 'auto-complete
  (-each cb:lisp-modes (~ add-to-list 'ac-modes))
  (hook-fn 'ielm-mode-hook
    (auto-complete-mode +1)
    (setq ac-sources '(ac-source-features ac-source-functions
                       ac-source-yasnippet ac-source-variables
                       ac-source-symbols))))
#+end_src
** Search methods
Add elisp functions to global search picker.
#+begin_src emacs-lisp
(cbs-define-search-method
 :name "Apropos"
 :key "a"
 :command
 (lambda (_)
   (call-interactively 'helm-apropos))
 :when
 (lambda ()
   (apply 'derived-mode-p cb:elisp-modes)))
#+end_src
** Yasnippet
Define auxiliary functions for snippets.
#+begin_src emacs-lisp
(defun cbel:find-identifier-prefix ()
    "Find the commonest identifier prefix in use in this buffer."
    (let ((ns-separators (rx (or ":" "--" "/"))))
      (->> (buffer-string)
        ;; Extract the identifiers from declarations.
        (s-match-strings-all
         (rx bol (* space)
             "(" (? "cl-") (or "defun" "defmacro" "defvar" "defconst")
             (+ space)
             (group (+ (not space)))))
        ;; Find the commonest prefix.
        (-map 'cadr)
        (-filter (~ s-matches? ns-separators))
        (-map (C car (~ s-match (rx (group (* nonl) (or ":" "--" "/"))))))
        (-group-by 'identity)
        (-max-by (-on '>= 'length))
        (car))))

  (defun cbel:find-group-for-snippet ()
    "Find the first group defined in the current file,
falling back to the file name sans extension."
    (or
     (cadr (s-match (rx "(defgroup" (+ space) (group (+ (not
     space))))
                    (buffer-string)))
     (cadr (s-match (rx ":group" (+ space) "'" (group (+ (any "-" alnum))))
                    (buffer-string)))
     (f-no-ext (f-filename buffer-file-name))))

  (define-obsolete-function-alias 'cbel:bol-for-snippet? 'cbyas:bol?)

  (defun cbel:simplify-arglist (text)
    "Return a simplified docstring of arglist TEXT."
    (->> (ignore-errors
           (read (format "(%s)" text)))
      (--keep
       (ignore-errors
         (cond
          ((listp it)
           (-first (& symbolp (C (N (~ s-starts-with? "&")) symbol-name))
                   it))
          ((symbolp it) it))))
      (-remove (C (~ s-starts-with? "&") symbol-name))))

  (defun cbel:cl-arglist? (text)
    "Non-nil if TEXT is a Common Lisp arglist."
    (let ((al (ignore-errors (read (format "(%s)" text)))))
      (or (-any? 'listp al)
          (-intersection al '(&key &allow-other-keys &body)))))

  (defun cbel:defun-form-for-arglist (text)
    "Return either 'defun or 'cl-defun depending on whether TEXT
is a Common Lisp arglist."
    (if (cbel:cl-arglist? text) 'cl-defun 'defun))

  (defun cbel:defmacro-form-for-arglist (text)
    "Return either 'defmacro or 'cl-defmacro depending on whether TEXT
is a Common Lisp arglist."
    (if (cbel:cl-arglist? text) 'cl-defmacro 'defmacro))

  (defun cbel:process-docstring (text)
    "Format a function docstring for a snippet.
TEXT is the content of the docstring."
    (let ((docs (->> (cbel:simplify-arglist text)
                  (-map (C s-upcase symbol-name))
                  (s-join "\n\n"))))
      (unless (s-blank? docs)
        (concat "\n\n" docs))))
#+end_src
** Paredit in eval-expression
Enable Paredit during eval-expression.
#+begin_src emacs-lisp
(hook-fn 'minibuffer-setup-hook
  (when (equal this-command 'eval-expression)
    (paredit-mode +1)))
#+end_src
** elisp-slime-nav
Defines a command for going to the definition of the symbol at point.
#+begin_src emacs-lisp
(cb:install-package 'elisp-slime-nav)
#+end_src
*** Bind to M-. for all elisp modes
#+begin_src emacs-lisp
(hook-fn 'cb:elisp-modes-hook
  (elisp-slime-nav-mode +1)
  (local-set-key (kbd "M-.") 'elisp-slime-nav-find-elisp-thing-at-point)

  ;; Make M-. work in normal state.
  (after 'evil
    (evil-local-set-key 'normal (kbd "M-.")
                        'elisp-slime-nav-find-elisp-thing-at-point)))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'elisp-slime-nav-mode-hook
  (diminish 'elisp-slime-nav-mode))
#+end_src
** litable
#+begin_src emacs-lisp
(cb:install-package 'litable)
#+end_src
** cl-lib-highlight
#+begin_src emacs-lisp
(cb:install-package 'cl-lib-highlight)
(hook-fn 'emacs-lisp-mode
  (cl-lib-highlight-initialize)
  (cl-lib-highlight-warn-cl-initialize))
#+end_src
** Key bindings
#+begin_src emacs-lisp
(after 'lisp-mode
  (define-key emacs-lisp-mode-map (kbd "C-c C-t") 'ert)
  (define-key emacs-lisp-mode-map (kbd "C-c C-l")
    'emacs-lisp-byte-compile-and-load))
#+end_src
** IELM
Customise newline key bindings.
#+begin_src emacs-lisp
(after 'ielm
  (define-keys ielm-map
    "M-RET" 'newline-and-indent
    "C-j" 'newline-and-indent))
#+end_src
*** switching to IELM
Define commands to switch between IELM and elisp buffers.
**** Impl
#+begin_src emacs-lisp
(defun switch-to-ielm ()
  "Start up or switch to an Inferior Emacs Lisp buffer."
  (interactive)
  ;; HACK: rebind switch-to-buffer so ielm opens in another window.
  (noflet ((switch-to-buffer (buf) (switch-to-buffer-other-window buf)))
    (ielm)
    (cb:append-buffer)))

(defun switch-to-elisp ()
  "Switch to the last active elisp buffer."
  (interactive)
  (-when-let (buf (--first-buffer (derived-mode-p 'emacs-lisp-mode)))
    (switch-to-buffer-other-window buf)))
#+end_src
**** Key bindings
#+begin_src emacs-lisp
(after 'lisp-mode
  (define-key emacs-lisp-mode-map (kbd "C-c C-z") 'switch-to-ielm))
(after 'ielm
  (define-key ielm-map (kbd "C-c C-z") 'switch-to-elisp))
#+end_src
*** Eval in IELM
Define commands to eval the expression at point in IELM.
**** Impl
#+begin_src emacs-lisp
(defun send-to-ielm ()
  "Send the sexp at point to IELM"
  (interactive)
  (sp-kill-sexp nil 'yank)
  (unwind-protect
      (progn (switch-to-ielm)
             (delete-region (save-excursion
                              (search-backward-regexp (rx bol "ELISP>"))
                              (search-forward "> ")
                              (point))
                            (line-end-position))
             (yank))
    (setq kill-ring (cdr kill-ring))))

(defun eval-in-ielm ()
  "Eval the sexp at point in ielm."
  (interactive)
  (send-to-ielm)
  (ielm-return)
  (recenter -1)
  (switch-to-elisp))
#+end_src
**** Key bindings
#+begin_src emacs-lisp
(after 'lisp-mode
  (define-keys emacs-lisp-mode-map
    "C-c C-e" 'send-to-ielm
    "C-c RET" 'eval-in-ielm))
#+end_src
*** Evil
Add evil documentation lookup for elisp.
#+begin_src emacs-lisp
(after 'evil
  (define-evil-doc-handler cb:elisp-modes
    (let ((sym (symbol-at-point)))
      (cond
       ((symbol-function sym)
        (describe-function sym))
       ((and (boundp sym) (not (facep sym)))
        (describe-variable sym))
       ((facep sym)
        (describe-face sym))
       (t
        (user-error "No documentation available"))))))
#+end_src
*** smartparens
#+begin_src emacs-lisp
(add-hook 'ielm-mode-hook 'smartparens-strict-mode)
#+end_src
*** hideshow
Configure hideshow for IELM.

#+begin_src emacs-lisp
(after 'hideshow
  (add-to-list 'hs-special-modes-alist
               '(inferior-emacs-lisp-mode "(" ")" ";.*$" nil nil)))

(add-hook 'ielm-mode-hook 'hs-minor-mode)
#+end_src

Configure comment syntax for IELM, which is needed by hideshow.

#+begin_src emacs-lisp
(put 'ielm-mode 'comment-start ";")
#+end_src
** Evaluation
*** Set key bindings for common eval commands
#+begin_src emacs-lisp
(after 'lisp-mode
  (define-key emacs-lisp-mode-map (kbd "C-c C-f") 'eval-buffer)
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
  (define-key emacs-lisp-mode-map (kbd "C-c C-r") 'eval-region))
#+end_src
*** Advise eval functions to report when evaluation was successful
#+begin_src emacs-lisp
(defadvice eval-region (after region-evaluated-message activate)
  (when (called-interactively-p nil)
    (message "Region evaluated.")))

(defadvice eval-buffer (after buffer-evaluated-feedback activate)
  (when (called-interactively-p nil)
    (message "Buffer evaluated.")))
#+end_src
** Save behaviour
Byte-compile and check parens on save, unless this is a special buffer.
#+begin_src emacs-lisp
(defun cbel:after-save ()
  (check-parens)
  (unless no-byte-compile
    (byte-compile-file (buffer-file-name))))

(hook-fn 'emacs-lisp-mode-hook
  (when (cb:special-elisp-buffer?) (setq-local no-byte-compile t))
  (add-hook 'after-save-hook 'cbel:after-save nil t))
#+end_src
** Font locking
*** Add font locking for dash.el functions
#+begin_src emacs-lisp
(dash-enable-font-lock)
#+end_src
*** Highlight Common Lisp keywords
#+begin_src emacs-lisp
(--each cb:elisp-modes
  (font-lock-add-keywords
   it
   `(
     ;; General keywords
     (,(rx "(" (group (or "cl-destructuring-bind"
                          "cl-case")
                      symbol-end))
      (1 font-lock-keyword-face))
     ;; Macros and functions
     (,(rx bol (* space) "("
           (group-n 1 (or "cl-defun" "cl-defmacro"
                          "cl-defstruct"
                          "cl-defsubst"
                          "cl-deftype"))
           (+ space)
           (group-n 2 (+? anything) symbol-end))
      (1 font-lock-keyword-face)
      (2 font-lock-function-name-face)))))
#+end_src
*** Add miscellaneous font locking
#+begin_src emacs-lisp
(--each cb:elisp-modes
  (font-lock-add-keywords
   it
   `(
     ;; General keywords
     (,(rx "(" (group (or "until"
                          "hook-fn"
                          "hook-fns"
                          "lambda+"
                          "after"
                          "noflet"
                          "ac-define-source"
                          "evil-global-set-keys"
                          "flycheck-declare-checker"
                          "flycheck-define-checker")
                      symbol-end))
      (1 font-lock-keyword-face))

     ;; definition forms
     (,(rx bol (* space) "("
           (group-n 1
                    symbol-start
                    (* (not space))
                    (or "declare" "define" "extend" "gentest")
                    (+ (not space))
                    symbol-end)
           (+ space)
           (group-n 2 (+ (regex "\[^ )\n\]"))
                    symbol-end))
      (1 font-lock-keyword-face)
      (2 font-lock-function-name-face)))))
#+end_src

#+RESULTS:

* Clojure
** clojure-mode
Provides a major mode for editing Clojure files.
#+begin_src emacs-lisp
(cb:install-package 'clojure-mode)
#+end_src

#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook 'subword-mode)
#+end_src
** documentation
Add evil documentation lookup for Clojure.
#+begin_src emacs-lisp
(after 'evil
  (define-evil-doc-handler cb:clojure-modes (call-interactively 'cider-doc)))
#+end_src
** cider
Provides a Clojure IDE and REPL for Emacs, built on top of nREPL.
#+begin_src emacs-lisp
(cb:install-package 'cider)
#+end_src

#+begin_src emacs-lisp
(setq cider-popup-stacktraces    nil
      nrepl-hide-special-buffers t)
#+end_src

*** Switch to cider repl
#+begin_src emacs-lisp
(defun cb:switch-to-cider ()
  "Start cider or switch to an existing cider buffer."
  (interactive)
  (-if-let (buf (get-buffer "*cider*"))
      (cider-switch-to-repl-buffer buf)
    (cider-jack-in)))

(after 'clojure-mode
  (define-key clojure-mode-map (kbd "C-c C-z") 'cb:switch-to-cider))
#+end_src
*** DEFER
#+begin_src emacs-lisp
(after 'cider
#+end_src
*** Documentation
#+begin_src emacs-lisp
(define-key clojure-mode-map (kbd "C-c C-h") 'cider-doc)
#+end_src

Use help-mode as the major-mode for cider popup buffers.

#+begin_src emacs-lisp
(defadvice cider-popup-buffer-display (after set-mode activate)
  (with-current-buffer (ad-get-arg 0)
    (help-mode)))
#+end_src
*** Switch to clojure
#+begin_src emacs-lisp
(defun cb:switch-to-clojure ()
  "Switch to the last active clojure buffer."
  (interactive)
  (-when-let (buf (--first-buffer (derived-mode-p 'clojure-mode)))
    (pop-to-buffer buf)))

(define-key cider-repl-mode-map (kbd "C-c C-z") 'cb:switch-to-clojure)
#+end_src
*** Do not scroll docs
Redefine doc handler so that the documentation buffer does not scroll as new
input is received.

#+begin_src emacs-lisp
(after 'cider-interaction

  (defun cider-emit-doc-into-popup-buffer (buffer value)
    "Emit into BUFFER the provided VALUE."
    (with-current-buffer buffer
      (let ((inhibit-read-only t)
            (buffer-undo-list t))
        (goto-char (point-max))
        (insert (format "%s" value))
        (indent-sexp)
        (font-lock-fontify-buffer)
        (goto-char (point-min)))))

  (defun cider-doc--handler (buffer)
    "Make a handler for evaluating and printing stdout/stderr in popup BUFFER."
    (nrepl-make-response-handler buffer
                                 '()
                                 (lambda (buffer str)
                                   (cider-emit-doc-into-popup-buffer buffer str))
                                 (lambda (buffer str)
                                   (cider-emit-doc-into-popup-buffer buffer str))
                                 '()))

  (defun cider-doc-handler (symbol)
    "Create a handler to lookup documentation for SYMBOL."
    (let ((form (format "(clojure.repl/doc %s)" symbol))
          (doc-buffer (cider-popup-buffer cider-doc-buffer t)))
      (cider-tooling-eval form
                          (cider-doc--handler doc-buffer)
                          nrepl-buffer-ns))))
#+end_src

*** eldoc
Use eldoc in all new clojure and cider buffers.

#+begin_src emacs-lisp
(hook-fns '(clojure-mode-hook cider-repl-mode-hook)
  (cider-turn-on-eldoc-mode))
#+end_src

Enable for existing clojure buffers.

#+begin_src emacs-lisp
(-each (--filter-buffers (derived-mode-p 'clojure-mode))
       'cider-turn-on-eldoc-mode)
#+end_src
*** Evaluation
Define a command to evaluate the last clojure buffer.

#+begin_src emacs-lisp
(defun cb:eval-last-clj-buffer ()
  "Evaluate that last active clojure buffer without leaving the repl."
  (interactive)
  (-when-let (buf (--first-buffer (derived-mode-p 'clojure-mode)))
    (with-current-buffer buf
      (cider-eval-buffer))))
#+end_src

#+begin_src emacs-lisp
(define-key clojure-mode-map (kbd "C-c C-f") 'cider-eval-buffer)
(define-key cider-repl-mode-map (kbd "C-c C-f") 'cb:eval-last-clj-buffer)
#+end_src
*** Faces
#+begin_src emacs-lisp
(set-face-attribute 'cider-error-highlight-face t :inherit 'error)
(set-face-underline 'cider-error-highlight-face nil)
#+end_src
*** Evil
Enter insert state when starting cider repl.

#+begin_src emacs-lisp
(after 'evil
  (add-hook 'cider-repl-mode-hook evil-insert-state))
#+end_src

Enter insertion state when switching to cider.

#+begin_src emacs-lisp
(after 'evil
  (defadvice cider-switch-to-repl-buffer (after insert-at-end-of-cider-line activate)
    (evil-insert-state)))
#+end_src

Advise back-to-indentation so evil bol commands work.

#+begin_src emacs-lisp
(defadvice back-to-indentation (around move-to-cider-bol activate)
  "Move to position after prompt in cider."
  (if (equal major-mode 'cider-mode)
      (nrepl-bol)
    ad-do-it))
#+end_src
*** Key bindings
#+begin_src emacs-lisp
(define-key cider-repl-mode-map (kbd "C-l") 'cider-repl-clear-buffer)
#+end_src
*** END
#+begin_src emacs-lisp
)
#+end_src
** ac-nrepl
Provides auto-complete sources for Clojure using Cider.
#+begin_src emacs-lisp
(cb:install-package 'ac-nrepl)
(add-hook 'cider-mode-hook 'ac-nrepl-setup)
(add-hook 'cider-repl-mode-hook 'ac-nrepl-setup)
(add-to-list 'ac-modes 'cider-mode)
#+end_src

#+begin_src emacs-lisp
(after 'cider
  (define-key cider-mode-map (kbd "C-c C-d") 'ac-nrepl-popup-doc))
#+end_src
** yasnippet
Define auxiliary functions for snippets.

#+begin_src emacs-lisp
(defun cbclj:pad-for-arglist (text)
  "Pad TEXT for insertion into an arglist after existing parameters."
  (unless (s-blank? text)
    (s-prepend " " (s-trim-left text))))

(defun cbclj:ns-for-current-buf ()
  "Calculate the namespace to use for the current buffer."
  (if (buffer-file-name)
      (s-replace "/" "."
                 (if (s-matches? "src" (buffer-file-name))
                     (->> (buffer-file-name)
                       f-no-ext
                       (s-split "src/")
                       -last-item)
                   (f-no-ext (f-filename (buffer-file-name)))))
    "name"))
#+end_src
** overtone
*** Define a command to stop overtone synthesis
#+begin_src emacs-lisp
(defun cb:stop-overtone ()
  "Stop synthesis."
  (interactive)
  (cider-eval "(stop)" nil)
  (message "Synthesis stopped."))
#+end_src
*** Define overtone documentation search commands
#+begin_src emacs-lisp
(defun overtone-doc-handler (symbol)
  "Create a handler to lookup documentation for SYMBOL."
  (let ((form (format "(odoc %s)" symbol))
        (doc-buffer (cider-popup-buffer cider-doc-buffer t)))
    (cider-tooling-eval form
                        (cider-popup-eval-out-handler doc-buffer)
                        nrepl-buffer-ns)))

(defun overtone-doc (query)
  "Open a window with the docstring for the given QUERY.
Defaults to the symbol at point.  With prefix arg or no symbol
under point, prompts for a var."
  (interactive "P")
  (cider-read-symbol-name "Symbol: " 'overtone-doc-handler query))

(defalias 'odoc 'overtone-doc)
#+end_src
*** Define a minor mode to use for overtone projects
#+begin_src emacs-lisp
(defun cbot:overtone-project-reference-p ()
  "Non-nil if the project.clj imports overtone."
  (-when-let (clj (and (projectile-project-p)
                       (f-join (projectile-project-root) "project.clj")))
    (when (f-exists? clj)
      (s-contains? "overtone" (f-read-text clj)))))

(defvar overtone-mode-map
  (let ((km (make-sparse-keymap)))
    (define-key km (kbd "C-c C-g") 'cb:stop-overtone)
    (define-key km (kbd "s-.") 'cb:stop-overtone)
    (define-key km (kbd "C-c C-h") 'odoc)
    km))

(define-minor-mode overtone-mode
  "Provide additional overtone-related functionality for clojure."
  nil " overtone" overtone-mode-map)

(defun maybe-enable-overtone-mode ()
  "Enable `overtone-mode' only if the current buffer or project references overtone."
  (when (and (not overtone-mode)
             (derived-mode-p 'clojure-mode 'cider-repl-mode)
             (cbot:overtone-project-reference-p))
    (overtone-mode t)))

(define-globalized-minor-mode global-overtone-mode overtone-mode
  maybe-enable-overtone-mode)

(add-hook 'clojure-mode-hook 'global-overtone-mode)
#+end_src
* Scheme
** auto-complete
*** Enable for all scheme modes
#+begin_src emacs-lisp
(-each cb:scheme-modes (~ add-to-list 'ac-modes))
#+end_src
** documentation
#+begin_src emacs-lisp
(after 'evil
  (define-evil-doc-handler cb:scheme-modes
    (call-interactively 'geiser-doc-symbol-at-point)))
#+end_src
** yasnippet
#+begin_src emacs-lisp
(hook-fn 'cb:scheme-modes-hook
  (add-to-list 'ac-sources 'ac-source-yasnippet))
#+end_src
** geiser
Provides slime-like interaction for Scheme. I mainly use Racket, so the config
below probably doesn't work for other Schemes.
#+begin_src emacs-lisp
(after 'scheme
  (cb:install-package 'geiser))
#+end_src
*** DEFER
#+begin_src emacs-lisp
(after 'geiser
#+end_src
*** set geiser vars
#+begin_src emacs-lisp
(setq geiser-mode-start-repl-p t
      geiser-repl-startup-time 20000
      geiser-repl-history-filename (f-join cb:tmp-dir "geiser-history")
      geiser-active-implementations '(racket))
#+end_src
*** ac-geiser
Provides auto-complete sources for geiser.
#+begin_src emacs-lisp
(cb:install-package 'ac-geiser t)
(add-hook 'geiser-mode-hook 'ac-geiser-setup)
(add-hook 'geiser-repl-mode-hook 'ac-geiser-setup)
#+end_src
*** eval-buffer command
#+begin_src emacs-lisp
(defun geiser-eval-buffer (&optional and-go raw nomsg)
  "Eval the current buffer in the Geiser REPL.

With prefix, goes to the REPL buffer afterwards (as
`geiser-eval-buffer-and-go')"
  (interactive "P")
  (let ((start (progn
                 (goto-char (point-min))
                 (while (s-matches? (rx bol "#") (current-line))
                   (forward-line))
                 (point)))
        (end (point-max)))
    (save-restriction
      (narrow-to-region start end)
      (check-parens))
    (geiser-debug--send-region nil
                               start
                               end
                               (and and-go 'geiser--go-to-repl)
                               (not raw)
                               nomsg)))

(define-key geiser-mode-map (kbd "C-c C-f") 'geiser-eval-buffer)
#+end_src
*** help key bindings
#+begin_src emacs-lisp
(define-key geiser-mode-map (kbd "C-c C-h") 'geiser-doc-look-up-manual)
(define-key geiser-repl-mode-map (kbd "C-c C-h") 'geiser-doc-look-up-manual)
#+end_src
*** move to end of buffer when switching to geiser repl
#+begin_src emacs-lisp
(defadvice switch-to-geiser (after append-with-evil activate)
  (when (derived-mode-p 'comint-mode)
    (goto-char (point-max))))
#+end_src
*** evil
**** M-. goes to definition in normal state
#+begin_src emacs-lisp
(after 'evil
  (evil-define-key 'normal geiser-mode-map
    (kbd "M-.") 'geiser-edit-symbol-at-point))
#+end_src
**** Enter insert state when switching to repl
#+begin_src emacs-lisp
(after 'evil
  (defadvice switch-to-geiser (after append-with-evil activate)
    (when (derived-mode-p 'comint-mode)
      (evil-insert-state))))
#+end_src
*** END
#+begin_src emacs-lisp
)
#+end_src
** add compile-and-run command for Racket
*** Define buffer name
#+begin_src emacs-lisp
(defconst cbscm:scm-buf "*execute scheme*")
#+end_src
*** Define utility to execute a file with Racket
#+begin_src emacs-lisp
(defun cbscm:lang (s)
  (or (cadr (s-match (rx bol "#lang" (+ space) (group (+ nonl))) s))
      "racket"))

(defun cbscm:run-file (file language)
  (interactive "f")
  (start-process cbscm:scm-buf cbscm:scm-buf
                 "racket" "-I" language file))
#+end_src
*** Define command to compile-and-run current buffer
#+begin_src emacs-lisp
(defun cbscm:execute-buffer ()
  "Compile and run the current buffer in Racket."
  (interactive)
  ;; Kill running processes and prepare buffer.
  (with-current-buffer (get-buffer-create cbscm:scm-buf)
    (read-only-mode +1)
    (ignore-errors (kill-process))
    (let ((inhibit-read-only t))
      (delete-region (point-min) (point-max))))

  ;; Start a new Scheme process in the appropriate language for this file.
  (let ((lang (cbscm:lang (buffer-string))))
    (cond
     ;; Create a temp file if there are unwritten changes or this buffer does
     ;; not have a corresponding file.
     ((or (buffer-modified-p)
          (and (buffer-file-name) (not (f-exists? (buffer-file-name)))))
      (let ((f (make-temp-file nil nil ".rkt")))
        (f-write (buffer-string) 'utf-8 f)
        (cbscm:run-file f lang)))
     ;; Otherwise run this file directly.
     (t
      (cbscm:run-file (buffer-file-name) lang))))

  (display-buffer-other-frame cbscm:scm-buf))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(after 'scheme
  (define-key scheme-mode-map (kbd "C-c C-c") 'cbscm:execute-buffer))
#+end_src
** Set custom indentation for Racket keywords
#+begin_src emacs-lisp
(after 'scheme
  (put 'begin                 'scheme-indent-function 0)
  (put 'begin-for-syntax      'scheme-indent-function 0)
  (put 'case                  'scheme-indent-function 1)
  (put 'cond                  'scheme-indent-function 0)
  (put 'delay                 'scheme-indent-function 0)
  (put 'do                    'scheme-indent-function 2)
  (put 'lambda                'scheme-indent-function 1)
  (put 'λ                     'scheme-indent-function 1)
  (put 'lambda:               'scheme-indent-function 1)
  (put 'case-lambda           'scheme-indent-function 0)
  (put 'lambda/kw             'scheme-indent-function 1)
  (put 'define/kw             'scheme-indent-function 'defun)
  (put 'let                   'scheme-indent-function 'scheme-let-indent)
  (put 'let*                  'scheme-indent-function 1)
  (put 'letrec                'scheme-indent-function 1)
  (put 'let-values            'scheme-indent-function 1)
  (put 'let*-values           'scheme-indent-function 1)
  (put 'fluid-let             'scheme-indent-function 1)
  (put 'let/cc                'scheme-indent-function 1)
  (put 'let/ec                'scheme-indent-function 1)
  (put 'let-id-macro          'scheme-indent-function 2)
  (put 'let-macro             'scheme-indent-function 2)
  (put 'letmacro              'scheme-indent-function 1)
  (put 'letsubst              'scheme-indent-function 1)
  (put 'sequence              'scheme-indent-function 0) ; SICP, not r4rs
  (put 'letsyntax             'scheme-indent-function 1)
  (put 'let-syntax            'scheme-indent-function 1)
  (put 'letrec-syntax         'scheme-indent-function 1)
  (put 'syntax-rules          'scheme-indent-function 1)
  (put 'syntax-id-rules       'scheme-indent-function 1)

  (put 'call-with-input-file  'scheme-indent-function 1)
  (put 'call-with-input-file* 'scheme-indent-function 1)
  (put 'with-input-from-file  'scheme-indent-function 1)
  (put 'with-input-from-port  'scheme-indent-function 1)
  (put 'call-with-output-file 'scheme-indent-function 1)
  (put 'call-with-output-file* 'scheme-indent-function 1)
  (put 'with-output-to-file   'scheme-indent-function 'defun)
  (put 'with-output-to-port   'scheme-indent-function 1)
  (put 'with-slots            'scheme-indent-function 2)
  (put 'with-accessors        'scheme-indent-function 2)
  (put 'call-with-values      'scheme-indent-function 2)
  (put 'dynamic-wind          'scheme-indent-function 'defun)

  (put 'if                    'scheme-indent-function 1)
  (put 'method                'scheme-indent-function 1)
  (put 'beforemethod          'scheme-indent-function 1)
  (put 'aftermethod           'scheme-indent-function 1)
  (put 'aroundmethod          'scheme-indent-function 1)
  (put 'when                  'scheme-indent-function 1)
  (put 'unless                'scheme-indent-function 1)
  (put 'thunk                 'scheme-indent-function 0)
  (put 'while                 'scheme-indent-function 1)
  (put 'until                 'scheme-indent-function 1)
  (put 'parameterize          'scheme-indent-function 1)
  (put 'parameterize*         'scheme-indent-function 1)
  (put 'syntax-parameterize   'scheme-indent-function 1)
  (put 'with-handlers         'scheme-indent-function 1)
  (put 'with-handlers*        'scheme-indent-function 1)
  (put 'begin0                'scheme-indent-function 1)
  (put 'with-output-to-string 'scheme-indent-function 0)
  (put 'ignore-errors         'scheme-indent-function 0)
  (put 'no-errors             'scheme-indent-function 0)
  (put 'matcher               'scheme-indent-function 1)
  (put 'match                 'scheme-indent-function 1)
  (put 'regexp-case           'scheme-indent-function 1)
  (put 'dotimes               'scheme-indent-function 1)
  (put 'dolist                'scheme-indent-function 1)

  (put 'with-syntax           'scheme-indent-function 1)
  (put 'syntax-case           'scheme-indent-function 2)
  (put 'syntax-case*          'scheme-indent-function 3)
  (put 'syntax-parse          'scheme-indent-function 1)
  (put 'module                'scheme-indent-function 2)

  (put 'syntax                'scheme-indent-function 0)
  (put 'quasisyntax           'scheme-indent-function 0)
  (put 'syntax/loc            'scheme-indent-function 1)
  (put 'quasisyntax/loc       'scheme-indent-function 1)

  (put 'cases                 'scheme-indent-function 1)

  (put 'for                   'scheme-indent-function 1)
  (put 'for*                  'scheme-indent-function 1)
  (put 'for/list              'scheme-indent-function 1)
  (put 'for*/list             'scheme-indent-function 1)
  (put 'for/fold              'scheme-indent-function 2)
  (put 'for*/fold             'scheme-indent-function 2)
  (put 'for/and               'scheme-indent-function 1)
  (put 'for*/and              'scheme-indent-function 1)
  (put 'for/or                'scheme-indent-function 1)
  (put 'for*/or               'scheme-indent-function 1)

  (put 'nest                  'scheme-indent-function 1))
#+end_src
** Improve font locking for Racket
#+begin_src emacs-lisp
(after 'scheme
  (--each cb:scheme-modes
    (font-lock-add-keywords
     it
     `(;; Special forms in Typed Racket.
       (,(rx "("
             (group (or
                     ;; let family
                     (and (? "p") "let" (* (syntax word)) ":")
                     (and "let/" (+ (syntax word)))
                     ;; lambdas
                     (and (* (syntax word)) "lambda:")
                     ;; loops
                     (and "for" (* (syntax word)) ":")
                     "do:"
                     ;; Types
                     "struct:"
                     ":"
                     "provide:"
                     "cast"))

             eow)
        (1 font-lock-keyword-face))

       ;; Definition forms
       (,(rx "(" (group "def" (* (syntax word)) eow))
        (1 font-lock-keyword-face))

       ;; Bindings created by `define-values'
       (,(rx "(define-values" (+ space)
             "(" (group (+ (or (syntax word) space))) ")")
        (1 font-lock-variable-name-face))

       ;; General binding identifiers
       (,(rx "(def" (* (syntax word)) (+ space)
             (group (+ (syntax word))))
        (1 font-lock-variable-name-face))

       ;; Function identifiers
       (,(rx "(def" (* (syntax word)) (+ space)
             "(" (group (+ (syntax word))))
        (1 font-lock-function-name-face))

       ;; Function identifier in type declaration
       (,(rx "(:" (+ space) (group bow (+ (syntax word)) eow))
        (1 font-lock-function-name-face))

       ;; Arrows
       (,(rx bow "->" eow)
        (0 (prog1 nil (compose-region (match-beginning 0) (match-end 0) "→"))))

       ;; Match keywords
       (,(rx "(" (group "match" (* (syntax word)) eow))
        (1 font-lock-keyword-face))

       ;; Error signalling keywords
       (,(rx "(" (group (or "error" "raise")
                        (* (syntax word)) eow))
        (1 font-lock-warning-face))

       ;; Grab-bag of keywords
       (,(rx "(" (group (or (and "begin" num)
                            "parameterize"
                            ))
             eow)
        (1 font-lock-keyword-face))))

    ;; Do not add type font locking to the REPL, because it has too many false
    ;; positives.
    (font-lock-add-keywords
     'scheme-mode
     ;; Types for Typed Racket.
     `((,(rx bow upper (* (syntax word)) eow)
        (0 font-lock-type-face))))))
#+end_src
* Python
** python-mode
Use the more recent python mode available on Marmalade.
#+begin_src emacs-lisp
(cb:install-package 'python)
#+end_src
*** Work around packaging issue
FIX: the package file is malformed. Work around by manually autoloading
=python-mode=.
#+begin_src emacs-lisp
(let ((pkg-dir (-first (~ s-matches? (rx "python-" digit))
                       (f-directories cb:elpa-dir))))
  (autoload 'python-mode (f-join pkg-dir "python.el") nil t))
#+end_src
*** Emulate prog-mode
=python-mode= is not derived from prog mode, but we still want all the
programming goodies, so run the hook manually.

#+begin_src emacs-lisp
(hook-fn 'python-mode-hook
  (run-hooks 'prog-mode-hook))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'python
#+end_src
** ipython support
Use ipython if it is installed.
#+begin_src emacs-lisp
(-when-let (ipython (executable-find "ipython"))
  (setq python-shell-interpreter ipython
        python-shell-interpreter-args ""
        python-shell-prompt-regexp "In \\[[0-9]+\\]: "
        python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
        python-shell-completion-setup-code
        "from IPython.core.completerlib import module_completion"
        python-shell-completion-module-string-code
        "';'.join(module_completion('''%s'''))\n"
        python-shell-completion-string-code
        "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))
#+end_src
** commas
#+begin_src emacs-lisp
(define-key python-mode-map (kbd ",") 'cb:comma-then-space)
(define-key inferior-python-mode-map (kbd ",") 'cb:comma-then-space)
#+end_src

** switch to python
Define a command to switch from the repl to the last python buffer and
vice-versa.
*** Impl

#+begin_src emacs-lisp
(defun cb-py:restart-python ()
  (save-window-excursion
    (let (kill-buffer-query-functions
          (buf (get-buffer "*Python*")))
      (when buf (kill-buffer buf)))
    (call-interactively 'run-python)))

(defun cb:switch-to-python ()
  "Switch to the last active Python buffer."
  (interactive)
  ;; Start inferior python if necessary.
  (unless (->> (--first-buffer (derived-mode-p 'inferior-python-mode))
            (get-buffer-process)
            (processp))
    (cb-py:restart-python))

  (if (derived-mode-p 'inferior-python-mode)
      ;; Switch from inferior python to source file.
      (switch-to-buffer-other-window
       (--first-buffer (derived-mode-p 'python-mode)))
    ;; Switch from source file to REPL.
    ;; HACK: `switch-to-buffer-other-window' does not change window
    ;; when switching to REPL buffer. Work around this.
    (-when-let* ((buf (--first-buffer (derived-mode-p 'inferior-python-mode)))
                 (win (or (--first-window (equal (get-buffer "*Python*")
                                                 (window-buffer it)))
                          (split-window-sensibly)
                          (next-window))))
      (set-window-buffer win buf)
      (select-window win)
      (goto-char (point-max))
      (when (fboundp 'evil-append-line)
        (evil-append-line 1)))))
#+end_src
*** Bind keys
#+begin_src emacs-lisp
(define-key python-mode-map (kbd "C-c C-z") 'cb:switch-to-python)
(define-key inferior-python-mode-map (kbd "C-c C-z") 'cb:switch-to-python)
#+end_src
** eval-dwim
Define a command that performs a context-sensitive eval command.
*** Impl
#+begin_src emacs-lisp
(defun cb-py:eval-dwim (&optional arg)
  (interactive "P")
  (cond
   ((region-active-p)
    (python-shell-send-region (region-beginning) (region-end))
    (deactivate-mark))
   (t
    (python-shell-send-defun arg))))
#+end_src
*** Bind keys
#+begin_src emacs-lisp
(define-key python-mode-map (kbd "C-c C-c") 'cb-py:eval-dwim)
#+end_src

** auto-complete
Enable auto-complete in python modes.
#+begin_src emacs-lisp
(-each cb:python-modes (~ add-to-list 'ac-modes))
(hook-fn 'cb:python-modes-hook (auto-complete-mode +1))
#+end_src
** smart operators
Add special smart-operator behaviours for python buffers.
#+begin_src emacs-lisp
(defun cb-py:smart-equals ()
  "Insert an '=' char padded by spaces, except in function arglists."
  (interactive)
  (if (s-matches? (rx (* space) "def" space) (current-line))
      (insert "=")
    (smart-insert-operator "=")))

(defun cb-py:smart-asterisk ()
  "Insert an asterisk with padding unless we're in an arglist."
  (interactive "*")
  (cond
   ((s-matches? (rx (* space) "def" space) (current-line))
    (insert "*"))
   ;; Collapse whitespace around exponentiation operator.
   ((thing-at-point-looking-at (rx (* space) "*" (* space)))
    (delete-horizontal-space)
    (save-excursion
      (search-backward "*")
      (delete-horizontal-space))
    (insert "*"))
   (t
    (smart-insert-operator "*"))))

(defun cb-py:smart-comma ()
  "Insert a comma with padding."
  (interactive "*")
  (insert ",")
  (just-one-space))

(defun cb-py:smart-colon ()
  "Insert a colon with padding."
  (interactive "*")
  (insert ":")
  (just-one-space))

(--each (list python-mode-map inferior-python-mode-map)
    (define-keys it
      "," 'cb-py:smart-comma
      "&" (command (smart-insert-operator "&"))
      "%" (command (smart-insert-operator "%"))
      "?" (command (smart-insert-operator "?"))
      "*" 'cb-py:smart-asterisk
      ":" 'cb-py:smart-colon
      "+" (command (smart-insert-operator "+"))
      "/" (command (smart-insert-operator "/"))
      "-" (command (smart-insert-operator "-"))
      "=" 'cb-py:smart-equals
      "<" (command (smart-insert-operator "<"))
      ">" (command (smart-insert-operator ">"))
      "|" (command (smart-insert-operator "|"))
      "$" (command (smart-insert-operator "$"))))
#+end_src
** smartparens
#+begin_src emacs-lisp
(sp-with-modes cb:python-modes
  (sp-local-pair "{" "}" :post-handlers '(:add sp-generic-leading-space)))
#+end_src
** documentation
#+begin_src emacs-lisp
(after 'evil
  (define-evil-doc-handler cb:python-modes (jedi:show-doc)))
#+end_src
** auto-insert headers
Auto-insert header in python files.
#+begin_src emacs-lisp
(after 'autoinsert
  (define-auto-insert
    '("\\.py$" . "Python skeleton")
    '("Short description: "
      "\"\"\"\n"
      str
      "\n\"\"\"\n\n"
      _
      "\n")))
#+end_src
** yasnippet
Define functions for manipulating docstrings.
#+begin_src emacs-lisp
(defun cb-py:split-arglist (arglist)
  "Parse ARGLIST into a list of parameters.
Each element is either a string or a cons of (var . default)."
  (cl-loop
   for arg in (s-split (rx ",") arglist t)
   for (x . y)  = (s-split "=" arg)
   for (_ name) = (s-match (rx (* (any "*")) (group (* (any "_" alnum)))) x)
   for default  = (when y (car y))
   when (not (s-blank? (s-trim name)))
   collect (if default (cons name default) name)))

(defun cb-py:python-docstring (arglist)
  "Format a docstring according to ARGLIST."
  (let ((al (s-replace " " "" arglist)))
    (if (s-blank? al)
        ""
      (cl-destructuring-bind (keywords formal)
          (-separate 'listp (cb-py:split-arglist al))
        (concat
         (when (or formal keywords) "\n")
         ;; Formal args
         (when (and formal keywords) "    Formal arguments:\n")
         (s-join "\n" (--map (format "    %s --" it) formal))
         (when keywords "\n\n")
         ;; Keyword args
         (when (and formal keywords) "    Keyword arguments:\n")
         (s-join "\n" (--map (format "    %s (default %s) --" (car it) (cdr it))
                             keywords)))))))
#+end_src
** insertion commands
Define a command to insert a docstring for the function at point.
*** Define command
#+begin_src emacs-lisp
(defun cb-py:arglist-for-function-at-point ()
  "Return the arglist for the function at point, or nil if none."
  (save-excursion
    (when (beginning-of-defun)
      (let ((start (search-forward "("))
            (end (1- (search-forward ")"))))
        (buffer-substring start end)))))

(defun cb-py:insert-docstring ()
  "Insert a docstring for the python function at point."
  (interactive "*")
  (-when-let (arglist (cb-py:arglist-for-function-at-point))
    (when (beginning-of-defun)
      (search-forward-regexp (rx ":" (* space) eol))
      (newline)
      (open-line 1)
      (insert (concat "    \"\"\"\n"
                      (cb-py:python-docstring arglist) "\n\n"
                      "    Returns:\n\n"
                      "    \"\"\"" ))
      (message "Arglist inserted."))))
#+end_src
*** Add to insertion picker
#+begin_src emacs-lisp
(add-to-list 'insertion-picker-options
             '("d" "Docstring" cb-py:insert-docstring :modes (python-mode)))
#+end_src
** python-info
Installs an info manual for Python 2.7
#+begin_src emacs-lisp
(cb:install-package 'python-info)
#+end_src
** jedi
Provides auto-completion, code search and documentation for python.

#+begin_src emacs-lisp
(cb:install-package 'jedi)
(add-hook 'cb:python-modes-hook 'jedi:setup)
#+end_src

Configure auto-complete.

#+begin_src emacs-lisp
(setq jedi:tooltip-method nil
      jedi:complete-on-dot t)
#+end_src

Improve python support in imenu.

#+begin_src emacs-lisp
(setq jedi:install-imenu t)
#+end_src

Make the goto-definition key the same as for lisp modes.

#+begin_src emacs-lisp
(setq jedi:key-goto-definition (kbd "M-."))
#+end_src
** virtualenv
Configures Emacs according to the current python virtualenv settings.

#+begin_src emacs-lisp
(cb:install-package 'virtualenv)
(add-hook 'cb:python-modes-hook 'virtualenv-minor-mode)
#+end_src

Mark virtualenv vars as safe.

#+begin_src emacs-lisp
(put 'virtualenv-default-directory 'safe-local-variable (K t))
(put 'virtualenv-workon 'safe-local-variable (K t))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Ruby
** ruby-mode
#+begin_src emacs-lisp
(cb:install-package 'ruby-mode)
#+end_src
** Ignore RBC files
#+begin_src emacs-lisp
(add-to-list 'completion-ignored-extensions ".rbc")
#+end_src
** auto-modes
#+begin_src emacs-lisp
(-each '(("\\.rake\\'". ruby-mode)
         ("Rakefile\\'" . ruby-mode)
         ("\\.gemspec\\'" . ruby-mode)
         ("\\.ru\\'" . ruby-mode)
         ("Gemfile\\'" . ruby-mode)
         ("Guardfile\\'" . ruby-mode)
         ("Capfile\\'" . ruby-mode)
         ("\\.thor\\'" . ruby-mode)
         ("Thorfile\\'" . ruby-mode)
         ("Vagrantfile\\'" . ruby-mode)
         ("\\.jbuilder\\'" . ruby-mode))
       (~ add-to-list 'auto-mode-alist))
#+end_src
** erb
Define custom minor mode for ERB files.
#+begin_src emacs-lisp
(define-derived-mode erb-mode html-mode
  "ERB" nil
  (when (fboundp 'flycheck-mode)
    (flycheck-mode -1)))

(add-to-list 'auto-mode-alist '("\\.html\\.erb" . erb-mode))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'ruby-mode
#+end_src
** inf-ruby
#+begin_src emacs-lisp
(cb:install-package 'inf-ruby)
#+end_src
*** Work around damaged package
#+begin_src emacs-lisp
(let ((file (f-join (-first (~ s-matches? "inf-ruby") (f-directories cb:elpa-dir))
                    "inf-ruby.el")))

  (autoload 'inf-ruby-mode file nil t)
  (load-file file))
#+end_src
*** DEFER
#+begin_src emacs-lisp
(after '(ruby-mode inf-ruby)
#+end_src
*** Start an inferior ruby if not already running
#+begin_src emacs-lisp
(defadvice ruby-switch-to-inf (around start-inf-ruby activate)
  "Start an inferior ruby if one is not running."
  (condition-case _
      ad-do-it
    (wrong-type-argument
     (run-ruby))))
#+end_src
*** Interactively set ruby interpreter
#+begin_src emacs-lisp
(defun set-ruby-interpreter (cmd)
  "Set the default ruby interpreter to CMD."
  (interactive
   (list
    (ido-completing-read
     "Inferior Ruby Program: "
     (->> inf-ruby-implementations
       (-map 'car)
       (-filter 'executable-find)))))
  (setq inf-ruby-default-implementation cmd))
#+end_src
*** Define restart-ruby command
#+begin_src emacs-lisp
(defun cb-rb:inf-ruby-window ()
  (-when-let (buf (get-buffer inf-ruby-buffer))
    (--first-window (equal (window-buffer it) buf))))

(defun restart-ruby ()
  (interactive)
  ;; Suppress exit query.
  (-when-let (proc (ignore-errors (inf-ruby-proc)))
    (set-process-query-on-exit-flag proc nil))
  ;; Kill and relaunch IRB, reusing existing window.
  (let ((win (cb-rb:inf-ruby-window)))
    (ignore-errors (kill-buffer inf-ruby-buffer))
    (save-window-excursion (run-ruby))
    (when win
      (set-window-buffer win inf-ruby-buffer))))

#+end_src
*** switch to ruby
**** Impl
#+begin_src emacs-lisp
(defun cb-rb:switch-to-ruby ()
  "Toggle between irb and the last ruby buffer.
Start an inferior ruby if necessary."
  (interactive)
  (cond
   ((derived-mode-p 'inf-ruby-mode)
    (switch-to-buffer-other-window
     (--first-buffer (derived-mode-p 'ruby-mode))))
   ((and inf-ruby-buffer (get-buffer inf-ruby-buffer))
    (ruby-switch-to-inf t))
   (t
    (run-ruby))))
#+end_src
**** Key binding
#+begin_src emacs-lisp
(define-key ruby-mode-map (kbd "C-c C-z") 'cb-rb:switch-to-ruby)
(define-key inf-ruby-mode-map (kbd "C-c C-z") 'cb-rb:switch-to-ruby)
(define-key inf-ruby-minor-mode-map (kbd "C-c C-z") 'cb-rb:switch-to-ruby)
#+end_src
*** eval-dwim
**** Impl
#+begin_src emacs-lisp
(defun cb-rb:eval-dwim ()
  "Perform a context-sensitive evaluation."
  (interactive)
  ;; Start ruby if necessary.
  (unless (get-buffer "*ruby*")
    (run-ruby)
    (cb-rb:switch-to-ruby)
    ;; Revert window layout.
    (when (= 2 (length (window-list)))
      (delete-other-windows)))
  (cond
   ;; Evaluate active region.
   ((region-active-p)
    (ruby-send-region (region-beginning) (region-end)))
   ;; Evaluate the block at or just before point.
   ((or (thing-at-point-looking-at
         (rx (or "end" "]" "}" ")") (* space) (* "\n")))
        (ruby-block-contains-point (point)))
    (ruby-send-block))
   ;; Eval the block-like thing around point.
   (t
    (ruby-send-region (line-beginning-position)
                      (line-end-position)))))
#+end_src
**** Key binding
#+begin_src emacs-lisp
(define-key ruby-mode-map (kbd "C-c C-c") 'cb-rb:eval-dwim)
#+end_src
*** propertise IRB errors
#+begin_src emacs-lisp
(defun cb-rb:format-irb-error (lines)
  "Return a propertized error string for the given LINES of
an irb error message."
  (-when-let* ((err (--first (s-matches? "Error:" it) lines))
               (colon (s-index-of ":" err)))
    (concat (propertize (substring err 0 colon) 'face 'error)
            (substring err colon))))

(defun cb-rb:apply-font-lock (str)
  "Apply ruby font-locking to string STR."
  (with-temp-buffer
    (insert str)
    (require 'ruby-mode)
    ;; Configure ruby font-lock.
    (set (make-local-variable 'font-lock-defaults)
         '((ruby-font-lock-keywords) nil nil))
    (set (make-local-variable 'syntax-propertize-function)
         'ruby-syntax-propertize-function)

    (font-lock-fontify-buffer)
    (buffer-string)))

(defun cb-rb:filter-irb-output (str &rest _)
  "Print IRB output to messages."
  (ignore-errors
    (when (and (fboundp 'inf-ruby-proc) (inf-ruby-proc))
      (let ((lines
             (->> (s-lines str)
               (--remove (or (s-contains? "--inf-ruby" it)
                             (s-blank? it)
                             (s-matches? inf-ruby-prompt-pattern it)))
               (-map 's-trim))))
        (message (or (cb-rb:format-irb-error lines)
                     (cb-rb:apply-font-lock (car (reverse lines))))))))
  str)

(hook-fn 'inf-ruby-mode-hook
  (add-hook 'comint-preoutput-filter-functions 'cb-rb:filter-irb-output)
  ;; Stop IRB from echoing input.
  (setq comint-process-echoes t))
#+end_src
*** END
#+begin_src emacs-lisp
)
#+end_src
** convert rockets to colons
#+begin_src emacs-lisp
(defun cb-rb:rockets->colons ()
  "Convert old-style rockets to new hash literal syntax in the current buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward-regexp (rx ":" (group-n 1 (+ (not space)))
                                      (* space)
                                      "=>"
                                      (* space))
                                  nil t)
      (replace-match "\\1: " t nil))))
#+end_src
** rvm
#+begin_src emacs-lisp
(cb:install-package 'rvm)
(add-hook 'ruby-mode-hook 'rvm-activate-corresponding-ruby)
#+end_src
** subword-mode
#+begin_src emacs-lisp
(add-hook 'cb:ruby-modes-hook 'subword-mode)
#+end_src
** smart operator
#+begin_src emacs-lisp
(defun cb-rb:smart-colon ()
  "Insert a colon, with or without padding.
If this is the leading colon for a symbol, do not insert padding.
If this is the trailing colon for a hash key, insert padding."
  (interactive)
  (insert ":")
  (when (s-matches? (rx (+ alnum) ":" eol)
                    (buffer-substring (line-beginning-position) (point)))
    (just-one-space)))

(hook-fn 'cb:ruby-modes-hook
  (local-set-key (kbd ",") (command (insert ",") (just-one-space)))
  (local-set-key (kbd ":") 'cb-rb:smart-colon)
  (local-set-key (kbd "|") (smart-op "|"))
  (local-set-key (kbd "~") (smart-op "~"))
  (local-set-key (kbd "<") (smart-op "<"))
  (local-set-key (kbd ">") (smart-op ">"))
  (local-set-key (kbd "=") (smart-op "="))
  (local-set-key (kbd "-") (smart-op "-"))
  (local-set-key (kbd "+") (smart-op "+"))
  (local-set-key (kbd "/") (smart-op "/")))
#+end_src
** rinari
Provides navigation commands between files in Rails projects.
#+begin_src emacs-lisp
(cb:install-package 'rinari)
#+end_src
*** Enable in rails projects
#+begin_src emacs-lisp
(defun cb:rails-project? ()
  (and (not (or (true? org-src-mode)
                (s-starts-with? "*Org Src " (buffer-name))))
       (projectile-project-p)
       (s-matches? "rails" (symbol-name (projectile-project-type)))))

(hook-fn 'cb:rails-modes-hook
  (when (cb:rails-project?)
    (rinari-minor-mode +1)))
#+end_src
*** Configure vars
#+begin_src emacs-lisp
(hook-fn 'rinari-minor-mode-hook
  (setq rinari-tags-file-name "TAGS"
        rng-nxml-auto-validate-flag nil
        nxml-degraded t))
#+end_src
*** Rebind keys
#+begin_src emacs-lisp
(after 'rinari
  (define-prefix-command 'cb:rinari-map)
  (define-key rinari-minor-mode-map (kbd "C-c f") 'cb:rinari-map)
  (define-keys cb:rinari-map
    ";" 'rinari-find-by-context
    "C" 'rinari-find-cells
    "F" 'rinari-find-features
    "M" 'rinari-find-mailer
    "S" 'rinari-find-steps
    "Y" 'rinari-find-sass
    "a" 'rinari-find-application
    "c" 'rinari-find-controller
    "e" 'rinari-find-environment
    "f" 'rinari-find-file-in-project
    "h" 'rinari-find-helper
    "i" 'rinari-find-migration
    "j" 'rinari-find-javascript
    "l" 'rinari-find-lib
    "m" 'rinari-find-model
    "n" 'rinari-find-configuration
    "o" 'rinari-find-log
    "p" 'rinari-find-public
    "r" 'rinari-find-rspec
    "s" 'rinari-find-script
    "t" 'rinari-find-test
    "u" 'rinari-find-plugin
    "v" 'rinari-find-view
    "w" 'rinari-find-worker
    "x" 'rinari-find-fixture
    "y" 'rinari-find-stylesheet
    "z" 'rinari-find-rspec-fixture))
#+end_src
** smartparens
#+begin_src emacs-lisp
(require 'smartparens-ruby)
#+end_src
*** Change word boundaries so slurping works
#+begin_src emacs-lisp
(modify-syntax-entry ?@ "w" ruby-mode-syntax-table)
(modify-syntax-entry ?_ "w" ruby-mode-syntax-table)
(modify-syntax-entry ?! "w" ruby-mode-syntax-table)
(modify-syntax-entry ?? "w" ruby-mode-syntax-table)
#+end_src
*** Automate delimiter formatting
#+begin_src emacs-lisp
(defun sp-ruby-should-insert-pipe-close (_id _action _ctx)
  "Test whether to insert the closing pipe for a lambda-binding pipe pair."
  (thing-at-point-looking-at
   (rx-to-string `(and (or "do" "{") (* space) "|"))))

(defun sp-ruby-sp-hook-space-before (_id action _ctx)
  "Move to point before ID and insert a space."
  (when (equal 'insert action)
    (save-excursion
      (search-backward "|")
      (just-one-space))))

(defun sp-ruby-sp-hook-space-after (_id action _ctx)
  "Move to point after ID and insert a space."
  (when (equal 'insert action)
    (save-excursion
      (search-forward "|")
      (just-one-space))))

(sp-with-modes '(ruby-mode inf-ruby-mode)

  (sp-local-pair "{" "}"
                 :post-handlers '(:add sp-generic-leading-space))

  (sp-local-pair "[" "]"
                 :pre-handlers '(sp-ruby-pre-handler))

  (sp-local-pair "%q{" "}" :when '(sp-in-code-p))
  (sp-local-pair "%Q{" "}" :when '(sp-in-code-p))
  (sp-local-pair "%w{" "}" :when '(sp-in-code-p))
  (sp-local-pair "%W{" "}" :when '(sp-in-code-p))
  (sp-local-pair  "%(" ")" :when '(sp-in-code-p))
  (sp-local-pair "%x(" ")" :when '(sp-in-code-p))
  (sp-local-pair  "#{" "}" :when '(sp-in-string-p))

  (sp-local-pair "|" "|"
                 :when '(sp-ruby-should-insert-pipe-close)
                 :unless '(sp-in-string-p)
                 :pre-handlers '(sp-ruby-sp-hook-space-before)
                 :post-handlers '(sp-ruby-sp-hook-space-after))

  (sp-local-pair "case" "end"
                 :when '(("SPC" "RET" "<evil-ret>"))
                 :unless '(sp-ruby-in-string-or-word-p)
                 :actions '(insert)
                 :pre-handlers '(sp-ruby-pre-handler)
                 :post-handlers '(sp-ruby-block-post-handler)))
#+end_src
** yari
Provides a frontend to Ruby ri docs.
#+begin_src emacs-lisp
(cb:install-package 'yari)
#+end_src
*** Bind to C-c C-h
#+begin_src emacs-lisp
(hook-fn 'cb:ruby-modes-hook
  (local-set-key (kbd "C-c C-h") 'yari))
#+end_src
** rubocop
Rubocop is a Ruby style-checker.
#+begin_src emacs-lisp
(cb:install-package 'rubocop)
#+end_src
** robe
Robe provides auto-complete for Ruby.
#+begin_src emacs-lisp
(cb:install-package 'robe)
#+end_src
*** Enable for all Ruby modes
#+begin_src emacs-lisp
(-each cb:ruby-modes (~ add-to-list 'ac-modes))
(hook-fn 'cb:ruby-modes-hook
  (require 'robe-ac)
  (robe-mode)
  (setq ac-sources '(ac-source-robe ac-source-words-in-same-mode-buffers)))
#+end_src
*** Undefine binding conflicting with org src mode
#+begin_src emacs-lisp
(after 'robe
  (define-key robe-mode-map (kbd "C-c C-k") nil))
#+end_src
*** Diminish robe-mode
#+begin_src emacs-lisp
(hook-fn 'robe-mode-hook
  (diminish 'robe-mode))
#+end_src
** hideshow
#+begin_src emacs-lisp
(after 'hideshow
  (add-to-list 'hs-special-modes-alist
               `(ruby-mode
                 ,(rx (or "def" "class" "module" "{" "[")) ; Block start
                 ,(rx (or "}" "]" "end"))                  ; Block end
                 ,(rx (or "#" "=begin"))                   ; Comment start
                 ruby-forward-sexp nil)))
#+end_src
** documentation
Add evil doc lookup handler for Ruby.
#+begin_src emacs-lisp
(after 'evil
  (define-evil-doc-handler cb:ruby-modes (call-interactively 'robe-doc)))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
** yaml-mode
#+begin_src emacs-lisp
(cb:install-package 'yaml-mode)
#+end_src
* Scala
#+begin_src emacs-lisp
(cb:install-package 'scala-mode2)
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'scala-mode2
#+end_src
** Customise indentation
#+begin_src emacs-lisp
(setq scala-indent:align-forms t
      scala-indent:align-parameters t
      scala-indent:default-run-on-strategy scala-indent:eager-strategy)
#+end_src
** auto-complete
*** Auto-complete Scala language keywords
#+begin_src emacs-lisp
(defconst cbscala:scala-keywords
  '("abstract" "case" "catch" "class" "def" "do" "else" "extends" "false" "final"
    "finally" "for" "forSome" "if" "implicit" "import" "lazy" "match" "new" "null"
    "object" "override" "package" "private" "protected" "return" "sealed" "super"
    "this" "throw" "trait" "try" "true" "type" "val" "var" "while" "with" "yield"
    "-" ":" "=" "=>" "<-" "<:" "<%" ">:" "#" "@")
  "List of keywords reserved by the scala language.")

(ac-define-source scala-keywords
  '((symbol . "k")
    (candidates . cbscala:scala-keywords)
    (action . just-one-space)))
#+end_src
*** Configure auto-complete
#+begin_src emacs-lisp
(add-to-list 'ac-modes 'scala-mode)

(hook-fn 'scala-mode-hook
  (setq-local ac-auto-start 2)
  (-each '(ac-source-yasnippet
           ac-source-scala-keywords
           ac-source-ensime-completions)
         (~ add-to-list 'ac-sources)))
#+end_src
** yasnippet utilities
#+begin_src emacs-lisp
(defun cbscala:find-case-class-parent ()
  (save-excursion
    (if (search-backward-regexp
         (rx (or
              (and bol (* space)
                   (or (and (? "abstract" (+ space)) "class")
                       "trait")
                   (+ space) (group-n 1 (+ alnum)))
              (and bol (* space)
                   "case" (+ space) "class" (* anything) space
                   "extends" (+ space) (group-n 1 (+ alnum)) (* space) eol)))
         nil t)
        (match-string 1)
      "")))
#+end_src
** smart operators
*** Define a macro for declaring operators that double as variance annotations
#+begin_src emacs-lisp
(defun cbscala:equals ()
  (interactive)
  (smart-insert-operator "=")
  (just-one-space))

(defun cbscala:colon ()
  (interactive)
  (smart-insert-operator ":")
  (just-one-space))

(defmacro define-scala-variance-op-command (sym op)
  "Define command named SYM to insert a variance operator OP."
  `(defun ,sym ()
     "Insert a variance operator.
Pad in normal expressions. Do not insert padding in variance annotations."
     (interactive "*")
     (cond
      ;; No padding at the start of type parameter.
      ((thing-at-point-looking-at (rx "[" (* space)))
       (delete-horizontal-space)
       (insert ,op))
      ;; Leading padding after a comma, e.g. for a type parameter or function call.
      ((thing-at-point-looking-at (rx "," (* space)))
       (just-one-space)
       (insert ,op))
      ;; Otherwise leading and trailing padding.
      (t
       (smart-insert-operator ,op)))))
#+end_src
*** Declare variance operators
#+begin_src emacs-lisp
(define-scala-variance-op-command cbscala:plus "+")
(define-scala-variance-op-command cbscala:minus "-")
#+end_src
*** Set key bindings
#+begin_src emacs-lisp
(hook-fn 'scala-mode-hook
  (smart-insert-operator-hook)
  (local-unset-key (kbd "."))
  (bind-keys
    :map scala-mode-map
    "=" 'cbscala:equals
    ":" 'cbscala:colon
    "+" 'cbscala:plus
    "-" 'cbscala:minus))
#+end_src
** Evil
*** Adapt scala-mode's join-line command for evil-mode
#+begin_src emacs-lisp
(after 'evil

  (defun cbscala:join-line ()
    "Adapt `scala-indent:join-line' to behave more like evil's line join.

`scala-indent:join-line' acts like the vanilla `join-line',
joining the current line with the previous one. The vimmy way is
to join the current line with the next.

Try to move to the subsequent line and then join. Then manually move
point to the position of the join."
    (interactive)
    (let (join-pos)
      (save-excursion
        (goto-char (line-end-position))
        (unless (eobp)
          (forward-line)
          (call-interactively 'scala-indent:join-line)
          (setq join-pos (point))))

      (when join-pos
        (goto-char join-pos))))

  (evil-define-key 'normal scala-mode-map "J" 'cbscala:join-line))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Haskell
** ignore .hi files
#+begin_src emacs-lisp
(add-to-list 'completion-ignored-extensions ".hi")
#+end_src
** haskell-mode
#+begin_src emacs-lisp
(cb:install-package 'haskell-mode)
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'haskell-mode
#+end_src
** haskell-doc
Provides el-doc-style minibuffer typesignatures.
#+begin_src emacs-lisp
(cb:install-package 'haskell-doc-mode)
#+end_src
*** run in hooks
#+begin_src emacs-lisp
(add-hook 'cb:haskell-modes-hook 'haskell-doc-mode)
(add-hook 'cb:haskell-modes-hook 'turn-on-eldoc-mode)
#+end_src
*** diminish
#+begin_src emacs-lisp
(hook-fn 'haskell-doc-mode-hook
  (diminish 'haskell-doc-mode))
#+end_src
** Define command to switch to src from repl
#+begin_src emacs-lisp
(defun cb:switch-to-haskell ()
  "Switch to the last active Haskell buffer."
  (interactive)
  (-when-let (buf (--first-buffer (derived-mode-p 'haskell-mode)))
    (pop-to-buffer buf)))

(hook-fn 'inferior-haskell-mode-hook
  (local-set-key (kbd "C-c C-z") 'cb:switch-to-haskell))
#+end_src
** indentation
=hi2= is an improved indentation mode for Haskell.
#+begin_src emacs-lisp
(cb:install-package 'hi2)
(add-hook 'haskell-mode-hook 'turn-on-hi2)
#+end_src
** auto-complete
#+begin_src emacs-lisp
(cb:install-package 'haskell-ac t)

(hook-fn 'cb:haskell-modes-hook
  (add-to-list 'ac-modes major-mode)
  (add-to-list 'ac-sources 'ac-source-words-in-same-mode-buffers)
  (add-to-list 'ac-sources 'ac-source-haskell))
#+end_src
** evil
#+begin_src emacs-lisp
(after 'evil
  (defadvice switch-to-haskell (after insert-at-end-of-line activate)
    (evil-insert-state)))
#+end_src
** Stop errors during save from changing window state
#+begin_src emacs-lisp
(defadvice haskell-mode-after-save-handler (around ignore-warnings activate)
  "Prevent subprocess warnings from changing window state."
  (let ((inhibit-redisplay t))
    (save-window-excursion
      ad-do-it)))
#+end_src
** set haskell-mode vars in hook
#+begin_src emacs-lisp
(hook-fn 'haskell-mode-hook
  (setq evil-shift-width     4
        tab-width            4
        haskell-tags-on-save t
        haskell-stylish-on-save t))
#+end_src
** smart operators
*** Impl
#+begin_src emacs-lisp
(defun cbhs:smart-comma ()
  (interactive)
  (cond
   ((s-matches? (rx bol (* space) eol)
                (buffer-substring (line-beginning-position) (point)))
    (insert ", ")
    (hi2-indent-line))
   (t
    (insert ","))))

(defun cbhs:smart-pipe ()
  "Insert a pipe operator. Add padding, unless we're inside a list."
  (interactive)
  (if (s-matches? (rx "[" (* (any "|" alnum)) eol)
                  (buffer-substring (line-beginning-position) (point)))
      (insert "|")
    (smart-insert-operator "|")))

(defun cbhs:looking-at-module-or-constructor? ()
  (-when-let (sym (thing-at-point 'symbol))
    (s-uppercase? (substring sym 0 1))))

(defun cbhs:smart-dot (&optional arg)
  "Insert a period. Add padding, unless this line is an import statement.
With a prefix arg, insert a period without padding."
  (interactive "*P")
  (cond
   (arg
    (insert "."))
   ((cbhs:looking-at-module-or-constructor?)
    (insert "."))
   ((thing-at-point-looking-at (rx (or "(" "{" "[") (* space)))
    (insert "."))
   (t
    (smart-insert-operator "."))))

(defun cbhs:smart-colon ()
  "Insert either a type binding colon pair or a cons colon."
  (interactive)
  (if (s-matches? (rx bol (* space) (? ",") (* space)
                      (+ (not (any space "("))) (* space) eol)
                  (buffer-substring (line-beginning-position) (point)))
      (atomic-change-group
        (just-one-space)
        (insert "::")
        (just-one-space))
    (insert ":")))

(defun cbhs:insert-arrow (arrow)
  "If point is inside a tuple, insert an arrow inside.
Otherwise insert an arrow at the end of the line."
  (atomic-change-group
    (cl-destructuring-bind (&key beg end op &allow-other-keys)
        (sp-get-sexp t)
      ;; Check whether point is inside a tuple.
      (if (and (equal op "(")
               (> (point) beg)
               (< (point) end))
          (sp-end-of-sexp)
        (end-of-line)))
    ;; Insert arrow.
    (just-one-space)
    (insert arrow)
    (just-one-space)))

(defun cbhs:at-typedecl? ()
  (s-matches? "::" (buffer-substring (line-beginning-position) (point))))

(defun cbhs:smart-minus (&optional arg)
  "Insert an arrow if we're in a typesig, otherwise perform a normal insertion.
With a prefix arg, insert an arrow with padding at point."
  (interactive "*P")
  (cond
   (arg
    (just-one-space)
    (insert "->")
    (just-one-space))
   ((cbhs:at-typedecl?)
    (cbhs:insert-arrow "->"))
   (t
    (smart-insert-operator "-"))))

(defun cbhs:smart-lt (&optional arg)
  "Insert a less than symbol. With a prefix arg, insert an arrow at point."
  (interactive "*P")
  (cond
   (arg
    (just-one-space)
    (insert "<-")
    (just-one-space))
   (t
    (smart-insert-operator "<"))))
#+end_src
*** Set key bindings
Because these are set in hooks, the forms below are order-dependent.
=smart-insert-operator-hook= must be called first, so it is added to the list
last.
#+begin_src emacs-lisp
(bind-keys
  :hook cb:haskell-modes-hook
  "," 'cbhs:smart-comma
  "-" 'cbhs:smart-minus
  "=" (command (smart-insert-operator "="))
  "<" 'cbhs:smart-lt
  "." 'cbhs:smart-dot
  ":" 'cbhs:smart-colon
  "|" 'cbhs:smart-pipe
  "?" (command (smart-insert-operator "?"))
  "$" (command (smart-insert-operator "$")))

(add-hook 'cb:haskell-modes-hook 'smart-insert-operator-hook)
#+end_src
** auto-complete
#+begin_src emacs-lisp
(-each cb:haskell-modes (~ add-to-list 'ac-modes))
#+end_src
** Do not use apostrophe smartparens pair
#+begin_src emacs-lisp
(sp-with-modes '(haskell-mode
                 inf-haskell-mode
                 haskell-cabal-mode)
  (sp-local-pair "'" "'" :actions '(:rem insert)))
#+end_src
** hideshow
*** Define helper functions
#+begin_src emacs-lisp
(defun cbhs:next-separator-pos ()
  (save-excursion
    (when (search-forward-regexp (rx bol "---") nil t)
      (ignore-errors (forward-line -1))
      (while (and (emr-blank-line?)
                  (not (bobp)))
        (forward-line -1))
      (end-of-line)
      (point))))

(defun cbhs:next-decl-pos ()
  (save-excursion
    (haskell-ds-forward-decl)
    ;; Skip infix and import groups.
    (while (emr-line-matches? (rx bol (or "import" "infix") (+ space)))
      (haskell-ds-forward-decl))
    (unless (eobp)
      (ignore-errors (forward-line -1))
      (while (and (emr-line-matches? (rx bol (* space) "--" space))
                  (not (bobp)))
        (forward-line -1)))
    (point)))

(defun cbhs:forward-fold (&rest _)
  (let ((sep (cbhs:next-separator-pos))
        (decl (cbhs:next-decl-pos)))
    (goto-char (min (or sep (point-max))
                    (or decl (point-max))))))

#+end_src
*** Configure hideshow
#+begin_src emacs-lisp
(after 'hideshow
  (add-to-list 'hs-special-modes-alist
               `(haskell-mode
                 ;; Beginning function
                 ,(rx (or
                       ;; Function
                       (group  (* nonl) (+ space) "::" (+ space ) (* nonl))
                       ;; FFI declarations.
                       (group (? "foreign") (+ space) "import")
                       ;; Groupings
                       (group (or "class" "instance" "newtype" "data")
                              (+ space) (* nonl))))
                 ;; End function
                 nil
                 ;; Comment start
                 ,(rx "{-")
                 ;; Forward-sexp function
                 cbhs:forward-fold)))
#+end_src
** Insertion commands
*** Insert import statements with helm
#+begin_src emacs-lisp
(defun cbhs:parse-module (str)
  (with-temp-buffer
    (insert str)
    (goto-char (point-min))
    (when (search-forward-regexp (rx bol "exposed-modules: ") nil t)
      (let (start end)
        (setq start (point))
        (setq end (if (search-forward ":" nil t)
                      (progn (beginning-of-line) (point))
                    (point-max)))
        (s-split " " (buffer-substring-no-properties start end) t)))))

(defun cbhs:haskell-modules ()
  "Get a list of all Haskell modules known to GHC."
  (->> (%-string "ghc-pkg" "dump")
    (s-split "---")
    (-mapcat 'cbhs:parse-module)
    (-map 's-trim)))

(defun cbhs:read-import ()
  "Read a module from the user and format as an import statement."
  (interactive)
  (let ((modid
         (helm-comp-read "Import module: "
                         (sort (cbhs:haskell-modules) 'string<)
                         :volatile t
                         :must-match t))
        (qualified? (y-or-n-p "Qualified import? ")))
    (if qualified?
        (format "import qualified %s as %s" modid (read-string "As: "))
      (format "import %s" modid))))

(defun cbhs:insert-import ()
  "Interactively insert a Haskell import statement."
  (interactive)
  (let ((import (cbhs:read-import)))
    ;; Insert the import statement.
    (require 'emr)
    (emr-reporting-buffer-changes "Inserted import"
      (save-excursion
        (goto-char (point-min))

        (cond
         ;; Move directly to import statements.
         ((search-forward-regexp (rx bol "import") nil t))

         ;; Move past module declaration.
         ((search-forward "module" nil t)
          (search-forward "where")
          (forward-line)
          (beginning-of-line)
          (while (and (s-blank? (current-line))
                      (not (eobp)))
            (forward-line)))

         ;; Otherwise insert on first blank line.
         (t
          (until (or (eobp) (s-blank? (current-line)))
            (forward-line))))

        ;; Insert import statement.
        (beginning-of-line)
        (open-line 1)
        (insert import)))))
#+end_src
*** Add to global insertion commands list
#+begin_src emacs-lisp
(-each
 '(("i" "Haskell Import" cbhs:insert-import :modes haskell-mode)
   ("l" "Haskell Language Extension" haskell-insert-language :modes haskell-mode)
   ("p" "GHC Pragma" haskell-insert-pragma :modes haskell-mode)
   ("f" "GHC Flag" haskell-insert-flag :modes haskell-mode))
 (~ add-to-list 'insertion-picker-options))
#+end_src
** Hoogle search method
#+begin_src emacs-lisp
(cbs-define-search-method
 :name "hoogle"
 :key "h"
 :command
 (lambda (q)
   (browse-url (concat "http://www.haskell.org/hoogle/?hoogle="
                       (url-hexify-string (cbs-read "Hoogle" q)))))
 :when
 (lambda ()
   (derived-mode-p 'haskell-mode 'inf-haskell-mode)))
#+end_src
** Apply font-lock to show unicode symbols
#+begin_src emacs-lisp
(defun cbhs:apply-font-lock (pat rep)
  "Call SUBSTITUTE-PATTERN-WITH-UNICODE repeatedly."
  (font-lock-add-keywords
   nil `((,pat
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    ,(string-to-char rep) 'decompose-region)
                    nil))))))

(defun cbhs:font-lock (patterns)
  (--each patterns
    (cl-destructuring-bind (pat rep) it
      (cbhs:apply-font-lock
       (rx-to-string `(and (not (any "\""))
                           (? "`")
                           (group  symbol-start ,pat symbol-end)
                           (? "`")
                           (not (any "\""))))
       rep))))

(defun cbhs:apply-unicode ()
  (cbhs:apply-font-lock
   "\\s ?(?\\(\\\\\\)\\s *\\(\\w\\|_\\|(.*)\\).*?\\s *->" "λ")
  (cbhs:font-lock '(("<-"     "←")
                    ("->"     "→")
                    ("=>"     "⇒")
                    ("."      "•")
                    ("forall" "∀")
                    ("undefined" "⊥")
                    (">="     "≥")
                    ("<="     "≤")
                    ("=="     "≣")
                    ("alpha"  "ɑ")
                    ("beta"   "β")
                    ("gamma"  "ɣ")
                    ("delta"  "δ")
                    ("elem"   "∈")
                    ("notElem" "∉")
                    ("!!"     "‼")
                    ("::"     "∷"))))

(add-hook 'cb:haskell-modes-hook 'cbhs:apply-unicode)
#+end_src
** flycheck
*** Install hdevtools checker
#+begin_src emacs-lisp
(cb:install-package 'flycheck-hdevtools t)
#+end_src
*** Use hdevtools checker for projects and ghc checker for standalone files
#+begin_src emacs-lisp
(defun cbhs:configure-flycheck ()
  (flycheck-select-checker
   (if (and
        (buffer-file-name)
        (locate-dominating-file
         (f-dirname (buffer-file-name))
         (C (~ -any? (~ s-matches? "\\.cabal$")) f-files)))

       'haskell-hdevtools
     'haskell-ghc)))

(add-hook 'haskell-mode-hook 'cbhs:configure-flycheck)
#+end_src
** Key bindings
#+begin_src emacs-lisp
(hook-fn 'cb:haskell-modes-hook
  (local-set-key (kbd "C-c h") 'hoogle)
  (local-set-key (kbd "C-c C-c") 'haskell-process-cabal-build))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Idris
#+begin_src emacs-lisp
(cb:install-package 'idris-mode)
#+end_src
** HACK: redefine idris-mode to derive from prog-mode.
#+begin_src emacs-lisp
(define-derived-mode idris-mode prog-mode "Idris"
  "Major mode for Idris
     \\{idris-mode-map}
Invokes `idris-mode-hook'."
  :syntax-table idris-syntax-table
  :group 'idris
  (set (make-local-variable 'font-lock-defaults)
       idris-font-lock-defaults)
  (set (make-local-variable 'indent-tabs-mode) nil)
  (set (make-local-variable 'comment-start) "--"))
#+end_src
** ignore .idr files
#+begin_src emacs-lisp
(add-to-list 'completion-ignored-extensions ".idr")
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'idris-mode
#+end_src
** Switch to REPL with C-c C-z
#+begin_src emacs-lisp
(define-key idris-mode-map (kbd "C-c C-z") 'idris-switch-to-output-buffer)
#+end_src
** smart operators
*** Impl
#+begin_src emacs-lisp
(defun cbidris:typing-operator-in-braces? ()
  (or (equal (char-before) ?\()
      (and (not (s-matches? (rx alnum) (char-to-string (char-before))))
           (equal (char-after) ?\)))))

(defun cbidris:smart-insert-operator (op)
  "Insert an operator with padding.
Does not pad if inside a pair of brackets.

OP is the operator as a string."
  (let ((pt (point)))
    (cond
     ((cbidris:typing-operator-in-braces?)
      (delete-horizontal-space)
      (insert op))
     (t
      (smart-insert-operator op)))
    (save-excursion
      (goto-char pt)
      (idris-reformat-dwim t))))

(defun cbidris:inserting-cons-in-braces? ()
  (equal (char-after) ?\)))

(defun cbidris:smart-colon ()
  (interactive)
  (cond
   ((equal (string-to-char " ") (char-before))
    (smart-insert-operator ":"))
   ((cbidris:inserting-cons-in-braces?)
    (insert ":"))
   (t
    (smart-insert-operator ":")))

  (idris-reformat-dwim t))

(defun cbidris:smart-comma ()
  (interactive)
  (cond
   ((s-matches? (rx bol (* space) eol)
                (buffer-substring (line-beginning-position) (point)))
    (insert ", ")
    (idris-indentation-indent-line))
   (t
    (insert ","))))

(defun cbidris:smart-pipe ()
  "Insert a pipe operator. Add padding, unless we're inside a list."
  (interactive)
  (if (s-matches? (rx "[" (* (any "|" alnum)) eol)
                  (buffer-substring (line-beginning-position) (point)))
      (insert "|")
    (cbidris:smart-insert-operator "|")))

(defun cbidris:looking-at-module-or-constructor? ()
  (-when-let (sym (thing-at-point 'symbol))
    (s-uppercase? (substring sym 0 1))))

(defun cbidris:smart-dot (&optional arg)
  "Insert a period. Add padding, unless this line is an import statement.
With a prefix arg, insert a period without padding."
  (interactive "*P")
  (cond
   (arg
    (insert "."))
   ((cbidris:looking-at-module-or-constructor?)
    (insert "."))
   ((thing-at-point-looking-at (rx (or "(" "{" "[") (* space)))
    (insert "."))
   (t
    (cbidris:smart-insert-operator "."))))

(defun cbidris:insert-arrow (arrow)
  "If point is inside a tuple or braces, insert an arrow inside.
Otherwise insert an arrow at the end of the line."
  (atomic-change-group
    (cl-destructuring-bind (&key beg end op &allow-other-keys)
        (sp-get-sexp t)
      ;; Check whether point is inside a tuple.
      (if (and (-contains? '("(" "{") op)
               (> (point) beg)
               (< (point) end))
          (sp-end-of-sexp)
        (end-of-line)))
    ;; Insert arrow.
    (just-one-space)
    (insert arrow)
    (just-one-space)))

(defun cbidris:at-typedecl? ()
  (s-matches? (rx space ":" (not (any ":")))
              (buffer-substring (line-beginning-position) (point))))

(defun cbidris:smart-minus (&optional arg)
  "Insert an arrow if we're in a typesig, otherwise perform a normal insertion.
With a prefix arg, insert an arrow with padding at point."
  (interactive "*P")
  (cond
   (arg
    (just-one-space)
    (insert "->")
    (just-one-space))
   ((cbidris:at-typedecl?)
    (cbidris:insert-arrow "->"))
   (t
    (cbidris:smart-insert-operator "-"))))

(defun cbidris:smart-lt (&optional arg)
  "Insert a less than symbol. With a prefix arg, insert an arrow at point."
  (interactive "*P")
  (cond
   (arg
    (just-one-space)
    (insert "<-")
    (just-one-space))
   (t
    (cbidris:smart-insert-operator "<"))))

(defun cbidris:smart-question-mark ()
  "Insert a ? char as an operator, unless point is after an = sign."
  (interactive)
  (cond
   ((s-matches? (rx "=" (* space) eol) (current-line))
    (just-one-space)
    (insert "?"))
   (t
    (cbidris:smart-insert-operator "?"))))
#+end_src
*** Key bindings
#+begin_src emacs-lisp
(define-keys idris-mode-map
  "," 'cbidris:smart-comma
  "&" (command (cbidris:smart-insert-operator "&"))
  "%" (command (cbidris:smart-insert-operator "%"))
  "?" 'cbidris:smart-question-mark
  "*" (command (cbidris:smart-insert-operator "*"))
  "+" (command (cbidris:smart-insert-operator "+"))
  "/" (command (cbidris:smart-insert-operator "/"))
  "-" 'cbidris:smart-minus
  "=" (command (cbidris:smart-insert-operator "="))
  "<" 'cbidris:smart-lt
  ">" (command (cbidris:smart-insert-operator ">"))
  "." 'cbidris:smart-dot
  ":" 'cbidris:smart-colon
  "|" 'cbidris:smart-pipe
  "$" (command (cbidris:smart-insert-operator "$")))
#+end_src
** auto-complete
#+begin_src emacs-lisp
(add-hook 'cb:idris-modes-hook 'auto-complete-mode)
#+end_src
** Use font lock to display Unicode symbols in Idris buffers
#+begin_src emacs-lisp
(defun cbidris:apply-font-lock (pat rep)
  "Call SUBSTITUTE-PATTERN-WITH-UNICODE repeatedly."
  (font-lock-add-keywords
   nil `((,pat
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    ,(string-to-char rep) 'decompose-region)
                    nil))))))

(defun cbidris:font-lock (patterns)
  (--each patterns
    (cl-destructuring-bind (pat rep) it
      (cbidris:apply-font-lock
       (rx-to-string `(and (not (any "\""))
                           (? "`")
                           (group  symbol-start ,pat symbol-end)
                           (? "`")
                           (not (any "\""))))
       rep))))

(defun cbidris:apply-unicode ()
  (cbidris:apply-font-lock
   "\\s ?(?\\(\\\\\\)\\s *\\(\\w\\|_\\|(.*)\\).*?\\s *=>" "λ")
  (cbidris:font-lock '(("<-"     "←")
                       ("->"     "→")
                       ("=>"     "⇒")
                       ("."      "•")
                       ("_|_"    "⊥")
                       (">="     "≥")
                       ("<="     "≤")
                       ("=="     "≣"))))

(add-to-list 'font-lock-keywords-alist
             '(idris-mode
               ((("^ *record\\>" . font-lock-keyword-face)))))

(add-hook 'cb:idris-modes-hook 'cbidris:apply-unicode)
#+end_src
** smartparens
#+begin_src emacs-lisp
(defun sp-idris-just-one-space (id action ctx)
  "Pad parens with spaces."
  (when (and (equal 'insert action)
             (sp-in-code-p id action ctx))
    ;; Insert a leading space, unless
    ;; 1. this is a quoted form
    ;; 2. this is the first position of another list
    ;; 3. this form begins a new line.
    (save-excursion
      (search-backward id)
      (unless (s-matches?
               (rx (or (group bol (* space))
                       (any "," "`" "@" "(" "[" "{")) eol)
               (buffer-substring (line-beginning-position) (point)))
        (just-one-space)))
    ;; Insert space after separator, unless
    ;; 1. this form is at the end of another list.
    ;; 2. this form is at the end of the line.
    (save-excursion
      (search-forward (sp-get-pair id :close))
      (unless (s-matches? (rx (or (any ")" "]" "}")
                                  eol))
                          (buffer-substring (point) (1+ (point))))
        (just-one-space)))))

(sp-with-modes cb:idris-modes
  ;; Pad delimiters with spaces.
  (sp-local-pair "\"" "\"" :post-handlers '(:add sp-idris-just-one-space))
  (sp-local-pair "{" "}" :post-handlers '(:add sp-idris-just-one-space))
  (sp-local-pair "[" "]" :post-handlers '(:add sp-idris-just-one-space))
  (sp-local-pair "(" ")" :post-handlers '(:add sp-idris-just-one-space))
  (sp-local-pair "'" nil :actions nil))
(sp-with-modes cb:idris-modes
  (sp-local-pair "'" "'" :actions '(:rem insert)))
#+end_src
** eldoc
#+begin_src emacs-lisp
(defun cbidris:get-docstring ()
  "Format a docstring for eldoc."
  (ignore-errors
    (-when-let* ((name (car (idris-thing-at-point)))
                 (s (idris-eval `(:type-of ,name))))
      (nth 1 (s-match (rx (* (any "-" "\n" space)) (group (* anything)))
                      s)))))

(defun cbidris:configure-eldoc ()
  "Set up eldoc for Idris."
  (setq-local eldoc-documentation-function 'cbidris:get-docstring)
  (eldoc-mode +1))

(add-hook 'cb:idris-modes-hook 'cbidris:configure-eldoc)
#+end_src
** switching from repl to src
#+begin_src emacs-lisp
(defun idris-switch-to-src ()
  "Pop to the last idris source buffer."
  (interactive)
  (-if-let (buf (car (--filter-buffers (derived-mode-p 'idris-mode))))
      (pop-to-buffer buf)
    (error "No idris buffers")))

(after 'idris-repl
  (define-key idris-repl-mode-map (kbd "C-c C-z") 'idris-switch-to-src))
#+end_src
** automatically indent code on RET
*** format datatypes
#+begin_src emacs-lisp
(defun cbidris:data-start-pos ()
  "Find the start position of the datatype declaration at point."
  (save-excursion
    (end-of-line)
    (when (search-backward-regexp (rx bol (* space) (or "record" "data") eow) nil t)
      (skip-chars-forward " \t")
      (point))))

(defun cbidris:data-end-pos ()
  "Find the end position of the datatype declaration at point."
  (save-excursion
    (let ((start (point)))

      (goto-char (cbidris:data-start-pos))
      (forward-line)
      (goto-char (line-beginning-position))

      (let ((end
             (when (search-forward-regexp
                    (rx bol (or (and (* space) eol) (not (any space "|"))))
                    nil t)
               (forward-line -1)
               (line-end-position))))
        (if (and end (<= start end))
            end
          (point-max))))))

(cl-defun cbidris:data-decl-at-pt ()
  "Return the data declaration at point."
  (-when-let* ((start (cbidris:data-start-pos))
               (end (cbidris:data-end-pos)))
    (buffer-substring-no-properties start end)))

(defun cbidris:at-data-decl? ()
  (-when-let (dd (cbidris:data-decl-at-pt))
    (let ((lines (s-split "\n" dd)))
      (or (equal 1 (length lines))
          (->> (-drop 1 lines)
            (-all? (~ s-matches? (rx bol (or space "|")))))))))

(cl-defun cbidris:goto-type-judgement-colon
    (&optional (bound (cbidris:data-end-pos)))
  (let (done)
    (goto-char (line-beginning-position))
    (while (and (not done)
                (search-forward " : " bound t))
      (unless (sp-get-enclosing-sexp)
        (search-backward ":")
        (setq done t)))
    done))

(defun cbidris:max-colon-column-in-data ()
  "Find the greatest column of type judgements in a data decl."
  (->> (save-excursion
         (cl-loop
          while (and (not (eobp))
                     (cbidris:at-data-decl?))
          if (cbidris:goto-type-judgement-colon)
          collect (current-column)
          do (progn
               (forward-line)
               (end-of-line))))
    (-remove 'null)
    (cons 0)
    (-max)))

(defun cbidris:line-is-unfinished-type-judgement? (line-no)
  (save-excursion
    (goto-char (point-min))
    (forward-line (1- line-no))
    (s-matches? (rx "->" (* space) eol) (current-line))))

(defun cbidris:indent-data-decl ()
  "Indent the data decl at point."
  (when (< 1 (->> (cbidris:data-decl-at-pt)
               (s-split "\n")
               (length)))
    (let ((end-ln (line-number-at-pos (cbidris:data-end-pos))))
      (save-excursion

        ;; Indent each line in the decl to the column of the first identifier.
        (goto-char (cbidris:data-start-pos))
        (let ((datatype-ident-col
               (progn
                 (search-forward-regexp (rx (or "record" "data") (+ space)))
                 (just-one-space)
                 (current-column))))
          (forward-line)

          (let (done current-type-judgement-col)
            (while (and (not done) (<= (line-number-at-pos (point)) end-ln))
              (goto-char (line-beginning-position))
              (delete-horizontal-space)

              ;; Align multi-line type judgements after the colon.
              (if (cbidris:line-is-unfinished-type-judgement? (1- (line-number-at-pos)))
                  (indent-to (+ 2 current-type-judgement-col))

                ;; Indent new constructors to the same column as the first
                ;; identifier after the data keyword.
                (indent-to datatype-ident-col)
                (setq current-type-judgement-col
                      (save-excursion
                        (goto-char (line-beginning-position))
                        (cbidris:goto-type-judgement-colon)
                        (current-column))))

              ;; If it's not the end of the buffer, continue the loop.
              (if (save-excursion (goto-char (line-end-position))
                                  (eobp))
                  (setq done t)
                (forward-line)))))))))

(defun cbidris:normalise-data-decl-colons ()
  (save-excursion
    (let ((start (cbidris:data-start-pos)))

      (goto-char start)
      (while (search-forward-regexp
              (rx space ":" (or space eol))
              (cbidris:data-end-pos) t)
        (save-excursion
          (just-one-space)
          (search-backward ":")
          (just-one-space)))

      (goto-char start)
      (let ((col (cbidris:max-colon-column-in-data))
            done)
        (while (and (not done)
                    (cbidris:at-data-decl?))
          (when (cbidris:goto-type-judgement-colon)
            (indent-to col))
          (goto-char (line-end-position))
          (if (eobp)
              (setq done t)
            (forward-line)))))))

(defun cbidris:at-sum-type? ()
  "Non-nil if point is at a data decl for a sum type."
  (s-matches? (rx bol (* space) "data" (* nonl) "=")
              (cbidris:data-decl-at-pt)))

(defun cbidris:align-sum-cases ()
  "Align cases of a sum type with the '=' sign."
  (save-excursion
    ;; Ensure the '=' sign is surrounded by single spaces.
    (goto-char (cbidris:data-start-pos))
    (search-forward-regexp (rx space "=" (not (any "="))))
    (just-one-space)
    (search-backward "=")
    (just-one-space)
    (let ((col (current-column))
          done)
      (forward-line)
      (goto-char (line-end-position))
      (while (and (not done)
                  (cbidris:at-data-decl?))
        (when (s-matches? (rx bol (* space) "|") (current-line))
          (goto-char (line-beginning-position))
          (search-forward "|")
          (backward-char)
          (indent-to col))
        (goto-char (line-end-position))
        (if (eobp)
            (setq done t)
          (forward-line))))))

(defun cbidris:format-data-decl ()
  "Align colons in a datatype declaration."
  (when (cbidris:at-data-decl?)
    (cond
     ((cbidris:at-sum-type?)
      (cbidris:align-sum-cases))

     (t
      (cbidris:indent-data-decl)
      (cbidris:normalise-data-decl-colons)))

    t))
#+end_src
*** format functions
#+begin_src emacs-lisp
(defun cbidris:after-function-args? ()
  "Non-nil if point is at a function application."
  (let ((fst-equals (s-index-of "=" (current-line))))
    (and (< fst-equals (current-column)))))

(defun cbidris:at-let-binding? ()
  "Non-nil if point is at a let-binding form."
  (s-matches? (rx bow "let" eow) (current-line)))

(defun cbidris:at-equation? ()
  "Non-nil if point is at a function definition or equation."
  (and (s-matches? (rx space "=" (or space eol)) (current-line))
       (not (cbidris:at-let-binding?))
       (not (cbidris:after-function-args?))))

(defun cbidris:function-case-lines (fname)
  "Return a list of lines for the function FNAME."
  (save-excursion
    (cl-loop
     initially (goto-char (point-min))
     while (search-forward-regexp (rx-to-string `(and bol (* space)
                                                      (? "(") ,fname (? ")")))
                                  nil t)
     unless (s-matches? " : " (current-line))
     collect (line-number-at-pos))))

(-each '("record" "data") (~ add-to-list 'idris-keywords))

(defun cbidris:function-name-at-pt ()
  "Return the name of the function at point."
  (save-excursion
    (search-backward-regexp (rx bol (* space) (group (+ (not (any space ":"))))))
    (let ((s (s-trim (match-string-no-properties 1))))
      (unless (or (-contains? idris-keywords s)
                  (s-blank? s))
        s))))

(defun cbidris:pad-tokens (lines)
  "For each line in LINES, align tokens in columns by right-padding with whitespace."
  (cl-loop
   ;; Calculate leading indentation for lines.
   for indent-column =
   (-max (cons 0 (-map (C length cadr (~ s-match (rx bol (group (* space)))))
                       lines)))
   for indentation = (s-repeat indent-column " ")
   ;; Split lines into a matrix of argument expressions.
   for split-lines = (-map 's-split-sexps lines)
   ;; Pad with whitespace. This requires a matrix transposition before we can calculate
   ;; the width for each row.
   for padded =
   (cl-loop for col from 0 upto (-max (cons 0 (-map 'length split-lines)))
            for rows = (-map (~ nth col) split-lines)
            for widest = (-max (-map 'length rows))
            collect (-map (~ s-pad-right widest " ") rows))
   ;; Transpose matrix again to restore original ordering.
   for col from 0 upto (-max (cons 1 (-map 'length padded)))
   for (ident . argv) = (-map (~ nth col) padded)
   collect (cons (s-prepend indentation ident) argv)))

(defun cbidris:columnate-arguments (lines)
  "Align function arguments by column for each line in LINE-NOS."
  (let* ((padded
          (->> (cbidris:pad-tokens lines)
            ;; Manually pad and align '=' sign, in case some equations are partial.
            (-map (C (~ s-chop-suffix "=") s-trim-right (~ s-join " ")))))
         (widest-arglist (-max (cons 0 (-map 'length padded)))))
    (->> padded
      (-remove (~ s-matches? (rx bol (* space) eol)))
      (-map (C (~ s-append "=") (~ s-pad-right widest-arglist " "))))))

(defun cbidris:bol-to-s (rx line-no)
  "Return the part of the line at LINUM from the line start up to RX."
  (save-excursion
    (goto-char (point-min))
    (forward-line (1- line-no))
    (buffer-substring-no-properties (line-beginning-position)
                                    (search-forward-regexp rx nil t))))

(defun cbidris:normalise-function-decl-arguments ()
  (let* ((linums (cbidris:function-case-lines (cbidris:function-name-at-pt)))
         (replacements (cbidris:columnate-arguments
                        (-map (~ cbidris:bol-to-s "=") linums))))
    (-each (-zip linums replacements)
           (lambda+ ((linum . s))
             (save-excursion
               (goto-char (point-min))
               (forward-line (1- linum))
               (search-forward-regexp (rx bol (group (+ (not (any "="))) "="))
                                      (line-end-position))
               (replace-match s t))))))

(defun cbidris:format-function-args ()
  "Align function declaration arguments."
  (when (cbidris:at-equation?)
    (cbidris:normalise-function-decl-arguments)
    t))
#+end_src
*** define reformatting command
#+begin_src emacs-lisp
(defun idris-reformat-dwim (&optional silent?)
  "Perform a context-sensitive reformatting command.
SILENT? controls whether provide feedback to the user on the action performed."
  (interactive "*")
  ;; HACK: Set point manually--something is moving point to the line start pos.
  (let ((pt (point)))
    (save-excursion
      (cond
       ((cbidris:format-data-decl)
        (unless silent?
          (message "Formatted data declaration.")))
       ((cbidris:format-function-args)
        (unless silent?
          (message "Formatted function arguments.")))
       (t
        (unless silent?
          (message "No context to reformat")))))
    (goto-char (max (point) pt))))
#+end_src
*** Define custom newline commands
#+begin_src emacs-lisp
(defun idris-ret ()
  "Indent and align on newline."
  (interactive "*")
  (if (s-matches? comment-start (current-line))
      (comment-indent-new-line)
    (idris-reformat-dwim t)

    (cond

     ((s-matches? (rx space "->" (* space))
                  (buffer-substring (line-beginning-position) (point)))
      (newline)
      (delete-horizontal-space)
      (indent-for-tab-command))

     ((s-matches? (rx bol (* space) eol) (current-line))
      (delete-horizontal-space)
      (newline))

     (t
      (idris-newline-and-indent)))))

(defun idris-meta-ret ()
  "Create a newline and perform a context-sensitive continuation.
- At functions, create a new case for the function.
- At types, add a 'where' statement if one does not exist.
- At comments, fill paragraph and insert a newline."
  (interactive)
  (cond
   ((cbidris:at-data-decl?)
    (let ((dt (cbidris:data-decl-at-pt)))

      (unless (s-contains? "where" dt)
        (save-excursion
          (goto-char (cbidris:data-start-pos))
          (unless (s-matches? (rx space "=" (not (any "="))) (current-line))
            (goto-char (line-end-position))
            (just-one-space)
            (insert "where"))))

      (goto-char (line-end-position))
      (idris-ret)))

   ((cbidris:function-name-at-pt)
    (goto-char (line-end-position))
    (let ((fn (cbidris:function-name-at-pt)))

      (unless (s-matches? (rx bol (* space) eol) (current-line))
        (newline-and-indent))

      (insert fn)
      (just-one-space)))

   ((s-matches? comment-start (current-line))
    (fill-paragraph)
    (comment-indent-new-line))

   (t
    (goto-char (line-end-position))
    (idris-ret))))
#+end_src
*** Set key bindings
#+begin_src emacs-lisp
(define-keys idris-mode-map
  "M-q" 'idris-reformat-dwim
  "<return>" 'idris-ret
  "M-<return>" 'idris-meta-ret)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Mutt
#+begin_src emacs-lisp
(cb:install-package 'muttrc-mode)
#+end_src
* Load personal config
The personal config file may be used to store sensitive information such as
passwords. It may be anywhere on the load path.

#+begin_src emacs-lisp
(require 'personal-config nil t)
#+end_src
* Define functions for [[file:Makefile][Makefile]]
#+begin_src emacs-lisp
(defun byte-compile-conf ()
  "Recompile all configuration files."
  (interactive)
  (byte-recompile-file (concat user-emacs-directory "init.el") t 0)
  (when (boundp 'cb:lisp-dir)
    (byte-recompile-directory cb:lisp-dir 0 t)))
#+end_src
