#+TITLE: Config: Orgmode
#+DESCRIPTION: Configuration options loaded at Emacs startup.
#+AUTHOR: Chris Barrett
#+OPTIONS: toc:3 num:nil ^:nil

org-mode is a suite of editing and management tools centred around
human-readable text files. See http://orgmode.org/.

* Set file paths
** Create a var to hold the original value of the notes file
=org-default-notes-file= may be changed interactively by
=cb-org:set-notes-file=, so we need a reference to the original for some
functions.
#+begin_src emacs-lisp
(defvar org-init-notes-file org-default-notes-file
  "Captures the original value of the `org-default-notes-file'.")
#+end_src
** Clock persist file
The clock persist file is used to save clocking data between sessions. It allows
org to restart interrupted clocks.
#+begin_src emacs-lisp
(setq org-clock-persist-file  (f-join org-directory ".org-clock-save"))
#+end_src
** Miscellaneous file paths
#+begin_src emacs-lisp
(setq org-id-locations-file   (f-join cb:tmp-dir "org-id-locations")
      org-agenda-diary-file   (f-join org-directory "diary.org")
      calendar-date-style     'european)
#+end_src
* Customise miscellaneous vars
#+begin_src emacs-lisp
(setq org-completion-use-ido t
      org-link-mailto-program (quote (compose-mail "%a" "%s"))
      org-insert-heading-respect-content nil
      org-M-RET-may-split-line nil
      org-blank-before-new-entry nil
      org-catch-invisible-edits 'smart
      org-return-follows-link t
      org-support-shift-select t)
#+end_src
* Automatically renumber footnotes
#+begin_src emacs-lisp
(setq org-footnote-auto-adjust t)
#+end_src
* Auto-revert org files
Since they are under VC with git-auto-push, this should keep them in sync if
they are changed on different computers.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-revert-mode)
#+end_src
* Use auto-fill
This will automatically insert line breaks to keep lines shorter
than =fill-column=.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
* Diminish org minor modes
#+begin_src emacs-lisp
(hook-fn 'cb:org-minor-modes-hook
  (--each cb:org-minor-modes
    (ignore-errors (diminish it))))
#+end_src
* Drawers
#+begin_src emacs-lisp
(setq org-drawers '("COMMENTS" "NOTES" "PROPERTIES"
                    "CLOCK" "LOGBOOK" "RESULTS"))
#+end_src
* Display style
#+begin_src emacs-lisp
(setq org-put-time-stamp-overlays t
      org-indirect-buffer-display 'current-window
      org-startup-indented t
      org-startup-with-inline-images t
      org-cycle-separator-lines 0)
#+end_src
* Render latex-style character sequences as unicode chars
#+begin_src emacs-lisp
(setq org-pretty-entities t)
#+end_src
* Logging
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-log-done 'time
      org-reverse-note-order nil)
#+end_src
* Modal views
Add executors for common org views.
#+begin_src emacs-lisp
(declare-modal-executor org-agenda-fullscreen
  :command (if cb-org:at-work?
               (org-agenda current-prefix-arg "w")
             (org-agenda current-prefix-arg "A")))

(declare-modal-executor org-show-todo-list
  :command (progn
             (org-agenda prefix-arg "t")
             (org-agenda-filter-apply '("-someday") 'tag)))

(declare-modal-executor org-tags-view-todos-fullscreen
  :command (org-tags-view t))

(declare-modal-executor org-tags-view-all-fullscreen
  :command (org-tags-view nil))

(declare-modal-executor org-search-view
  :command (call-interactively 'org-search-view))
#+end_src
* Org command picker
** Utilities
#+begin_src emacs-lisp
(defun cb-org:yank-region-as-quote (beg end)
  "Yank the current region as an org quote."
  (interactive "r")
  (if (region-active-p)
      (progn
        (kill-new (cb-org:buffer-substring-to-quote beg end))
        (deactivate-mark)
        (message "Region yanked as quote."))
    (error "No region is active, so no quote could be yanked")))

(defun cb-org:set-notes-file (file)
  "Select the notes file to use as the default.
This will set which file org-capture will capture to."
  (interactive
   (list
    (let* ((fs (org-files-list))
           (selected
            (ido-completing-read
             "File: "
             (->> fs
               (-remove (C (~ equal "org_archive") f-ext))
               (-map 'f-filename)))))
      (-first (C (~ equal selected) f-filename) fs))))
  (setq org-default-notes-file file))

(defun cb-org:find-diary ()
  (interactive)
  (find-file org-agenda-diary-file))

(defun cb-org:find-notes ()
  (interactive)
  (find-file org-default-notes-file))

(defun cb-org:capture ()
  "Adapt `org-capture' to my own selection widget."
  (interactive)
  (let ((k (car (read-option "*Org Capture*" 'car 'cadr
                             org-capture-templates))))
    (org-capture nil k)))
#+end_src
** Impl
#+begin_src emacs-lisp
(define-command-picker org-action-picker
  :title "*Org Commands*"
  :options
  `(("a" "Agenda" org-agenda)
    ("b" "Buffers" org-iswitchb)
    ("c" "Follow Clock" org-clock-goto)
    ("d" "Go to Diary" cb-org:find-diary)
    ("f" "Set Notes File" cb-org:set-notes-file)
    ("g" "Go to Subtree" ,(command (org-refile 'goto)))
    ("k" "Capture" cb-org:capture)
    ("l" "Store Link" org-store-link)
    ("n" "Go to Notes" cb-org:find-notes)
    ("s" "Search" executor:org-search-view)
    ("t" "Todo List" executor:org-show-todo-list)
    ("v" "View Tags (todos)" executor:org-tags-view-todos-fullscreen)
    ("V" "View Tags (all)" executor:org-tags-view-all-fullscreen)
    ("y" "Yank Region as Quote" cb-org:yank-region-as-quote :when region-active-p)))
#+end_src

* Notes
** Prevent attempts to expand the minibuffer
#+begin_src emacs-lisp
(defadvice org-add-log-note (before exit-minibuffer activate)
  (when (minibufferp (window-buffer (selected-window)))
    (other-window 1)))
#+end_src
* Statistics
Perhaps confusingly, setting hierarchy vars to non-nil values makes statistics
functions shallow.
#+begin_src emacs-lisp
(setq org-hierarchical-todo-statistics nil
      org-checkbox-hierarchical-statistics t)
#+end_src
* Tags
Make GTD context tags available in all buffers.
#+begin_src emacs-lisp
(setq org-tag-persistent-alist
      '((:startgroup . nil)
        ("@computer" . ?c)
        ("@errand" . ?e)
        ("@home" . ?h)
        ("@leisure" . ?l)
        ("@phone" . ?p)
        ("@work" . ?w)
        (:endgroup . nil)))
#+end_src
* Clocking
#+begin_src emacs-lisp
(require 'org-clock)
#+end_src
** Persist the clock across Emacs sessions
#+begin_src emacs-lisp
(unless noninteractive
  (setq org-clock-persist t)
  (org-clock-persistence-insinuate))
#+end_src
** Clock out of tasks automatically when they are marked as DONE
#+begin_src emacs-lisp
(setq org-clock-out-when-done t)
#+end_src
** Automatically resume interrupted clocks when starting Emacs
#+begin_src emacs-lisp
(setq org-clock-persist-query-resume nil)
#+end_src
** Add clocking info to a special drawer
#+begin_src emacs-lisp
(setq org-clock-into-drawer t)
#+end_src
** Increase clock history length
#+begin_src emacs-lisp
(setq org-clock-history-length 20)
#+end_src
** Customise clock resolution
#+begin_src emacs-lisp
(setq org-clock-in-resume t
      org-clock-auto-clock-resolution 'when-no-clock-is-running)
#+end_src
** Include the running clock when generating clocking reports
#+begin_src emacs-lisp
(setq org-clock-report-include-clocking-task t)
#+end_src
** Utilities used by clocking customisations
#+begin_src emacs-lisp
(defun cb-org:project? ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun cb-org:task? ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
#+end_src
** Clocking into a TODO changes state to NEXT
#+begin_src emacs-lisp
(defun cb-org:clock-in-to-next-state (_kw)
  "Move a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO."
  (unless (true? org-capture-mode)
    (cond
     ((and (-contains? '("TODO") (org-get-todo-state))
           (cb-org:task?))
      "NEXT")
     ((and (-contains? '("NEXT") (org-get-todo-state))
           (cb-org:project?))
      "TODO"))))

(setq org-clock-in-switch-to-state 'cb-org:clock-in-to-next-state)
#+end_src

** Automatically change clocked projects from NEXT to TODO
#+begin_src emacs-lisp
(defun cb-org:mark-next-parent-tasks-todo ()
  "Visit each parent task and change state to TODO"
  (let ((mystate (or (and (fboundp 'org-state)
                          state)
                     (nth 2 (org-heading-components)))))
    (when mystate
      (save-excursion
        (while (org-up-heading-safe)
          (when (-contains? '("NEXT" "WAITING" "MAYBE")
                            (nth 2 (org-heading-components)))
            (org-todo "TODO")))))))

(hook-fns '(org-after-todo-state-change-hook org-clock-in-hook)
  :append t
  (cb-org:mark-next-parent-tasks-todo))
#+end_src
** Remove empty clock entries
#+begin_src emacs-lisp
(setq org-clock-out-remove-zero-time-clocks t)
#+end_src
** Remove empty LOGBOOK drawers when clocking out
#+begin_src emacs-lisp
(hook-fn 'org-clock-out-hook
  :append t
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at "LOGBOOK" (point))))
#+end_src

* Effort estimates
#+begin_src emacs-lisp
(add-to-list 'org-global-properties
             `("Effort_ALL" . ,(concat "1:00 2:00 3:00 4:00 "
                                       "5:00 6:00 7:00 8:00 9:00 "
                                       "0:05 0:10 0:30")))
#+end_src
* Customise capture templates
#+begin_src emacs-lisp
(defvar org-work-capture-templates nil
  "Capture templates that should only be available when at work.")

(defvar org-home-capture-templates
  `(
    ("m" "Listening" entry
     (file+olp org-default-notes-file "Media" "Listening")
     "* MAYBE Listen to %i%?"
     :clock-keep t)

    ("v" "Viewing" entry
     (file+olp org-default-notes-file "Media" "Viewing")
     "* MAYBE Watch %i%?"
     :clock-keep t)

    ("r" "Reading" entry
     (file+olp org-default-notes-file "Media" "Reading")
     "* MAYBE Read %i%?"
     :clock-keep t)
    )
  "Capture templates that should only be available when not at work.")

(require 'org-capture)
(-each `(("t" "Todo" entry
          (file+olp org-default-notes-file "Tasks")
          "* TODO %?"
          :clock-keep t)

         ("d" "Diary" entry
          (file+datetree org-agenda-diary-file)
          "* %?\n%^t"
          :clock-keep t)

         ("h" "Habit" entry
          (file+olp org-default-notes-file "Habits/Recurring")
          ,(s-unlines
            "* TODO %?"
            "SCHEDULED: %t"
            ":PROPERTIES:"
            ":STYLE: habit"
            ":END:")
          :clock-keep t)

         ("l" "Link" entry
          (file+olp org-default-notes-file "Links")
          "* %c\n%i"
          :immediate-finish t
          :clock-keep t)

         ("s" "Someday" entry
          (file+olp org-default-notes-file "Someday")
          "* MAYBE %?"
          :clock-keep t)

         ("S" "Shopping" checkitem
          (file+olp org-default-notes-file "Tasks" "Shopping")
          "- [ ] %?"
          :clock-keep t)

         ("z" "Note" entry
          (file+olp org-default-notes-file "Notes")
          "* %i%?"
          :clock-keep t)
         )
  (~ add-to-list 'org-capture-templates))

(-each org-home-capture-templates (~ add-to-list 'org-capture-templates))
#+end_src
* Clocking in/out for work
#+begin_src emacs-lisp
(defvar org-work-file (f-join org-directory "work.org")
  "Defines the path to file for work-related todos, etc.")

(defvar cb-org:work-persistence-file (f-join cb:tmp-dir ".org-at-work")
  "File to create that saves work state between sessions.")

(defvar cb-org:at-work? nil "Non-nil if currently 'at work'.")

(defun cb-org:goto-or-create-work-log ()
  (cl-destructuring-bind (_s _m _h d mo y &rest _)
      (decode-time (current-time))
    (org-datetree-find-date-create (list mo d y))))

(defun cb-org:start-work (file)
  (cb-org:set-notes-file file)
  (with-current-buffer (find-file-noselect file)
    (cb-org:goto-or-create-work-log)
    (org-clock-in))
  (setq cb-org:at-work? t)

  (setq org-capture-templates
        (-difference (-union org-capture-templates
                             org-work-capture-templates)
                     org-home-capture-templates))

  (f-touch cb-org:work-persistence-file)
  (message "Started work"))

(defun cb-org:leave-work (file)
  (with-current-buffer (find-file-noselect file)
    (cb-org:goto-or-create-work-log)
    (org-clock-out nil t))

  (cb-org:set-notes-file org-init-notes-file)
  (setq cb-org:at-work? nil)
  (setq org-capture-templates
        (-union (-difference org-capture-templates
                             org-work-capture-templates)
                org-home-capture-templates))

  (when (f-exists? cb-org:work-persistence-file)
    (f-delete cb-org:work-persistence-file))

  (message "Left work"))

(defun cb-org:toggle-at-work (file)
  "Toggle whether I am currently at work.
FILE is the file to use as the notes file while at work."
  (interactive (list org-work-file))
  (if (equal org-default-notes-file org-init-notes-file)
      (cb-org:start-work file)
    (cb-org:leave-work file))
  (when (derived-mode-p 'org-agenda-mode)
    (executor:org-agenda-fullscreen)))

(defun cb-org:maybe-set-to-work ()
  "Set status to 'at-work' if the work persistence file exists."
  (if (f-exists? cb-org:work-persistence-file)
      (cb-org:start-work org-work-file)
    (-each org-home-capture-templates
      (~ add-to-list 'org-capture-templates))))

(add-hook 'after-init-hook 'cb-org:maybe-set-to-work)

(bind-key "<f12>" 'cb-org:toggle-at-work)
#+end_src
* Projects
#+begin_src emacs-lisp
(setq org-stuck-projects
      '("+project&TODO={.+}/-DONE-CANCELLED"
        ("NEXT" "TODO") nil "\\<IGNORE\\>"))
#+end_src
* Refiling
#+begin_src emacs-lisp
(setq org-refile-use-outline-path t
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm
      org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))
#+end_src
** Exclude todo keywords with a DONE state from refile targets
#+begin_src emacs-lisp
(setq org-refile-target-verify-function
      (lambda ()
        (not (member (nth 2 (org-heading-components))
                     org-done-keywords))))
#+end_src
* Attachments
#+begin_src emacs-lisp
(require 'org-attach)
(setq org-link-abbrev-alist '(("att" . org-attach-expand-link))
      org-attach-directory (f-join org-directory "data"))
#+end_src
** Redefine `org-attach-attach' to use ido to read files
#+begin_src emacs-lisp
(defun org-attach-attach (file &optional visit-dir method)
  "Move/copy/link FILE into the attachment directory of the current task.
If VISIT-DIR is non-nil, visit the directory with dired. METHOD
may be `cp', `mv', `ln', or `lns' default taken from
`org-attach-method'."
  (interactive
   (list
    (ido-read-file-name "File to keep as an attachment: " nil nil t)
    current-prefix-arg))
  (setq method (or method org-attach-method))
  (let ((basename (file-name-nondirectory file)))
    (when (and org-attach-file-list-property (not org-attach-inherited))
      (org-entry-add-to-multivalued-property
       (point) org-attach-file-list-property basename))
    (let* ((attach-dir (org-attach-dir t))
           (fname (expand-file-name basename attach-dir)))
      (cond
       ((eq method 'mv) (rename-file file fname))
       ((eq method 'cp) (copy-file file fname))
       ((eq method 'ln) (add-name-to-file file fname))
       ((eq method 'lns) (make-symbolic-link file fname)))
      (org-attach-commit)
      (org-attach-tag)
      (cond ((eq org-attach-store-link-p 'attached)
             (org-attach-store-link fname))
            ((eq org-attach-store-link-p t)
             (org-attach-store-link file)))
      (if visit-dir
          (dired attach-dir)
        (message "File \"%s\" is now a task attachment." basename)))))
#+end_src
* Archiving
#+begin_src emacs-lisp
(require 'org-archive)
#+end_src
** Apply inherited tags to archived items
#+begin_src emacs-lisp
(defadvice org-archive-subtree
  (before add-inherited-tags-before-org-archive-subtree activate)
  "Add inherited tags before org-archive-subtree."
  (org-set-tags-to (org-get-tags-at)))
#+end_src
** Archive only DONE tasks by default
#+begin_src emacs-lisp
(defun cb-org:archive-done-tasks ()
  (interactive)
  (atomic-change-group
    (org-map-entries (lambda ()
                       ;; Ensure point does not move past the next item to
                       ;; archive.
                       (setq org-map-continue-from (point))
                       (org-archive-subtree))
                     "/DONE|PAID|VOID|CANCELLED" 'tree)))

(setq org-archive-default-command 'cb-org:archive-done-tasks)
#+end_src
* Encryption
#+begin_src emacs-lisp
(require 'org-crypt)
#+end_src
** Enable auto-encryption
#+begin_src emacs-lisp
(org-crypt-use-before-save-magic)
(setq org-crypt-disable-auto-save 'encypt)
#+end_src
** Do not inherit encryption property
Prevents nested encrypting.
#+begin_src emacs-lisp
(add-to-list 'org-tags-exclude-from-inheritance "crypt")
#+end_src
** Extend org C-c C-c command to decrypt entry at point
#+begin_src emacs-lisp
(defun cb-org:looking-at-pgp-section? ()
  (unless (org-before-first-heading-p)
    (save-excursion
      (org-back-to-heading t)
      (let ((heading-point (point))
            (heading-was-invisible-p
             (save-excursion
               (outline-end-of-heading)
               (outline-invisible-p))))
        (forward-line)
        (looking-at "-----BEGIN PGP MESSAGE-----")))))

(defun cb-org:decrypt-entry ()
  (when (cb-org:looking-at-pgp-section?)
    (org-decrypt-entry)
    t))

(add-hook 'org-ctrl-c-ctrl-c-hook 'cb-org:decrypt-entry)
#+end_src
* MIME
Provides MIME exporting functions, allowing you to export org buffers to HTML
emails.
#+begin_src emacs-lisp
(require 'org-mime)
#+end_src
** Define key bindings for HTML conversion commands
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c M-o") 'org-mime-org-buffer-htmlize)

(after 'message
  (define-key message-mode-map  (kbd "C-c M-o") 'org-mime-htmlize))
#+end_src
** Offset block quotes and source code
#+begin_src emacs-lisp
(hook-fn 'org-mime-html-hook
  (org-mime-change-element-style
   "blockquote" "border-left: 2px solid #B0B0B0; padding-left: 4px;")
  (org-mime-change-element-style
   "pre" "border-left: 2px solid #B0B0B0; padding-left: 4px;"))
#+end_src
** Fix undefined function
#+begin_src emacs-lisp
(defun org-export-grab-title-from-buffer ()
  "")
#+end_src
** Set default org header options
#+begin_src emacs-lisp
(setq org-mime-default-header "#+OPTIONS: num:nil toc:nil latex:t\n")
#+end_src
** Define a command picker for sending mail
#+begin_src emacs-lisp
(require 'cb-org-mail)

(define-command-picker mail-picker
  :title "*Mail Commands*"
  :options
  '(("m" "Compose Mail" org-compose-mail)
    ("s" "Compose Mail (subtree)" org-compose-mail-subtree :modes org-mode)))

(defun cb-compose-mail-dwim ()
  (interactive)
  (if (derived-mode-p 'org-mode)
      (call-interactively 'mail-picker)
    (call-interactively 'org-compose-mail)))

(bind-key* "C-x m" 'cb-compose-mail-dwim)
#+end_src
* Write subtrees to new files
#+begin_src emacs-lisp
(defun org-narrow-to-subtree-content ()
  (widen)
  (unless (org-at-heading-p) (org-back-to-heading))
  (org-narrow-to-subtree)
  (forward-line)
  (narrow-to-region (line-beginning-position) (point-max)))

(defun org-subtree-content ()
  (save-excursion
    (save-restriction
      (org-narrow-to-subtree)
      (buffer-substring-no-properties (point-min) (point-max)))))

(defun org-write-subtree-content (dest)
  "Write the contents of the subtree at point to a file at DEST."
  (interactive (list (ido-read-file-name "Write subtree to: " nil nil nil ".org")))
  (f-write-text (org-subtree-content) 'utf-8 dest)
  (when (called-interactively-p nil)
    (message "Subtree written to %s" dest)))
#+end_src
* Export
#+begin_src emacs-lisp
(setq org-export-exclude-tags '("noexport" "crypt"))
#+end_src
** HTML
*** Use HTML5 tags
#+begin_src emacs-lisp
(setq org-html-html5-fancy t)
#+end_src
*** Do not export a postamble
The postamble usually displays the creator, org version, etc.
#+begin_src emacs-lisp
(setq org-html-postamble nil)
#+end_src
*** Use alternating table row colours
#+begin_src emacs-lisp
(setq org-html-head-extra
      "
<style type=\"text/css\">
table tr.tr-odd td {
      background-color: #FCF6CF;
}
table tr.tr-even td {
      background-color: #FEFEF2;
}
</style>
")

(setq org-html-table-row-tags
      (cons '(cond (top-row-p "<tr class=\"tr-top\">")
                   (bottom-row-p "<tr class=\"tr-bottom\">")
                   (t (if (= (mod row-number 2) 1)
                          "<tr class=\"tr-odd\">"
                        "<tr class=\"tr-even\">")))
            "</tr>"))
#+end_src
** texinfo
#+begin_src emacs-lisp
(require 'ox-texinfo)
(add-to-list 'org-export-snippet-translation-alist
             '("info" . "texinfo"))
#+end_src
** ox-koma-letter
#+begin_src emacs-lisp
(require 'ox-koma-letter)
(add-to-list 'org-latex-classes '("koma-letter" "
\\documentclass[paper=A4,pagesize,fromalign=right,
               fromrule=aftername,fromphone,fromemail,
               version=last]{scrlttr2}
\\usepackage[english]{babel}
\\usepackage[utf8]{inputenc}
\\usepackage[normalem]{ulem}
\\usepackage{booktabs}
\\usepackage{graphicx}
[NO-DEFAULT-PACKAGES]
[EXTRA]
[PACKAGES]"))

(defun org-export-koma-letter-at-subtree (dest)
  "Define a command to export the koma letter subtree at point to PDF.
With a prefix arg, prompt for the output destination. Otherwise
generate use the name of the current file to generate the
exported file's name.
The PDF will be created at DEST."
  (interactive
   (list (if current-prefix-arg
             (ido-read-file-name "Destination: " nil nil nil ".pdf")
           (concat (f-no-ext (buffer-file-name)) ".pdf"))))

  (let ((tmpfile (make-temp-file "org-export-" nil ".org")))
    (org-write-subtree-content tmpfile)
    (with-current-buffer (find-file-noselect tmpfile)
      (unwind-protect
          (-if-let (exported (org-koma-letter-export-to-pdf))
              (f-move exported dest)
            (error "Export failed"))
        (kill-buffer)))
    (%-sh "open" (%-quote dest))
    (message "opening %s..." dest)))

(add-hook 'org-ctrl-c-ctrl-c-hook
          (lambda ()
            (when (ignore-errors
                    (s-matches? (rx "latex_class:" (* space) "koma")
                                (org-subtree-content)))
              (call-interactively 'org-export-koma-letter-at-subtree)
              'export-koma-letter))
          t)
#+end_src
* Habits
#+begin_src emacs-lisp
(require 'org-habit)
(setq org-habit-preceding-days 14
      org-habit-following-days 4
      org-habit-graph-column 70)
#+end_src
* Tree killing
Define a command for killing the subtree at point. If we're in a special org
buffer, this should fall back to the cancel action.
** Impl
#+begin_src emacs-lisp
(defun cb-org:ctrl-c-ctrl-k (&optional n)
  "Kill subtrees, unless we're in a special buffer where it should cancel."
  (interactive "p")
  (if (s-starts-with? "*Org" (buffer-name))
      (org-kill-note-or-show-branches)
    (org-cut-subtree n)))
#+end_src
** Key binding
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c C-k") 'cb-org:ctrl-c-ctrl-k)
#+end_src
* Special C-c C-RET command
Define a custom command to insert todo headings, etc. This is mainly needed
because the default keybinding conflicts with my window manager on OS X.
** Impl
#+begin_src emacs-lisp
(defun cb-org:ctrl-c-ret ()
  "Call `org-table-hline-and-move' or `org-insert-todo-heading' dep. on context."
  (interactive)
  (cond
   ((org-at-table-p) (call-interactively 'org-table-hline-and-move))
   (t (call-interactively 'org-insert-todo-heading))))
#+end_src
** Key binding
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c RET") 'cb-org:ctrl-c-ret)
#+end_src
* Define a command to tidy org buffers
#+begin_src emacs-lisp
(defun tidy-org-buffer ()
  "Perform cosmetic fixes to the current org-mode buffer."
  (save-restriction
    (org-table-map-tables 'org-table-align 'quiet)
    ;; Realign tags.
    (org-set-tags 4 t)
    ;; Remove empty properties drawers.
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp ":PROPERTIES:" nil t)
        (save-excursion
          (org-remove-empty-drawer-at "PROPERTIES" (match-beginning 0)))))))
#+end_src
* Tidy org buffers when saving
#+begin_src emacs-lisp
(hook-fn 'org-mode-hook
  (add-hook 'before-save-hook 'tidy-org-buffer nil t))
#+end_src
* Agenda
#+begin_src emacs-lisp
(require 'org-agenda)
#+end_src
** Show appointment notifications in the modeline
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook 'org-agenda-to-appt)
#+end_src
** Read all org files in the org directory for items to add to the agenda
#+begin_src emacs-lisp
(add-to-list 'org-agenda-files org-directory)
#+end_src
** Use the timestamp set in diary entries
#+begin_src emacs-lisp
(setq org-agenda-insert-diary-extract-time t)
#+end_src
** Show the whole coming week in the agenda
#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday nil
      org-agenda-span 'week
      org-agenda-ndays 7)
#+end_src
** Define a hook for setting up agenda windows
#+begin_src emacs-lisp
(defvar org-agenda-customise-window-hook nil
  "Relay hook for `org-agenda-mode-hook'. Suitable for setting up the window.")

(hook-fn 'org-agenda-mode-hook
  (run-hooks 'org-agenda-customise-window-hook))
#+end_src
** Show today's agenda after a period of inactivity
#+begin_src emacs-lisp
(defvar cb-org:show-agenda-idle-delay (* 30 60)
  "The delay in seconds after which to pop up today's agenda.")

(defvar cb-org:show-agenda-idle-timer
  (unless noninteractive
    (run-with-idle-timer cb-org:show-agenda-idle-delay t
                         'executor:org-agenda-fullscreen))
  "Idle timer that will display today's org agenda.
See `cb-org:show-agenda-idle-delay'.")
#+end_src
** Exclude tasks with 'hold' tag
#+begin_src emacs-lisp
(defun cb-org:exclude-tasks-on-hold (tag)
  (and (equal tag "hold") (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'cb-org:exclude-tasks-on-hold)
#+end_src
** Searches include archives
#+begin_src emacs-lisp
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+end_src
** Searches are boolean, like a Google search
#+begin_src emacs-lisp
(setq org-agenda-search-view-always-boolean t)
#+end_src
** Deadlines
Don't show deadlines or scheduled tasks that have been completed.
#+begin_src emacs-lisp
(setq org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-prewarning-if-scheduled t)
#+end_src
** Hide ubiquitous tags from agenda
#+begin_src emacs-lisp
(setq org-agenda-hide-tags-regexp (rx (or "noexport" "someday")))
#+end_src
** Hide inherited tags from the agenda
#+begin_src emacs-lisp
(setq org-agenda-show-inherited-tags nil)
#+end_src
** Only show dates with entries in agenda
#+begin_src emacs-lisp
(setq org-agenda-show-all-dates nil)
#+end_src
** Define agenda views
They should be displayed modally.
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      (->> '(("A" "Agenda and next actions"
              ((tags-todo "-someday-media/NEXT"
                          ((org-agenda-overriding-header "Next Actions")))
               (agenda "")
               (todo "WAITING"
                     ((org-agenda-overriding-header "Waiting")))
               (tags-todo "media/NEXT"
                          ((org-agenda-overriding-header "Media"))))
              ((org-agenda-tag-filter-preset '("-@work"))))

             ("w" "Agenda and work actions"
              ((tags-todo "-someday-PeterBarrett-PeterRoberts/NEXT"
                          ((org-agenda-overriding-header "Next Actions")))
               (agenda "" ((org-agenda-ndays 14)))
               (todo "AWAITING|ORGANISE_IN"
                     ((org-agenda-overriding-header "Incoming")))
               (todo "TODO_OUT|READY|ORGANISE_OUT"
                     ((org-agenda-overriding-header "Outgoing")))
               (todo "CALLBACK|MESSAGE"
                     ((org-agenda-overriding-header "Phone calls")))
               (tags-todo "-someday/WAITING"
                          ((org-agenda-overriding-header "Waiting")))
               (tags-todo "-someday+PeterBarrett"
                          ((org-agenda-overriding-header "Peter Barrett")))
               (tags-todo "-someday+PeterRoberts"
                          ((org-agenda-overriding-header "Peter Roberts")))
               )

              ((org-agenda-tag-filter-preset '("+@work"))
               (org-agenda-files (list org-work-file))
               (org-agenda-hide-tags-regexp
                (regexp-opt (list org-agenda-hide-tags-regexp "@work")))))

             ("n" "Next actions"
              ((tags-todo "-someday/NEXT"))
              ((org-agenda-overriding-header "Next Actions")))

             ("g" . "GTD contexts")
             ("gg" "Anywhere"
              ((tags-todo "@computer")
               (tags-todo "@errand")
               (tags-todo "@home")
               (tags-todo "@leisure")
               (tags-todo "@phone")
               (tags-todo "@work")))
             ("gc" "Computer" tags-todo "@computer")
             ("ge" "Errands"  tags-todo "@errand")
             ("gp" "Phone"    tags-todo "@phone")
             ("gw" "Work"     tags-todo "@work")
             ("gh" "Home"     tags-todo "@home")
             ("gl" "Leisure"  tags-todo "@leisure")

             ("r" "Weekly Review"
              ((agenda "" ((org-agenda-ndays 14)))
               (stuck "")
               (todo "WAITING"
                     ((org-agenda-overriding-header "Waiting")))
               (tags-todo "someday-skill/MAYBE|NEXT"
                          ((org-agenda-overriding-header "Someday")))
               (tags-todo "someday&skill"
                          ((org-agenda-overriding-header "Skills")))
               (tags-todo "media"
                          ((org-agenda-overriding-header "Media"))))

              ((org-agenda-tag-filter-preset '("-drill" "-gtd"))
               (org-habit-show-habits nil)))

             ("g" . "GTD contexts")
             ("gg" "Anywhere"
              ((tags-todo "@computer")
               (tags-todo "@errand")
               (tags-todo "@home")
               (tags-todo "@leisure")
               (tags-todo "@phone")
               (tags-todo "@work")))
             ("gc" "Computer" tags-todo "@computer")
             ("ge" "Errands"  tags-todo "@errand")
             ("gp" "Phone"    tags-todo "@phone")
             ("gw" "Work"     tags-todo "@work")
             ("gh" "Home"     tags-todo "@home")
             ("gl" "Leisure"  tags-todo "@leisure"))
        (--map-when (listp (cdr it))
                    (append it
                            '(((org-agenda-customise-window-hook
                                'delete-other-windows)))))))
#+end_src
** Sort order
#+begin_src emacs-lisp
(setq org-agenda-sorting-strategy
      '((agenda habit-down time-up priority-down category-keep)
        (todo priority-down category-keep scheduled-up)
        (tags priority-down category-keep)
        (search category-keep)))
#+end_src
** Navigation commands
Define commands for skipping through agenda sections.
*** Impl
#+begin_src emacs-lisp
(defun cb-org:agenda-next-section ()
  "Move to the next section in the agenda."
  (interactive)
  (save-match-data
    (cond ((search-forward-regexp (rx bol (+ "="))
                                  nil t)
           (goto-char (line-beginning-position))
           (org-agenda-next-item 1))
          (t
           (goto-char (point-max))
           (goto-char (line-beginning-position))))))

(defun cb-org:agenda-prev-section ()
  "Move to the previous section in the agenda."
  (interactive)
  (save-match-data
    (cl-flet ((goto-section-start ()
                                  (when (search-backward-regexp (rx bol (+ "=")) nil t)
                                    (org-agenda-next-item 1)
                                    (goto-char (line-beginning-position))
                                    (point))))
      (let ((current-section-start (save-excursion (goto-section-start))))
        (cond
         ((and (equal (point) current-section-start)
               (search-backward-regexp (rx bol (+ "=")) nil t 2)))
         ((search-backward-regexp (rx bol (+ "=")) nil t))
         (t
          (goto-char (point-min)))

         (forward-line 1)
         (goto-char (line-beginning-position)))))))
#+end_src
*** Key bindings
#+begin_src emacs-lisp
(define-key org-agenda-mode-map (kbd "M-N") 'cb-org:agenda-next-section)
(define-key org-agenda-mode-map (kbd "M-P") 'cb-org:agenda-prev-section)
#+end_src
** Disable smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (hook-fn 'org-agenda-mode-hook
    (smartparens-mode -1)))
#+end_src
** Configure agenda auto-exclusion
#+begin_src emacs-lisp
(defun cb-org:agenda-auto-exclude (tag)
  "Hide drills."
  (when (equal "drill" tag)
    (concat "-" tag)))

(defun cb-org:apply-auto-exclude ()
  (org-agenda-filter-by-tag nil ?\r t))

(add-hook 'org-agenda-mode-hook 'cb-org:apply-auto-exclude)
(setq org-agenda-auto-exclude-function 'cb-org:agenda-auto-exclude)
#+end_src
* Define commands for use in diary entries
** Find the closest date to the given date an a certain day of the week
#+begin_src emacs-lisp
(defvar date nil
  "Dynamic var bound to current date by calendaring functions.")

(autoload 'calendar-extract-year "calendar")
(autoload 'calendar-day-number "calendar")
(autoload 'calendar-day-of-week "calendar")

(defun calendar-nearest-to (target-dayname target-day target-month)
  "Non-nil if the current date is a certain weekday close to an anniversary.

TARGET-DAYNAME is the day of the week that we want to match,
 while TARGET-DAY and TARGET-MONTH are the anniversary."
  (let* ((dayname (calendar-day-of-week date))
         (target-date (list target-month target-day (calendar-extract-year date)))
         (days-diff (abs (- (calendar-day-number date)
                            (calendar-day-number target-date)))))
    (and (= dayname target-dayname)
         (< days-diff 4))))
#+end_src
** Find the next weekday if date falls on a weekend
#+begin_src emacs-lisp
(defun calendar-mondayised (target-day target-month)
  "Given anniversary with DAY and MONTH, return non-nil if:

- the given date is a weekday, or

- it is the Monday after the given date if it falls on a weekend."
  (if (memq (calendar-day-of-week date) '(6 0)) ; Sat or Sun
      (calendar-nearest-to 1 target-day target-month)

    (let ((m (calendar-extract-month date))
          (d (calendar-extract-day date)))
      (and (equal d target-day)
           (equal m target-month)))) )
#+end_src
** Find dates that occur at regular intervals of N days/weeks/months
#+begin_src emacs-lisp
(defun diary-limited-cyclic (recurrences interval m d y)
  "For use in emacs diary. Cyclic item with limited number of recurrences.
Occurs every INTERVAL days, starting on YYYY-MM-DD, for a total of
RECURRENCES occasions."
  (let ((startdate (calendar-absolute-from-gregorian (list m d y)))
        (today (calendar-absolute-from-gregorian date)))
    (and (not (cl-minusp (- today startdate)))
         (zerop (% (- today startdate) interval))
         (< (floor (- today startdate) interval) recurrences))))

#+end_src
** Define a command to read a class sexpr and insert at point
#+begin_src emacs-lisp
(cl-defun cb-org:format-class-sexpr ((s1 m1 h1 d1 m1 y1 . _)
                                     (s2 m2 h2 d2 m2 y2 . _)
                                     desc)
  "Parse dates into an org-class s-expression."
  (let* ((time (unless (or (zerop m1) (zerop h1))
                 (format " %.2i:%.2i %s" h1 m1 desc)))
         (date-range (list (list y1 m1 d1) (list y2 m2 d2)))
         (date-cols (-map (C
                           (~ s-pad-right 12 " ")
                           (~ s-join " ")
                           (~ -map (C (~ s-pad-left 2 " ")
                                      'number-to-string)))
                          date-range))
         (day-of-week (number-to-string (calendar-day-of-week (list m1 d1 y1)))))
    (concat "<%%(org-class   "
            (s-join " "  (-concat date-cols (list day-of-week)))
            ")>" time)))

(defun org-read-class ()
  "Read a class diary sexp with a description.
The starting day is taken to be the weekday on which the event will repeat."
  (let ((desc (read-string "Description: ")))
    (cb-org:format-class-sexpr
     (org-parse-time-string (org-read-date nil nil nil "Start date: "))
     (org-parse-time-string (org-read-date nil nil nil "End date: "))
     desc)))

(defun org-insert-class ()
  "Read and insert a class diary sexp at point."
  (interactive "*")
  (insert (org-read-class)))
#+end_src
** Helpers for calculating Easter holidays
#+begin_src emacs-lisp
(defun calendar-easter-date (year)
  "Calculate the date for Easter Sunday in YEAR. Returns the date in the
Gregorian calendar, ie (MM DD YY) format."
  (let* ((century (1+ (/ year 100)))
         (shifted-epact (% (+ 14 (* 11 (% year 19))
                              (- (/ (* 3 century) 4))
                              (/ (+ 5 (* 8 century)) 25)
                              (* 30 century))
                           30))
         (adjusted-epact (if (or (= shifted-epact 0)
                                 (and (= shifted-epact 1)
                                      (< 10 (% year 19))))
                             (1+ shifted-epact)
                           shifted-epact))
         (paschal-moon (- (calendar-absolute-from-gregorian
                           (list 4 19 year))
                          adjusted-epact)))
    (calendar-dayname-on-or-before 0 (+ paschal-moon 7))))

(defun calendar-days-from-easter ()
  "When used in a diary sexp, this function will calculate how many days
are between the current date (DATE) and Easter Sunday."
  (- (calendar-absolute-from-gregorian date)
     (calendar-easter-date (calendar-extract-year date))))
#+end_src
* Babel
** Load languages
#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (ledger . t)
   (C . t)
   (ditaa . t)
   (sh . t)
   (calc . t)
   (scala . t)
   (emacs-lisp . t)
   (ruby . t)
   (clojure . t)
   (haskell . t)))
#+end_src
** Apply font-locking to source blocks
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src
** Do not prompt for confirmation when eval'ing source blocks
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src
** Do not indent source blocks
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
#+end_src
** Run a hook when exiting source blocks
#+begin_src emacs-lisp
(defvar org-edit-src-before-exit-hook nil
  "Hook run before exiting a code block.")

(defadvice org-edit-src-exit (before run-hook activate)
  (run-hooks 'org-edit-src-before-exit-hook))
#+end_src
** Do not add a final newline to org source buffers
#+begin_src emacs-lisp
(hook-fn 'org-src-mode-hook
  (setq-local require-final-newline nil))
#+end_src
** Remove trailing spaces when exiting org code blocks
#+begin_src emacs-lisp
(add-hook 'org-edit-src-before-exit-hook 'delete-trailing-whitespace)
#+end_src
* Todos
** Do not allow todos to be marked as DONE when children are not DONE
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src
** Define todo keywords
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((type "MAYBE(m)" "TODO(t)" "NEXT(n)" "WAITING(w@/!)"
              "|" "DONE(d!)" "CANCELLED(c@)" "DELEGATED(D@)")))
#+end_src
** Use special face for NEXT keyword
#+begin_src emacs-lisp
(defface org-todo-next
  `((((background dark))
     (:foreground ,solarized-hl-orange :bold t))
    (((background light))
     (:foreground ,solarized-hl-orange :bold t))
    (t
     (:inherit org-todo)))
  "Face for todos with the NEXT label."
  :group 'org-faces)

(defface org-todo-out
  `((t (:foreground ,solarized-hl-orange :bold t :inherit org-todo)))
  "Face for TODO_OUT keyword."
  :group 'org-faces)

(defface org-todo-ready
  `((t (:foreground ,solarized-hl-blue :bold t :inherit org-todo)))
  "Face for TODO_OUT keyword."
  :group 'org-faces)

(setq org-todo-keyword-faces
      '(("NEXT" . org-todo-next)
        ("ORGANISE_IN" . org-todo-next)
        ("ORGANISE_OUT" . org-todo-next)
        ("TODO_OUT" . org-todo-out)
        ("READY" . org-todo-ready)))
#+end_src
** Sub-task completion triggers parent completion
#+begin_src emacs-lisp
(hook-fn 'org-after-todo-statistics-hook
  :arglist (n-done n-not-done)
  (let (org-log-done org-log-states) ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
#+end_src
** When setting a todo as DONE, set the next TODO to NEXT
#+begin_src emacs-lisp
(defun cb-org:set-next-todo-state ()
  "When marking a todo to DONE, set the next TODO as NEXT.
Do not change habits, scheduled items or repeating todos."
  (when (equal org-state "DONE")
    (save-excursion
      (when (and (ignore-errors (outline-forward-same-level 1) t)
                 (equal (org-get-todo-state) "TODO"))
        (unless (or (org-is-habit-p)
                    (org-entry-get (point) "STYLE")
                    (org-entry-get (point) "LAST_REPEAT")
                    (org-get-scheduled-time (point)))
          (org-todo "NEXT"))))))

(add-hook 'org-after-todo-state-change-hook 'cb-org:set-next-todo-state)
#+end_src
* orglink
Adds support for org-mode-style and plain links in other modes.
#+begin_src emacs-lisp
(cb:install-package 'orglink t)
#+end_src
** Define which link types to highlight
#+begin_src emacs-lisp
(setq orglink-activate-links '(angle plain))
#+end_src
** Don't show in the modeline
#+begin_src emacs-lisp
(setq orglink-mode-lighter nil)
#+end_src
** Use orglink in most modes
#+begin_src emacs-lisp
(hook-fns '(prog-mode-hook text-mode-hook comint-mode)
  (ignore-errors
    (unless (derived-mode-p 'org-mode 'nxml-mode 'sgml-mode 'snippet-mode)
      (orglink-mode +1))))
#+end_src
* org-pomodoro
Implements Pomodoro timers using org-mode's clocking functions. I have my own
fork, since the original wasn't keeping up with pull requests and has since
diverged.
** Set a key binding for starting a pomodoro
#+begin_src emacs-lisp
(autoload 'org-pomodoro "org-pomodoro")
(bind-key* "<f5>" 'org-pomodoro)
#+end_src
** Set pomodoro length
#+begin_src emacs-lisp
(setq org-pomodoro-long-break-length 25)
#+end_src
** Customise display format
#+begin_src emacs-lisp
(setq org-pomodoro-format "• %s"
      org-pomodoro-short-break-format "Break %s"
      org-pomodoro-long-break-format "Break %s"
      org-pomodoro-show-seconds nil)
#+end_src
Don't use the built-in display mechanism, since I use custom logic in my
modeline format string.
#+begin_src emacs-lisp
(setq org-pomodoro-show-in-mode-line nil)
#+end_src
* appt
=appt= is emacs' generic scheduling system for calendar. Configure it to hook
into org-mode.
#+begin_src emacs-lisp
(require 'appt)
(setq appt-message-warning-time 60
      appt-display-interval 15)

(save-window-excursion
  (appt-activate +1))
#+end_src
** Update appointments when saving the diary file
#+begin_src emacs-lisp
(defun cb-org:save-diary ()
  (save-restriction
    (save-window-excursion
      (org-agenda-to-appt t)
      (appt-check 'force))))

(hook-fn 'org-mode-hook
  (when (equal (buffer-file-name) org-agenda-diary-file)
    (add-hook 'after-save-hook 'cb-org:save-diary nil t)))
#+end_src
* org-protocol
Allows other applications to connect to Emacs and prompt org-mode to perform
certain actions, including saving links.
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src
* org-reveal
Provides a Reveal.js exporter for making presentations.
#+begin_src emacs-lisp
(cb:install-package 'ox-reveal t)
#+end_src
** Set path to reveal.js
#+begin_src emacs-lisp
(setq org-reveal-root (concat "file://" (f-join cb:lib-dir "reveal.js")))
#+end_src
** Define auxiliary functions for snippets
#+begin_src emacs-lisp
(defun cb-org:reveal-read-transition ()
  (popup-menu*
   (-map 'popup-make-item
         '("Cube" "Page" "Concave" "Zoom" "Linear" "Fade" "None" "Default"))
   :isearch t))

(defun cb-org:reveal-read-theme ()
  (popup-menu*
   (-map 'popup-make-item
         '("Default" "Sky" "Beige" "Simple" "Serif" "Night Moon" "Simple" "Solarized"))
   :isearch t))

(defun cb-org:reveal-read-frag-style ()
  (popup-menu*
   (-map 'popup-make-item
         '("grow" "shrink" "roll-in" "fade-out"
           "highlight-red" "highlight-green" "highlight-blue"))
   :isearch t))
#+end_src
* org-drill
** save org buffers without prompting after drill session
#+begin_src emacs-lisp
(setq org-drill-save-buffers-after-drill-sessions-p nil)

(defadvice org-drill (after save-buffers activate)
  (org-save-all-org-buffers))
#+end_src
** autoload org-drill commands
#+begin_src emacs-lisp
(--each '(org-drill
          org-drill-strip-all-data
          org-drill-cram
          org-drill-tree
          org-drill-resume
          org-drill-merge-buffers
          org-drill-entry
          org-drill-directory
          org-drill-again)
  (autoload it "org-drill" nil t))
#+end_src
** Use org-drill-table to generate drill cards
#+begin_src emacs-lisp
(cb:install-package 'org-drill-table t)
(add-hook 'org-ctrl-c-ctrl-c-hook 'org-drill-table-update)
#+end_src
** Add org-drill-again to org action picker
#+begin_src emacs-lisp
(defun cb-org:drill-buffer? ()
  "Non-nil if the current buffer contains any drill items."
  (and
   (derived-mode-p 'org-mode)
   (s-matches? ":drill:" (buffer-string))))

(add-to-list 'org-action-picker-options
             '("r" "Org Drill" (lambda () (org-drill 'agenda))))
#+end_src
* Display inline images in org buffers
#+begin_src emacs-lisp
(after 'org
  (require 'iimage))
#+end_src
** Show images in file links
#+begin_src emacs-lisp
(after 'iimage
  (add-to-list 'iimage-mode-image-regex-alist
               (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                             "\\)\\]")  1)))
#+end_src
** Define a command to toggle images
#+begin_src emacs-lisp
(defun org-toggle-iimage-in-org ()
  "Display images in the current orgmode buffer."
  (interactive)
  (if (face-underline-p 'org-link)
      (set-face-underline-p 'org-link nil)
    (set-face-underline-p 'org-link t))
  (iimage-mode))
#+end_src
* flyspell
Prevent flyspell from incorrectly flagging common org-mode content such as code
blocks and encrypted regions.
** Define a structure element for suppressing spell checks
#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
             '("n" "#+begin_nospell\n?\n#+end_nospell" "?"))
#+end_src
** Define a custom flyspell predicate for org buffers
#+begin_src emacs-lisp
(defun cb-org:in-no-spellcheck-zone? ()
  (thing-at-point-looking-at (rx "#+begin_nospell" (*? anything ) "#+end_nospell")))

(defun cb-org:flyspell-verify ()
  "Prevent common flyspell false positives in org-mode."
  (and (ignore-errors
         (org-mode-flyspell-verify))
       (not (or
             (ignore-errors (org-at-encrypted-entry-p))
             (ignore-errors (org-in-src-block-p))
             (ignore-errors (org-at-TBLFM-p))
             (ignore-errors (org-in-block-p '("src" "example" "latex" "html")))
             (ignore-errors (org-in-verbatim-emphasis))
             (ignore-errors (org-in-drawer-p))
             (thing-at-point-looking-at (rx bol "#+" (* nonl) eol))
             (cb-org:in-no-spellcheck-zone?)))))
#+end_src
** Apply custom flyspell predicate
#+begin_src emacs-lisp
(put 'org-mode 'flyspell-mode-predicate 'cb-org:flyspell-verify)

(hook-fn 'org-mode-hook
  (setq-local flyspell-generic-check-word-predicate 'cb-org:flyspell-verify))
#+end_src
* Use lowercase structure keys, e.g. "begin_src" instead of "BEGIN_SRC"
#+begin_src emacs-lisp
(setq org-structure-template-alist
      (-map (~ -map 's-downcase) org-structure-template-alist))
#+end_src
* Disable auto-complete
#+begin_src emacs-lisp
(after 'auto-complete
  (hook-fn 'org-mode-hook
    (setq-local ac-sources nil)
    (auto-complete-mode -1)))
#+end_src
* Evil
** DEFER
#+begin_src emacs-lisp
(after 'evil
#+end_src
** Enter insertion mode in capture buffer
#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook 'cb:maybe-evil-insert-state)
#+end_src
** Enter insert state for popup notes
:LOGBOOK:
:END:
#+begin_src emacs-lisp
(hook-fn 'org-mode-hook
  (when (equal (buffer-name) "*Org Note*")
    (cb:maybe-evil-insert-state)))
#+end_src
** Use evil key bindings in agenda
#+begin_src emacs-lisp
(after 'org-agenda
  (bind-keys
    :map org-agenda-mode-map
    "C" 'org-agenda-capture
    "g" 'org-agenda-goto-date
    "j" 'org-agenda-next-item
    "k" 'org-agenda-previous-item
    "L" 'org-agenda-log-mode
    "l" 'evil-forward-char
    "h" 'evil-backward-char
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up))
#+end_src
** Advise header insertion commands to enter evil insert state
#+begin_src emacs-lisp
(defadvice org-insert-heading (after insert-state activate)
  (when (called-interactively-p nil)
    (cb:maybe-evil-insert-state)))

(defadvice org-insert-heading-respect-content (after insert-state activate)
  (when (called-interactively-p nil)
    (cb:maybe-evil-insert-state)))

(defadvice org-insert-todo-heading (after insert-state activate)
  (when (called-interactively-p nil)
    (cb:maybe-evil-insert-state)))

(defadvice org-insert-todo-heading-respect-content (after insert-state activate)
  (when (called-interactively-p nil)
    (cb:maybe-evil-insert-state)))
#+end_src
** Adapt outline fold commands for Evil
#+begin_src emacs-lisp
(defadvice org-toggle-heading (after goto-line-end activate)
  "Prevent point from being moved to the line beginning."
  (when (s-matches? (rx bol (+ "*") (* space) eol) (current-line))
    (goto-char (line-end-position))))

(defun cborg-evil-fold ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (org-global-cycle 1)
    (recenter)))

(defun cborg-evil-reveal ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (org-global-cycle 16)
    (recenter)))

(evil-define-key 'normal org-mode-map
  (kbd "<return>") 'org-return
  (kbd "M-P") 'outline-previous-visible-heading
  (kbd "M-N") 'outline-next-visible-heading
  (kbd "SPC") 'org-cycle
  (kbd "z m") 'cborg-evil-fold
  (kbd "z r") 'cborg-evil-reveal)
#+end_src
** Advise org-return not to insert newlines unless we're in insertion state
#+begin_src emacs-lisp
(defadvice org-return (around newlines-only-in-insert-state activate)
  "Only insert newlines if we're in insert state."
  (noflet ((newline (&rest args)
                    (when (and (fboundp 'evil-insert-state-p)
                               (evil-insert-state-p))
                      (funcall this-fn args))))
      ad-do-it))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Growl
Show growl notifications.
#+begin_src emacs-lisp
(defconst org-unicorn-png
  (f-join user-emacs-directory "assets" "org_unicorn.png"))
#+end_src
** CONDITIONAL
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
#+end_src
** Advise appt to show Growl notifications for appointments
#+begin_src emacs-lisp
(defun cb-appt:growl (title mins)
  (growl (cond ((zerop mins) "Appointment (now)")
               ((= 1 mins)   "Appointment (1 min)")
               (t (format "Appointment (%s mins)" mins)))
         (cl-destructuring-bind (whole time desc)
             (s-match (rx bol
                          (group (+ digit) ":" (+ digit))
                          (* space)
                          (group (* nonl)))
                      title)
           desc)))

(defadvice appt-display-message (around growl-with-sound activate)
  "Play a sound and display a growl notification for appt alerts."
  ;; Show notification.
  (let ((title (-listify (ad-get-arg 0)))
        (mins (-listify (ad-get-arg 1))))
    (-each (-zip-with 'list title mins)
           (-applify 'cb-appt:growl)))
  ;; Play sound.
  (osx-play-system-sound "blow"))
#+end_src
** Show Growl notification for countdown timers
#+begin_src emacs-lisp
(hook-fn 'org-timer-start-hook (growl "Timer Started" "" org-unicorn-png))
(hook-fn 'org-timer-done-hook (growl "Timer Finished" "" org-unicorn-png))
(hook-fn 'org-timer-done-hook (osx-play-system-sound "glass"))
#+end_src
** Show Growl notifications when capturing links from a browser
#+begin_src emacs-lisp
(defadvice org-protocol-do-capture (after show-growl-notification activate)
  "Show Growl notification when capturing links."
  (let* ((parts (org-protocol-split-data (ad-get-arg 0) t org-protocol-data-separator))
         ;; Pop the template selector if present.
         (template (or (and (>= 2 (length (car parts))) (pop parts))
                       org-protocol-default-template-key))
         (url (org-protocol-sanitize-uri (car parts)))
         (type (if (string-match "^\\([a-z]+\\):" url)
                   (match-string 1 url)))
         (title (or (cadr parts) "")))
    (growl "Link Stored" (or title url) org-unicorn-png)))
#+end_src
** Use system sounds for pomodoro notifications on OS X
#+begin_src emacs-lisp
(let ((snd (osx-find-system-sound "purr")))
  (setq org-pomodoro-sound snd
        org-pomodoro-short-break-sound snd
        org-pomodoro-long-break-sound snd))
#+end_src
** Show growl notifications for pomodoros
#+begin_src emacs-lisp
(defun cb-org:pomodoro-growl ()
  (growl "Pomodoro"
         (cl-case org-pomodoro-state
           (:pomodoro (format "Timer started (%s/%s)"
                              (1+ (mod org-pomodoro-count
                                       org-pomodoro-long-break-frequency))
                              org-pomodoro-long-break-frequency))
           (:short-break "Short break")
           (:long-break  "Long break")
           (otherwise "Stopped"))
         (f-join cb:assets-dir "org-pomodoro.png")))

(add-hook 'org-pomodoro-finished-hook 'cb-org:pomodoro-growl)
(add-hook 'org-pomodoro-started-hook 'cb-org:pomodoro-growl)
(add-hook 'org-pomodoro-killed-hook 'cb-org:pomodoro-growl)

(defun cb-org:pomodoro-growl-end-break ()
  (growl "Pomodoro"
         "Break finished"
         (f-join cb:assets-dir "org-pomodoro.png")))

(add-hook 'org-pomodoro-short-break-finished-hook 'cb-org:pomodoro-growl-end-break)
(add-hook 'org-pomodoro-short-break-finished-hook 'cb-org:pomodoro-growl-end-break)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Show the agenda after init
#+begin_src emacs-lisp
(when (or (daemonp) (display-graphic-p))
  (hook-fn 'after-init-hook
    (unless noninteractive
      (executor:org-agenda-fullscreen))))
#+end_src
* Auto-save notes file
Run an idle timer to save the notes file.

This has the nice side-effect that encrypted regions will be automatically
re-encrypted after a period of inactivity.
#+begin_src emacs-lisp
(defvar cb-org:notes-save-idle-delay 60)

(defun cb-org:save-notes ()
  "Save the notes file."
  (-when-let (buf (--first-buffer (equal (buffer-file-name it)
                                         org-default-notes-file)))
    (with-current-buffer buf
      (when (buffer-modified-p)
        (save-buffer)))))

(defvar cb-org:notes-save-timer
  (unless noninteractive
    (run-with-idle-timer cb-org:notes-save-idle-delay t 'cb-org:save-notes))
  "Timer that automatically saves the notes buffer on idle.")
#+end_src
* Enable abbrev-mode
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'abbrev-mode)
#+end_src
* Email capture
Use =capture-email= to capture items from emails to org.
#+begin_src emacs-lisp
(require 'capture-mail)
#+end_src
** Set maildir paths
#+begin_src emacs-lisp
(let ((account-dir (--first
                    (not (s-starts-with? "." (f-filename it)))
                    (f-directories user-mail-directory))))
  (setq cm-archived-messages-dir (f-join account-dir "org" "cur")
        cm-capture-messages-dir  (f-join account-dir "org" "new")))
#+end_src
** Define growl helper fn
#+begin_src emacs-lisp
(cl-defun cm--growl (kind desc)
  (growl (format "%s Captured" (s-capitalize kind))
         (s-truncate 40 desc)
         (f-join user-emacs-directory "assets" "org_unicorn.png")))
#+end_src
** Define helper fn to capture with org-mode
#+begin_src emacs-lisp
(cl-defun cm--org-capture (str template-name &optional tags)
  "Capture STR with org-mode.
TEMPLATE-NAME is a string matching the name of a capture
template."
  (let ((org-default-notes-file org-init-notes-file))
    (save-excursion
      (save-window-excursion
        (when (boundp 'org-capture-templates)
          (cl-destructuring-bind (&optional key name file tree template &rest rest)
              (-first (C (~ equal template-name) s-downcase cadr)
                      org-capture-templates)
            (org-capture-goto-target (or key "n"))
            ;; Prepare headline.
            (end-of-line)
            (org-insert-heading '(16))   ; 16 = at end of list
            ;; Insert item.
            (insert str)
            (org-set-tags-to tags)))))))
#+end_src
** Default parser creates a note
#+begin_src emacs-lisp
(setq cm-default-parser
      (list :type 'note
            :predicate '-true-fn
            :parser (~ cm-value 'body)
            :handler
            (lambda (str)
              (cm--org-capture str "note")
              (cm--growl "Note" str))))
#+end_src
** Capture links
Emails containing a URL will be captured to the Links heading in the notes file.
Use another Emacs process to fetch the title for webpages.

#+begin_src emacs-lisp
(defun cm--find-uri-in-body (alist)
  "Extract the first URI from the body in ALIST. Performs loose matching."
  (-when-let (str (cm-value 'body alist))
    (-when-let
        (uri (car (s-match
                   (rx bow
                       (or
                        ;; Match URIs, with and without protocol.
                        (and "http" (? "s") "://")
                        (and "www." (* alnum) ".")
                        ;; Loosely match strings with common domains.
                        (and (+? (not (any "\r" "\n" space))) "."
                             (or "io" "edu" "net"
                                 "gov" "com" "biz"
                                 "org" "info" "co.")))
                       (* (not (any space "\n" "\r"))))
                   str)))
      ;; Set the URI's protocol to http if none is provided.
      (if (s-contains? "://" uri)
          uri
        (s-prepend "http://" uri)))))

(cm-declare-message-parser 'link
  :predicate 'cm--find-uri-in-body
  :parser 'cm--find-uri-in-body
  :handler
  (lambda (uri)
    (async-start
     `(lambda ()
        (package-initialize)
        (require 's)
        (require 'dash)
        (let* ((uri ,uri)
               (downloaded-title
                ;; Fetch webpage and download title.
                (unless (s-matches? (rx "." (or "z" "r" "t" "p" "d" "a" "w" "m")
                                        (** 2 3 alnum) eol)
                                    uri)
                  (with-timeout (10 nil)
                    (ignore-errors
                      (with-current-buffer
                          (url-retrieve-synchronously
                           (if (s-matches? (rx "http" (? "s") "://") uri)
                               uri
                             (s-prepend "http://" uri)))
                        ;; Clear request status.
                        (message nil)
                        (cadr (s-match (rx "<title>" (group (* nonl)) "</title>")
                                       (buffer-string))))))))
               ;; Escape chars used by org titles.
               (title (s-replace-all '(("[" . "(") ("]" . ")"))
                                     (or downloaded-title uri))))
          (list :uri uri
                :str (format "[[%s][%s]]" uri (s-truncate 70 title))
                :title title)))

     (lambda+ ((&key uri title str))
       (cm--org-capture str "link")
       (cm--growl "Link" (or title uri))))))
#+end_src
** Capture to diary
Dairy entries must have /diary/ as the subject, and take the form
#+begin_example
HEADLINE
DATE
NOTES*
#+end_example

#+begin_src emacs-lisp
(cm-declare-message-parser 'diary
  :predicate (~ cm-matches? (rx bol "diary") 'subject)
  :parser (lambda (alist)
            (cl-destructuring-bind (header date &rest notes)
                (s-split (rx (or "\n" (group bow (or "next" "on") eow)))
                         (cm-value 'body alist))
              (format "%s\n<%s>%s"
                      header
                      (org-read-date nil nil (or date "."))
                      (s-join "\n" notes))))
  :handler (lambda (str)
             (cm--org-capture str "diary")
             (cm--growl "Appointment" str)))
#+end_src
** Capture tasks
Tasks should have one TODO/MAYBE/NEXT as the subject

#+begin_example
HEADLINE
[t TAGS]
[s SCHEDULED-TIME]
[d DEADLINE]
NOTES
#+end_example

#+begin_src emacs-lisp
(defun cm--parse-12-hour-time (str)
  (cl-destructuring-bind (&optional _ hour min ampm &rest rest_)
      (s-match (rx (group (** 1 2 digit))
                   (? ":" (group (= 2 digit)))
                   (group (or "am" "pm")))
               str)
    (when hour
      (format "%s:%s"
              ;; Convert to 24-hour. Get the modulo just to prevent crazy times.
              (if (s-matches? "pm" ampm)
                  (mod (+ 12 (string-to-number hour))
                       24)
                hour)
              (or min "00")))))

(defun cm--parse-24-hour-time (str)
  (car (s-match (rx (** 1 2 digit) ":" (= 2 digit)) str)))

(defun cm--parse-date (str)
  (when str
    ;; Try to extract a time of day from STR.
    (-if-let (time (or (cm--parse-12-hour-time str)
                       (cm--parse-24-hour-time str)))
        (format "%s %s" (org-read-date t nil str) time)
      (org-read-date t nil str))))

(defun cm--match-directive (directive line)
  (cadr (s-match (eval `(rx bol ,directive (+ space) (group (* nonl)))) line)))

(defun cm--parse-task (alist)
  (let* ((todo-kw (cm-value 'subject alist))
         (lns (s-split "\n" (cm-value 'body alist)))
         (content
          (-remove (~ s-matches? (rx bol (or "s" "d" "t") (+ space))) lns))
         (header (car content))
         (notes (cdr content))

         (scheduled
          (->> lns
            (-keep (~ cm--match-directive "s"))
            car
            cm--parse-date))

         (deadline
          (->> lns
            (-keep (~ cm--match-directive "d"))
            car
            cm--parse-date))
         (tags
          (->> lns
            (-keep (~ cm--match-directive "t"))
            (-mapcat 's-split-words)
            (-distinct)))
         )
    (list :str
          (concat (s-upcase todo-kw) " " header
                  (when scheduled (format "\nSCHEDULED: <%s>" scheduled))
                  (when deadline  (format "\nDEADLINE: <%s>" deadline))
                  (cond
                   ((null notes) "")
                   ((= (length notes) 1)
                    (format "\n%s" (car notes)))
                   (t
                    (format "\n%s" (s-join "\n- " notes)))))

          :kind todo-kw
          :tags tags)))

(cm-declare-message-parser 'task
  :predicate
  (~ cm-matches? (rx bol (or "todo" "next" "maybe" "someday") (* space) eol)
     'subject)
  :parser 'cm--parse-task
  :handler
  (lambda+ ((&key str kind tags))
    (cond
     ((s-matches? (rx (or "next" "todo")) kind)
      (cm--org-capture str "todo" tags))
     ((s-matches? (rx (or "maybe" "someday")) kind)
      (cm--org-capture str "someday" tags))
     (t
      (error "No template for kind: %s" kind)))

    (cm--growl "Task" str)))
#+end_src
** Run on timer
#+begin_src emacs-lisp
(unless noninteractive
  (hook-fn 'after-init-hook
    (defvar cm-capture-timer
      (run-with-timer 5 60 (lambda ()
                             (capture-mail cm-capture-messages-dir))))))
#+end_src
* Quick capture
#+begin_src emacs-lisp
(defun cb-org:quick-capture (type body)
  "Use the capture-mail functionality to capture something quickly.

TYPE is the type of item.  It is ordinarily the subject for emails.

BODY is the string to interpret."
  (interactive "s[Quick Capture] Type: \ns[Quick Capture] String: ")
  (cl-loop
   with parsers = (-concat cm--parsers (list cm-default-parser))
   with alist = `((subject . ,type)
                  (body . ,body)
                  (date . (format-time-string "%FT%T%z"))
                  )
   for p in parsers do
   (cl-destructuring-bind (&key type predicate parser handler) p
     (when (funcall predicate alist)
       (-when-let
           (parsed-val
            (condition-case-unless-debug _
                (funcall parser alist)
              (error
               (display-warning 'capture-mail "Failed to parse input."))))
         (cl-return (cons type (funcall handler parsed-val))))))))

(add-to-list 'org-action-picker-options
             '("q" "Quick Capture" cb-org:quick-capture))
#+end_src
* Key bindings
Define global key bindings for org commands.
#+begin_src emacs-lisp
(bind-keys
  :overriding? t
  "C-c a" 'org-agenda
  "C-c l" 'org-store-link
  "<f6>" 'cb-org:quick-capture
  "<f7>" 'cb-org:capture
  "<f8>" 'org-action-picker
  "<f9>" 'executor:org-agenda-fullscreen)
#+end_src

Define keys for org-mode.
#+begin_src emacs-lisp
(define-keys org-mode-map
  "C-c C-." 'org-time-stamp-inactive
  "C-c o" 'org-attach-open
  "M-p" 'org-metaup
  "M-n" 'org-metadown
  "C-c c" 'org-columns
  "C-c C-j" (command (org-refile 'goto))
  ;; disable annoying comment toggle key
  "C-c ;" nil)
#+end_src
* Commands for working with latex
#+begin_src emacs-lisp
(defun org-latex-wrap ()
  (interactive)
  (let ((r (current-region)))
    (delete-region (region-beginning) (region-end))
    (insert (format "@@latex:%s@@" r))))
#+end_src
* Provide this file
#+begin_src emacs-lisp
(provide 'config-orgmode)
#+end_src
